<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>camera-imu联合标定</title>
      <link href="/2023/04/23/camera-imu%E8%81%94%E5%90%88%E6%A0%87%E5%AE%9A/"/>
      <url>/2023/04/23/camera-imu%E8%81%94%E5%90%88%E6%A0%87%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="IMU-camera联合标定"><a href="#IMU-camera联合标定" class="headerlink" title="IMU-camera联合标定"></a>IMU-camera联合标定</h1><p><img src="https://res.craft.do/user/full/263e5170-1edd-c6df-5898-f56572924e86/doc/b083fb8b-a3c8-4d57-90b3-31446d0db472/03032585-cda8-45cd-92c6-965fd90503c0" alt="概览.jpg"></p><h1 id="Kalibr"><a href="#Kalibr" class="headerlink" title="Kalibr"></a>Kalibr</h1><h3 id="kalibr官方教程"><a href="#kalibr官方教程" class="headerlink" title="kalibr官方教程"></a>kalibr官方教程</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/ethz-asl/kalibr/wiki/camera-imu-calibration">github.com</a></p></div><h1 id="ROS-Message-filter"><a href="#ROS-Message-filter" class="headerlink" title="ROS :: Message-filter"></a>ROS :: Message-filter</h1><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="http://wiki.ros.org/message_filters">wiki.ros.org</a></p></div><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-message-filters</span><br></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /opt/ros/noetic/setup.bash</span><br></pre></td></tr></table></figure><p>或者添加到<code>.bashrc</code>中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="喜闻乐见的报错环节🙃"><a href="#喜闻乐见的报错环节🙃" class="headerlink" title="喜闻乐见的报错环节🙃"></a>喜闻乐见的报错环节🙃</h3><blockquote><p>CMake Error at /opt/ros/noetic/share/catkin/cmake/catkinConfig.cmake:83 (find_package): Could not find a package configuration file provided by “message_filter” with any of the following names:    </p><p>​    message_filterConfig.cmake<br>​    message_filter-config.cmake</p><p>Add the installation prefix of “message_filter” to CMAKE_PREFIX_PATH or set “message_filter_DIR” to a directory containing one of the above files. If “message_filter” provides a separate development package or SDK, be sure it has been installed. Call Stack (most recent call first): msg_filter/CMakeLists.txt:10 (find_package)</p></blockquote><p>安装完包之后可以尝试刷新环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /opt/ros/noetic/setup.bash</span><br></pre></td></tr></table></figure><p>检查是否正确安装了包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rospack find mseeage_filter</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[rospack] Error: package <span class="string">&#x27;message_filter&#x27;</span> not found</span></span><br><span class="line">rospack find mseeage_filters</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/opt/ros/noetic/share/message_filters</span></span><br></pre></td></tr></table></figure><p>发现是因为我把<code>filters</code>写成了<code>filter</code> 😆</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><h3 id="msg-filter-subscriber"><a href="#msg-filter-subscriber" class="headerlink" title="msg_filter(subscriber)"></a>msg_filter(subscriber)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">message_filters::Subscriber&lt;sensor_msgs::Image&gt; <span class="title">image_sub</span><span class="params">(nh, <span class="string">&quot;image&quot;</span>, <span class="number">1</span>)</span>；</span></span><br></pre></td></tr></table></figure><p>从创建订阅实体<code>image_sub</code>，话题为<code>”image”</code>，消息类型为<code>&lt;sensor_msgs::Image&gt;</code></p><h4 id="ApproximateTime-policy"><a href="#ApproximateTime-policy" class="headerlink" title="ApproximateTime policy"></a><strong>ApproximateTime policy</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> sync_policies::ApproximateTime&lt;sensor_msgs::Image, geometry_msgs::WrenchStamped&gt; MySyncPolicy;</span><br></pre></td></tr></table></figure><p>​    这一行是定义了一个同步策略的类型，叫做<code>MySyncPolicy</code>，它使用了<strong>message_filters</strong>中的 <strong>ApproximateTime policy</strong> ，这个策略可以根据时间戳来匹配不同话题的消息，即使它们有不同的时间戳。这个策略需要指定两个参数，分别是要同步的两个话题的消息类型，这里是<code>sensor_msgs::Image</code>和<code>geometry_msgs::WrenchStamped</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Synchronizer&lt;MySyncPolicy&gt; <span class="title">sync</span><span class="params">(MySyncPolicy(<span class="number">10</span>), image_sub, wrench_sub)</span></span>;</span><br></pre></td></tr></table></figure><p>​    这一行是创建了一个<code>Synchronizer</code>对象，它是一个消息过滤器，可以根据指定的同步策略来同步不同话题的消息。这个对象需要三个参数，第一个是同步策略的实例，这里是<code>MySyncPolicy(10)</code>，其中 <strong>10</strong> 表示消息队列大小。第二个和第三个参数是要同步的两个话题的订阅器，这里是<strong>image_sub</strong>和<strong>wrench_sub</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync.<span class="built_in">registerCallback</span>(boost::<span class="built_in">bind</span>(&amp;callback, _1, _2));</span><br></pre></td></tr></table></figure><p>​    这一行是注册了一个回调函数，当Synchronizer对象同步了两个话题的消息后，就会调用这个回调函数，并把同步后的消息作为参数传递给它1。这里使用了<code>boost::bind</code>来绑定回调函数的地址和占位符，表示当Synchronizer对象有两个参数时，就调用<code>callback</code>函数，并把第一个参数传递给<strong>_1</strong>，第二个参数传递给<strong>_2</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">const</span> sensor_msgs::ImageConstPtr&amp; image, <span class="type">const</span> geometry_msgs::WrenchStampedConstPtr&amp; wrench)</span></span></span><br></pre></td></tr></table></figure><p>​    这一行是定义了一个回调函数<code>callback</code>，它有两个参数，分别是<code>sensor_msgs::ImageConstPtr&amp;</code>和<code>geometry_msgs::WrenchStampedConstPtr&amp;</code>。这两个参数的类型都是智能指针（smart pointer），它们可以自动管理内存，避免内存泄漏或无效指针1。智能指针的类型由消息类型加上ConstPtr后缀组成，例如<strong>sensor_msgs::Image</strong>消息对应的智能指针类型是<strong>sensor_msgs::ImageConstPtr</strong>。智能指针的好处是，它们可以在不同的节点间共享同一块内存，提高效率。在回调函数中，我们使用const修饰符和引用符号（&amp;）来表示这些参数是常量引用，也就是说我们不会修改它们的值，也不会拷贝它们的值。</p><p><img src="https://res.craft.do/user/full/263e5170-1edd-c6df-5898-f56572924e86/doc/6c0c5dad-e8aa-49de-8871-24534e9bd383/31383ea8-ce37-4d73-94bc-61c387ee2eff" alt="2023-04-22 10-04-46 的屏幕截图.png"></p><p>可以看到这个策略只能筛选出时间相近的信息，并不能对齐。🤔</p><h4 id="TimeSynchronizer"><a href="#TimeSynchronizer" class="headerlink" title="TimeSynchronizer"></a>TimeSynchronizer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimeSynchronizer&lt;sensor_msgs::Image, geometry_msgs::WrenchStamped&gt; <span class="title">sync2</span><span class="params">(image_sub, wrench_sub, <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这个同步器对时间精度的要求会比较高/</p><h3 id="mypub-publisher"><a href="#mypub-publisher" class="headerlink" title="mypub(publisher)"></a>mypub(publisher)</h3><blockquote><p>生成随机图像数据和力矢量数据<br>安装新的包</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-opencv-apps ros-noetic-cv-bridg</span><br><span class="line">source /opt/ros/noetic/setup.bash</span><br></pre></td></tr></table></figure><h4 id="创建图像"><a href="#创建图像" class="headerlink" title="创建图像"></a>创建图像</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a dummy image with random pixels</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">image</span><span class="params">(<span class="number">480</span>, <span class="number">640</span>, CV_8UC3)</span></span>;</span><br><span class="line">cv::<span class="built_in">randu</span>(image, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br></pre></td></tr></table></figure><p>​    使用OpenCV库创建了一个480x640的三通道无符号字符型矩阵，也就是一个彩色图像。然后使用cv::randu函数给图像的每个像素赋予了一个随机的颜色值，范围是从黑色（0,0,0）到白色（255,255,255）。</p><blockquote><p><strong>cv_8uc3</strong>是一个表示图像类型的枚举值，就是用来选择图像类型，它意味着每个像素由三个无符号字符组成，分别代表蓝色、绿色和红色通道。这样的图像占用了8位的空间，也就是一个字节。</p></blockquote><h4 id="转换为ROS的图像消息"><a href="#转换为ROS的图像消息" class="headerlink" title="转换为ROS的图像消息"></a>转换为ROS的图像消息</h4><p>​    首先创建了一个<code>cv_bridge::CvImage</code>对象，它包含了一个<code>std_msgs::Header</code>对象（用于存储消息的元数据），一个字符串（用于指定图像的编码方式，这里是<strong>bgr8</strong>，表示每个像素由三个无符号字符组成，分别代表蓝色、绿色和红色通道），和一个cv::Mat对象（就是前面创建的图像）。</p><p>​    然后调用了<code>toImageMsg()</code> ，将<code>cv_bridge::CvImage</code>对象转换为<code>sensor_msgs::ImagePtr</code>对象，也就是一个指向<code>sensor_msgs::Image</code>消息的智能指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// convert the image to a sensor_msgs::Image message</span></span><br><span class="line">sensor_msgs::ImagePtr msg = cv_bridge::<span class="built_in">CvImage</span>(std_msgs::<span class="built_in">Header</span>(), <span class="string">&quot;bgr8&quot;</span>, image).<span class="built_in">toImageMsg</span>();</span><br></pre></td></tr></table></figure><p>在发布的时候发布指针或者直接发送对象都可以，不过指针会快一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pub.<span class="built_in">publish</span>(msg); <span class="comment">// 发布指针</span></span><br><span class="line">pub.<span class="built_in">publish</span>(*msg); <span class="comment">// 发布指针指向的对象</span></span><br></pre></td></tr></table></figure><h4 id="添加时间戳信息"><a href="#添加时间戳信息" class="headerlink" title="添加时间戳信息"></a>添加时间戳信息</h4><p>这个其实就是这份代码最主要的部分了，虽然简单，但是我一开始确实漏了。🤫</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg-&gt;header.stamp = ros::Time::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>如果消息缺少时间戳信息的话是不会触发回调函数的。</p></div><h1 id="Recoder"><a href="#Recoder" class="headerlink" title="Recoder"></a>Recoder</h1><h3 id="Cv-bridge保存-image"><a href="#Cv-bridge保存-image" class="headerlink" title="Cv-bridge保存/image"></a>Cv-bridge保存/image</h3><p>保存<strong>sensor_msgs::Image</strong>为<strong>PNG</strong>，并且以时间戳命名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cv_bridge::CvImagePtr cv_ptr;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        cv_ptr = cv_bridge::<span class="built_in">toCvCopy</span>(msg, <span class="string">&quot;bgr8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (cv_bridge::Exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;cv_bridge exception: %s&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    使用cv_bridge::toCvCopy函数，将ROS的图像消息msg转换为OpenCV的图像，并赋值给cv_ptr。如果转换过程中发生异常，就会抛出cv_bridge::Exception类型的错误，并使用ROS_ERROR宏打印错误信息，并返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the timestamp of the image message</span></span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; msg-&gt;header.stamp;</span><br><span class="line">std::string timestamp = ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Construct the filename with timestamp</span></span><br><span class="line"><span class="type">char</span> filename[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(filename, filename_format.<span class="built_in">c_str</span>(), timestamp.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the image as a png file</span></span><br><span class="line">cv::<span class="built_in">imwrite</span>(save_path + filename, cv_ptr-&gt;image);</span><br></pre></td></tr></table></figure><p>​    将<code>msg</code>的时间戳<code>msg-&gt;header.stamp</code>转换为字符串，并赋值给<code>timestamp</code>变量。具体有关 <strong>stringstream</strong> 的内容可以参考文章后面的补充。</p><p>​    使用<code>cv::imwrite</code>函数，将OpenCV图像<code>cv_ptr-&gt;image</code>保存为<strong>png</strong>格式的文件。这个函数需要两个参数，第一个是要保存的文件路径和文件名，这里使用了save_path和filename拼接而成的字符串，<code>save_path</code>是一个预定义的变量，表示文件保存的路径，例如<code>&quot;/home/user/images/&quot;</code>。第二个参数是要保存的OpenCV图像。</p><h3 id="message-filter-cache"><a href="#message-filter-cache" class="headerlink" title="message_filter::cache"></a>message_filter::cache</h3><p>环形缓存器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set up subscriber &amp; cache</span></span><br><span class="line"><span class="function">message_filters::Subscriber&lt;sensor_msgs::Image&gt; <span class="title">sub</span><span class="params">(nh, image_topic, <span class="number">1</span>)</span></span>;</span><br><span class="line">sub.<span class="built_in">registerCallback</span>(boost::<span class="built_in">bind</span>(&amp;image_callback, _1));</span><br><span class="line">cache.<span class="built_in">connectInput</span>(sub);<span class="comment">//输入</span></span><br><span class="line">cache.<span class="built_in">setCacheSize</span>(cache_size);<span class="comment">//大小</span></span><br></pre></td></tr></table></figure><h3 id="保存-imu-amp-wrench"><a href="#保存-imu-amp-wrench" class="headerlink" title="保存/imu &amp; /wrench"></a>保存/imu &amp; /wrench</h3><p>一般选择保存为csv文件。</p><ul><li>使用<strong>rostopic echo -p</strong>命令，将订阅到的话题数据以<strong>csv</strong>格式输出到文件，例如：<code>rostopic echo -p /imu/data &gt; imu_data.csv</code></li><li>使用rosbag record命令，将订阅到的话题数据保存为rosbag文件，然后使用rosbag_to_csv包或者自己编写的脚本，将rosbag文件中的数据转换为csv文件。</li><li>使用自己编写的节点，订阅到话题数据后，使用标准库或者第三方库（如pandas）来创建和保存csv文件。</li></ul><p>前两种方法可能简单一些，但是显然即时性不太好，所以还是选择第三种好了。😋</p><h4 id="csv-parser第三方库"><a href="#csv-parser第三方库" class="headerlink" title="csv-parser第三方库"></a>csv-parser第三方库</h4><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/vincentlaucsb/csv-parser">GitHub - vincentlaucsb/csv-parser: A modern C++ library for reading, writing, and analyzing CSV (and similar) files.</a></p></div><p>我是在功能包目录下克隆仓库</p><p>在<strong>CmakeLists.txt中添加</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_subdirectory</span>(csv-parser)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(&lt;your program&gt; ...)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(&lt;your program&gt; csv)</span><br></pre></td></tr></table></figure><p>编译后在节点文件里面引用，我不能直接引用，要加上相对路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../csv-parser/single_include/csv.hpp&quot;</span></span></span><br></pre></td></tr></table></figure><p>我的文件目录</p><blockquote><p>msg_filter(功能包)</p><blockquote><p>include</p><p>src</p><blockquote><p>writeCSV_demo.cpp</p></blockquote><p>csv-parse</p><blockquote><p>single_include</p><blockquote><p>csv.hpp</p></blockquote></blockquote></blockquote></blockquote><h4 id="code-example"><a href="#code-example" class="headerlink" title="code_example"></a>code_example</h4><p>​    定义一个<code>CSVWriter</code>对象的指针，使用<code>std::ofstream</code>作为输出流类型</p><p>​    <code>csv::CSVWriter</code>是一个<strong>模板类</strong>，它需要一个模板参数，来指定输出流的类型。需要在声明CSVWriter对象的时候，提供一个模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CSVWriter&lt;std::ofstream&gt;* writer;</span><br><span class="line">writer = <span class="keyword">new</span> <span class="built_in">CSVWriter</span>&lt;std::ofstream&gt;(<span class="string">&quot;/home/stonewu/Data/test.csv&quot;</span>);</span><br></pre></td></tr></table></figure><p>或者可以使用<code>auto</code>关键字，让编译器自动推断模板参数的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> writer = <span class="keyword">new</span> <span class="built_in">CSVWriter</span>(<span class="string">&quot;/home/stonewu/Data/test.csv&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>写入数据</strong></p><p>需要注意的是<code>writer</code>是一个<strong>指针</strong>，需要先解引用指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> header = std::vector&lt;std::string&gt;&#123;<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;time&quot;</span>, <span class="string">&quot;fx&quot;</span>, <span class="string">&quot;fy&quot;</span>, <span class="string">&quot;fz&quot;</span>, <span class="string">&quot;tx&quot;</span>,<span class="string">&quot;ty&quot;</span>,<span class="string">&quot;tz&quot;</span>,<span class="string">&quot;\n&quot;</span>&#125;;</span><br><span class="line">*writer &lt;&lt; header;</span><br></pre></td></tr></table></figure><p>这个是将订阅到的数据写入CSV文件中。虽然只有短短几行代码，却花了不少时间。</p><p>​    实际上要注意的就是这个库传给writer的数据必须是<code>std::vector&lt;std::string&gt;</code>，所以要将这些数据转换为字符串形式，这里使用了<code>ostringstream oss</code>来存储。但是也不能直接通过ostringstream来构造一个<strong>vector<string></strong>，所以又构造了一个<code>istringstream</code>来作为中介。</p><p>​    也不能通过<code>&lt;&lt;endl</code>来输入换行，这里直接用<code>“\n”</code>即可。    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrench_callback</span><span class="params">(<span class="type">const</span> geometry_msgs::WrenchStampedConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将消息中的数据写入到CSV文件中</span></span><br><span class="line">    ostringstream oss;</span><br><span class="line">    oss &lt;&lt; msg-&gt;header.stamp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; msg-&gt;wrench.force.x &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">        &lt;&lt; msg-&gt;wrench.force.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; msg-&gt;wrench.force.z &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">        &lt;&lt; msg-&gt;wrench.torque.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; msg-&gt;wrench.torque.y &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">        &lt;&lt; msg-&gt;wrench.torque.z&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 创建一个vector&lt;string&gt;对象</span></span><br><span class="line">    vector&lt;string&gt; data;</span><br><span class="line">    <span class="comment">// 创建一个istringstream对象，用来读取oss中的字符串</span></span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(oss.str())</span></span>;</span><br><span class="line">    <span class="comment">// 创建一个string对象，用来存储每个子字符串</span></span><br><span class="line">    string word;</span><br><span class="line">    <span class="comment">// 使用空格作为分隔符，循环读取每个子字符串</span></span><br><span class="line">    <span class="keyword">while</span> (iss &gt;&gt; word) &#123;</span><br><span class="line">      <span class="comment">// 将子字符串放入向量中</span></span><br><span class="line">      data.<span class="built_in">push_back</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line">    *writer &lt;&lt; data ;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rosbag工具"><a href="#rosbag工具" class="headerlink" title="rosbag工具"></a>rosbag工具</h4><p>使用rosbag工具录制topic数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -O output.bag /imu /wrench</span><br></pre></td></tr></table></figure><p>这样可以将<strong>/imu</strong>和<strong>/wrench</strong>主题的数据保存到<strong>output.bag</strong>文件中。</p><p>回放数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play output.bag</span><br></pre></td></tr></table></figure><p>使用<strong>rostopic</strong>完成数据转存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rostopic echo -b output.bag -p /imu &gt; imu.csv</span><br><span class="line">rostopic echo -b output.bag -p /wrench &gt; wrench.csv</span><br></pre></td></tr></table></figure><p>这样就可以将/<strong>imu</strong>和/<strong>wrench</strong>主题的数据保存到<strong>imu.csv</strong>和<strong>wrench.csv</strong>文件中，它们是以逗号分隔的文本格式。</p><h3 id="Keyboard-Input"><a href="#Keyboard-Input" class="headerlink" title="Keyboard Input"></a>Keyboard Input</h3><h4 id="原来的keyboard扫描函数"><a href="#原来的keyboard扫描函数" class="headerlink" title="原来的keyboard扫描函数"></a>原来的keyboard扫描函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">scanKeyboard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> in;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">termios</span> new_settings;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">termios</span> stored_settings;</span><br><span class="line">    <span class="comment">//设置终端参数</span></span><br><span class="line"><span class="built_in">tcgetattr</span>(<span class="number">0</span>,&amp;stored_settings);</span><br><span class="line">new_settings = stored_settings;</span><br><span class="line">new_settings.c_lflag &amp;= (~ICANON);</span><br><span class="line">new_settings.c_cc[VTIME] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">tcgetattr</span>(<span class="number">0</span>,&amp;stored_settings);</span><br><span class="line">new_settings.c_cc[VMIN] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">tcsetattr</span>(<span class="number">0</span>,TCSANOW,&amp;new_settings);</span><br><span class="line">in = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="built_in">tcsetattr</span>(<span class="number">0</span>,TCSANOW,&amp;stored_settings);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> in;<span class="comment">//返回的是字符对应的ascii码</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个函数会一直等待输入，直到有键盘按键被按下。它使用了<code>tcsetattr</code>函数来修改终端的属性，将其设置为非规范模式（non-canonical mode），这意味着输入不会被缓冲，而是立即被读取。同时，它将VMIN属性设置为1，表示至少需要一个字符才能返回。因此，这个函数会阻塞其他函数的进行，除非有键盘输入。</p><h4 id="重新设置终端参数"><a href="#重新设置终端参数" class="headerlink" title="重新设置终端参数"></a>重新设置终端参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new_settings.c_lflag &amp;= ~(ICANON | ECHO); </span><br><span class="line"><span class="comment">//当关闭规范模式时，输入不会被缓冲，而是立即被读取</span></span><br><span class="line"><span class="comment">//如果开启规范模式，输入会被缓冲，直到遇到换行符或文件结束符才会被读取（真的吗）</span></span><br><span class="line">new_settings.c_cc[VTIME] = <span class="number">0</span>; <span class="comment">//设置超时时间为0，即不等待输入</span></span><br><span class="line">new_settings.c_cc[VMIN] = <span class="number">0</span>; <span class="comment">//设置最小字符数为0，即不需要输入任何字符就可以读取</span></span><br></pre></td></tr></table></figure><p><strong>指令集</strong></p><blockquote><ul><li>q: save latest data</li><li>w: save all data</li><li>b: begin to save data</li><li>stop saving data</li></ul></blockquote><h1 id="c-与ros库-补充"><a href="#c-与ros库-补充" class="headerlink" title="c++与ros库 补充"></a>c++与ros库 补充</h1><h3 id="boost-bind"><a href="#boost-bind" class="headerlink" title="boost::bind"></a>boost::bind</h3><p>假设我们有一个函数<strong>f</strong>，它接受三个整数参数，并返回它们的和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>boost::bind</code>来创建一个新的函数对象，它只接受一个整数参数，并把它作为f的第二个参数，而把第一和第三个参数固定为1和2。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boost::function&lt;<span class="type">int</span> (<span class="type">int</span>)&gt; g = boost::<span class="built_in">bind</span>(f, <span class="number">1</span>, _1, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这里，_1是一个占位符，表示g的第一个参数。我们可以这样调用g：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">g</span>(<span class="number">3</span>); <span class="comment">// x = f(1, 3, 2) = 6</span></span><br><span class="line"><span class="type">int</span> y = <span class="built_in">g</span>(<span class="number">4</span>); <span class="comment">// y = f(1, 4, 2) = 7</span></span><br></pre></td></tr></table></figure><p>我们也可以使用<code>boost::bind</code>来绑定类的成员函数。假设我们有一个类<code>myclass</code>，它有一个成员函数<strong>fun</strong>，它接受一个整数参数，并打印它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>boost::bind</code>来创建一个函数对象，它接受一个<code>myclass</code>的对象和一个整数参数，并调用该对象的<code>fun</code>方法。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boost::function&lt;<span class="type">void</span> (myclass&amp;, <span class="type">int</span>)&gt; h = boost::<span class="built_in">bind</span>(&amp;myclass::fun, _1, _2);</span><br></pre></td></tr></table></figure><p>这里，<strong>_1</strong>和<strong>_2</strong>分别表示h的第一和第二个参数。我们可以这样调用h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myclass mc;</span><br><span class="line"><span class="built_in">h</span>(mc, <span class="number">5</span>); <span class="comment">// mc.fun(5)</span></span><br><span class="line"><span class="built_in">h</span>(mc, <span class="number">6</span>); <span class="comment">// mc.fun(6)</span></span><br></pre></td></tr></table></figure><p>Q: 定义的h有三个参数，但是我们只给他两个参数也是可以的对吗?</p><p>A: 定义的h只有两个参数，因为我们使用了boost::bind来绑定myclass的成员函数fun，它本身就是一个参数。所以h的第一个参数是一个myclass的对象，第二个参数是一个整数。我们给h两个参数就可以了，不需要再给fun传递参数。</p><h3 id="sensor-msgs-Image"><a href="#sensor-msgs-Image" class="headerlink" title="sensor_msgs::Image"></a>sensor_msgs::Image</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 这个消息包含了一个未压缩的图像</span><br><span class="line"># (<span class="number">0</span>, <span class="number">0</span>) 是图像的左上角</span><br><span class="line">#</span><br><span class="line"># Header header        # Header timestamp 应该是图像获取的时间</span><br><span class="line">#                      # Header frame_id 应该是相机的光学帧</span><br><span class="line">#                      # 帧的原点应该是相机的光学中心</span><br><span class="line">#                      # +x 指向图像的右边</span><br><span class="line">#                      # +y 指向图像的下边</span><br><span class="line">#                      # +z 指向图像的平面</span><br><span class="line">#                      # 如果这里的 frame_id 和与图像相关联的 CameraInfo 消息的 frame_id 冲突</span><br><span class="line">#                      # 行为是未定义的</span><br><span class="line">uint32 height         # 图像高度，也就是行数</span><br><span class="line">uint32 width          # 图像宽度，也就是列数</span><br><span class="line"># 合法的编码值在文件 src/image_encodings.cpp 中</span><br><span class="line"># 如果你想标准化一个新的字符串格式，加入</span><br><span class="line"><span class="meta"># ros-users@lists.sourceforge.net 并发送一封邮件提出一个新的编码。</span></span><br><span class="line">string encoding       # 像素的编码 -- 通道的含义，顺序，大小</span><br><span class="line">                      # 从 include/sensor_msgs/image_encodings.h 中的字符串列表中取得</span><br><span class="line">uint8 is_bigendian    # 这个数据是否为大端序</span><br><span class="line">uint32 step           # 每行的字节数</span><br><span class="line">uint8[] data          # 实际的矩阵数据，大小是 (step * rows)</span><br></pre></td></tr></table></figure><h3 id="外部参数获取"><a href="#外部参数获取" class="headerlink" title="外部参数获取"></a>外部参数获取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string image_topic;</span><br><span class="line"><span class="function">ros::NodeHandle <span class="title">pnh</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line">pnh.<span class="built_in">param</span>&lt;std::string&gt;(<span class="string">&quot;image_topic&quot;</span>, image_topic, <span class="string">&quot;/camera/image_raw&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>param</strong>方法有三个参数</p><ul><li>参数的名字</li><li>参数的值</li><li>参数的默认值</li></ul><p>param方法会尝试从参数服务器或者命令行参数中获取指定名字的参数，如果成功，就将其赋值给第二个参数，如果失败，就使用第三个参数作为默认值。</p><p><strong>rosparam工具</strong></p><p>将image_topic参数的值设置为/camera/image</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam set image_topic /camera/image</span><br></pre></td></tr></table></figure><p>使用rosparam get命令来获取参数的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam get image_topic</span><br></pre></td></tr></table></figure><p>运行ROS节点的时候，通过命令行参数来设置参数的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun image_saver_node image_saver_node _image_topic:=/camera/image</span><br></pre></td></tr></table></figure><blockquote><p>注意，私有参数的名字前面要加一个下划线 <strong>_</strong></p></blockquote><h3 id="node命名空间"><a href="#node命名空间" class="headerlink" title="node命名空间"></a>node命名空间</h3><p>话题<code>/camera/image</code>中的<strong>camera</strong>和<strong>image</strong>分别是什么意思呢</p><p><a href="http://wiki.ros.org/ROS/Patterns/Conventions">话题/camera/image中的camera和image分别是话题的命名空间和基本名。话题的命名空间是用来组织和区分不同的话题的，它可以有多个层级，用斜杠/分隔。话题的基本名是用来描述话题的内容或者功能的，它不能包含斜杠/或者波浪线~。话题的命名空间和基本名都应该遵循一些命名规范1</a>，例如：</p><ul><li>话题的命名空间和基本名都应该使用小写字母，下划线_和数字。</li><li>话题的基本名应该尽量具有描述性，例如laser_scan而不是scan。</li><li>话题的命名空间应该尽量避免使用全局或者私有的前缀，例如/ros或者~。</li></ul><p>在这个例子中，camera是一个命名空间，表示这个话题是关于相机的。image是一个基本名，表示这个话题传输的是图像数据。你可以使用rosnode list命令来查看当前系统中所有的话题列表。</p><p>那么我在订阅的时候这两周写法效果是一样的吗</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ros::Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;image&quot;</span>, <span class="number">1</span>, imageCallback);</span><br><span class="line"></span><br><span class="line">ros::Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;/camera/image&quot;</span>, <span class="number">1</span>, imageCallback);</span><br></pre></td></tr></table></figure><p>不一定。这两种写法的效果取决于你的节点的命名空间。如果你的节点的命名空间是/，也就是全局命名空间，那么这两种写法的效果是一样的，都会订阅到/camera/image这个话题。但是如果你的节点的命名空间不是/，例如/wg，那么这两种写法的效果就不一样了。第一种写法会订阅到/wg/image这个话题，而第二种写法仍然会订阅到/camera/image这个话题。这是因为第一种写法使用了相对名称，而第二种写法使用了全局名称。相对名称会根据节点的命名空间进行解析，而全局名称不会。</p><p>请告诉我如何获取或者修改我的节点的命名空间。</p><p><a href="http://wiki.ros.org/Names">你可以使用rosnode命令来获取或者修改你的节点的命名空间。rosnode命令是一个用于显示和管理节点信息的命令行工具1</a>。你可以使用rosnode info命令来获取节点的详细信息，包括节点的命名空间，例如：</p><p>rosnode info /wg/node1</p><p>这样就会打印出/wg/node1节点的信息，其中第一行就是节点的命名空间，例如：</p><p>Node [/wg/node1] Publications:</p><ul><li>/wg/image [sensor_msgs/Image]</li><li>/rosout [rosgraph_msgs/Log]</li></ul><p>Subscriptions:</p><ul><li>/camera/image [sensor_msgs/Image]</li></ul><p>Services:</p><ul><li>/wg/node1/get_loggers</li><li>/wg/node1/set_logger_level</li></ul><p>你也可以在运行节点的时候，使用__ns参数来修改节点的命名空间，例如：</p><p>rosrun image_saver_node image_saver_node __ns:=/camera</p><p><a href="http://wiki.ros.org/Nodes">这样就会将image_saver_node节点的命名空间设置为/camera。你也可以在launch文件中使用ns属性来设置节点的命名空间2</a>，例如：</p><p>这样也会将image_saver_node节点的命名空间设置为/camera。</p><p>那么在默认情况下的节点都是在全局命名空间对吗，我是否能在代码的程序里面修改呢</p><p>不一定。在默认情况下，节点的命名空间是由ros::init函数的第二个参数决定的。这个参数是一个ros::NodeHandle类型的引用，它可以指定节点的命名空间和名称。如果你不提供这个参数，或者提供一个空的ros::NodeHandle，那么节点的命名空间就是/，也就是全局命名空间。但是如果你提供了一个非空的ros::NodeHandle，那么节点的命名空间就是由这个ros::NodeHandle指定的。例如：</p><p>ros::init(argc, argv, “image_saver_node”);</p><p>这样就会将节点的名称设置为image_saver_node，而节点的命名空间设置为/。</p><p>ros::NodeHandle nh(“/camera”); ros::init(argc, argv, “image_saver_node”, nh);</p><p>这样就会将节点的名称设置为image_saver_node，而节点的命名空间设置为/camera。</p><h3 id="std-stringstream"><a href="#std-stringstream" class="headerlink" title="std::stringstream"></a>std::stringstream</h3><blockquote><p>stringstream是一个C++中的类，它可以用来操作字符串。stringstream可以将字符串转换为其他类型，例如数值，也可以将其他类型转换为字符串。stringstream还可以对字符串进行格式化，例如添加空格或者0填充。stringstream的用法类似于输入输出流，可以使用&lt;&lt;和&gt;&gt;运算符来向其中插入或者提取数据。stringstream的内部有一个字符串缓冲区，可以使用str()方法来获取或者设置。</p></blockquote><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个stringstream对象</span></span><br><span class="line">std::stringstream ss;  </span><br><span class="line"><span class="comment">// 向其中插入字符串和数值 </span></span><br><span class="line">ss &lt;&lt; “Hello” &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">2021</span>; </span><br><span class="line"><span class="comment">// 输出缓冲区的内容，结果是Hello 2021 int n; </span></span><br><span class="line">std::cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>从缓冲区提取数值的时候，<strong>stringstream</strong> 会按照空格或者换行符来分隔数据，然后尝试将第一个分隔的数据转换为目标类型。如果转换成功，就返回这个数值，如果转换失败，就返回 <strong>0</strong>，并且设置错误状态标志。提取之后，ss内的缓冲区内容不会改变，::但是会有一个内部指针指向下一个要提取的数据的位置::。你可以使用<code>tellg()</code>方法来获取这个指针的位置，也可以使用<code>seekg()</code>方法来移动这个指针。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个stringstream对象 </span></span><br><span class="line">std::stringstream ss;</span><br><span class="line"><span class="comment">// 向其中插入字符串和数值 </span></span><br><span class="line">ss &lt;&lt; “Hello” &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">2021</span>; </span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"><span class="comment">// 从缓冲区中提取一个数值 </span></span><br><span class="line">ss &gt;&gt; n; </span><br><span class="line"><span class="comment">// 输出提取的数值，结果是0，因为Hello不能转换为int</span></span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl;  </span><br><span class="line"><span class="comment">// 输出内部指针的位置，结果是5，表示下一个要提取的数据是空格 </span></span><br><span class="line">std::cout &lt;&lt; ss.<span class="built_in">tellg</span>() &lt;&lt; std::endl; </span><br><span class="line"><span class="comment">// 移动内部指针到位置6，表示下一个要提取的数据是2021 </span></span><br><span class="line">ss.<span class="built_in">seekg</span>(<span class="number">6</span>); </span><br><span class="line"><span class="comment">// 从缓冲区中提取一个数值 </span></span><br><span class="line">ss &gt;&gt; n; </span><br><span class="line"><span class="comment">// 输出提取的数值，结果是2021</span></span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>提取的时候，<code>::stringstream</code>会<strong>自动跳过</strong>空格或者换行符，直到遇到非空白字符为止。提取的顺序是<strong>从左往右</strong>的，也就是从缓冲区的开头到结尾的顺序。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个stringstream对象</span></span><br><span class="line">std::stringstream ss;  </span><br><span class="line"><span class="comment">// 向其中插入一些数值，中间用空格分隔</span></span><br><span class="line">ss &lt;&lt; “<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>”;  </span><br><span class="line"><span class="comment">// 从缓冲区中提取一个数值输出，结果是1 </span></span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line">ss &gt;&gt; n;  </span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl; </span><br><span class="line"><span class="comment">// 从缓冲区中提取一个数值，输出,结果是2</span></span><br><span class="line">ss &gt;&gt; n;</span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl; </span><br><span class="line"><span class="comment">// 从缓冲区中提取一个数值，输出,结果是3</span></span><br><span class="line">ss &gt;&gt; n; </span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h4 id="ostringstream-amp-istringstream"><a href="#ostringstream-amp-istringstream" class="headerlink" title="ostringstream &amp; istringstream"></a>ostringstream &amp; istringstream</h4><p>从前缀可以看出来，一个用作输出，一个只用作输入。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 滤波器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高压线巡检机器人</title>
      <link href="/2023/04/17/%E9%AB%98%E5%8E%8B%E7%BA%BF%E5%B7%A1%E6%A3%80%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2023/04/17/%E9%AB%98%E5%8E%8B%E7%BA%BF%E5%B7%A1%E6%A3%80%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="设计说明书——高压线巡检机器人"><a href="#设计说明书——高压线巡检机器人" class="headerlink" title="设计说明书——高压线巡检机器人"></a>设计说明书——高压线巡检机器人</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="一、选题的背景和要求"><a href="#一、选题的背景和要求" class="headerlink" title="一、选题的背景和要求"></a>一、选题的背景和要求</h2><h3 id="1-1-研究背景和意义"><a href="#1-1-研究背景和意义" class="headerlink" title="1.1 研究背景和意义"></a>1.1 研究背景和意义</h3><h3 id="1-2-巡检线路环境"><a href="#1-2-巡检线路环境" class="headerlink" title="1.2 巡检线路环境"></a>1.2 巡检线路环境</h3><h3 id="1-3-机构设计的具体要求"><a href="#1-3-机构设计的具体要求" class="headerlink" title="1.3 机构设计的具体要求"></a>1.3 机构设计的具体要求</h3><h2 id="二、整体方案的拟定及说明"><a href="#二、整体方案的拟定及说明" class="headerlink" title="二、整体方案的拟定及说明"></a>二、整体方案的拟定及说明</h2><h3 id="2-1-整体机构组成"><a href="#2-1-整体机构组成" class="headerlink" title="2.1 整体机构组成"></a>2.1 整体机构组成</h3><h3 id="2-2-整体方案分析"><a href="#2-2-整体方案分析" class="headerlink" title="2.2 整体方案分析"></a>2.2 整体方案分析</h3><h3 id="2-3-人员分工"><a href="#2-3-人员分工" class="headerlink" title="2.3 人员分工"></a>2.3 人员分工</h3><h2 id="三、行走机构综合设计"><a href="#三、行走机构综合设计" class="headerlink" title="三、行走机构综合设计"></a>三、行走机构综合设计</h2><h2 id="3-0-总体设计方案"><a href="#3-0-总体设计方案" class="headerlink" title="3.0 总体设计方案"></a>3.0 总体设计方案</h2><h2 id="3-1-运动结构设计方案"><a href="#3-1-运动结构设计方案" class="headerlink" title="3.1 运动结构设计方案"></a>3.1 运动结构设计方案</h2><h3 id="3-1-1-连杆机构"><a href="#3-1-1-连杆机构" class="headerlink" title="3.1.1 连杆机构"></a>3.1.1 连杆机构</h3><h3 id="3-1-2-高度补偿机构"><a href="#3-1-2-高度补偿机构" class="headerlink" title="3.1.2 高度补偿机构"></a>3.1.2 高度补偿机构</h3><h3 id="3-1-3-动力装置"><a href="#3-1-3-动力装置" class="headerlink" title="3.1.3 动力装置"></a>3.1.3 动力装置</h3><h3 id="3-1-4-整体运动流程"><a href="#3-1-4-整体运动流程" class="headerlink" title="3.1.4 整体运动流程"></a>3.1.4 整体运动流程</h3><h2 id="3-2-尺寸综合与应力分析"><a href="#3-2-尺寸综合与应力分析" class="headerlink" title="3.2 尺寸综合与应力分析"></a>3.2 尺寸综合与应力分析</h2><h3 id="3-2-1-机体尺寸与越障尺寸"><a href="#3-2-1-机体尺寸与越障尺寸" class="headerlink" title="3.2.1 机体尺寸与越障尺寸"></a>3.2.1 机体尺寸与越障尺寸</h3><h3 id="3-2-2-连杆机构应力优化"><a href="#3-2-2-连杆机构应力优化" class="headerlink" title="3.2.2 连杆机构应力优化"></a>3.2.2 连杆机构应力优化</h3><h2 id="3-3-动力分析与选型"><a href="#3-3-动力分析与选型" class="headerlink" title="3.3 动力分析与选型"></a>3.3 动力分析与选型</h2><h2 id="四、平衡机构具体设计方案"><a href="#四、平衡机构具体设计方案" class="headerlink" title="四、平衡机构具体设计方案"></a>四、平衡机构具体设计方案</h2><h3 id="4-1平衡机构设计要求及方案"><a href="#4-1平衡机构设计要求及方案" class="headerlink" title="4.1平衡机构设计要求及方案"></a>4.1平衡机构设计要求及方案</h3><h3 id="4-2齿轮齿条传动"><a href="#4-2齿轮齿条传动" class="headerlink" title="4.2齿轮齿条传动"></a>4.2齿轮齿条传动</h3><h3 id="4-3-齿轮齿条传动平衡机构与行走机构配合"><a href="#4-3-齿轮齿条传动平衡机构与行走机构配合" class="headerlink" title="4.3 齿轮齿条传动平衡机构与行走机构配合"></a>4.3 齿轮齿条传动平衡机构与行走机构配合</h3><h2 id="五、夹爪机构具体设计方案"><a href="#五、夹爪机构具体设计方案" class="headerlink" title="五、夹爪机构具体设计方案"></a>五、夹爪机构具体设计方案</h2><h3 id="5-1总体设计方案"><a href="#5-1总体设计方案" class="headerlink" title="5.1总体设计方案"></a>5.1总体设计方案</h3><h3 id="5-2夹爪机构爆炸图"><a href="#5-2夹爪机构爆炸图" class="headerlink" title="5.2夹爪机构爆炸图"></a>5.2夹爪机构爆炸图</h3><h3 id="5-3夹爪机构应力分析"><a href="#5-3夹爪机构应力分析" class="headerlink" title="5.3夹爪机构应力分析"></a>5.3夹爪机构应力分析</h3><h2 id="六、脱线控制机构具体设计方案"><a href="#六、脱线控制机构具体设计方案" class="headerlink" title="六、脱线控制机构具体设计方案"></a>六、脱线控制机构具体设计方案</h2><h3 id="6-1、总体设计方案"><a href="#6-1、总体设计方案" class="headerlink" title="6.1、总体设计方案"></a>6.1、总体设计方案</h3><h3 id="6-2、凸轮齿轮齿条机构"><a href="#6-2、凸轮齿轮齿条机构" class="headerlink" title="6.2、凸轮齿轮齿条机构"></a>6.2、凸轮齿轮齿条机构</h3><h3 id="6-3、不完全齿轮齿条机构"><a href="#6-3、不完全齿轮齿条机构" class="headerlink" title="6.3、不完全齿轮齿条机构"></a>6.3、不完全齿轮齿条机构</h3><h3 id="6-4、齿轮系机构"><a href="#6-4、齿轮系机构" class="headerlink" title="6.4、齿轮系机构"></a>6.4、齿轮系机构</h3><h3 id="6-5、总结"><a href="#6-5、总结" class="headerlink" title="6.5、总结"></a>6.5、总结</h3><h2 id="七、收获与感想"><a href="#七、收获与感想" class="headerlink" title="七、收获与感想"></a>七、收获与感想</h2><hr><h1 id="一、选题的背景和要求-1"><a href="#一、选题的背景和要求-1" class="headerlink" title="一、选题的背景和要求"></a>一、选题的背景和要求</h1><h2 id="1-1-研究背景和意义-1"><a href="#1-1-研究背景和意义-1" class="headerlink" title="1.1 研究背景和意义"></a>1.1 研究背景和意义</h2><p>电力传输过程中不可或缺的设备之一就是高压线路，其影响了电力传输系统的可靠性和安全性。传输系统中的杆塔或者电线由于长期暴露在野外或者受到环境和机械的作用会产生多种形式的故障和安全隐患,如: 导线机械破损、连接金具松脱及线路电气故障等，如不及时发现排除，最终可能将导致重大停电事故或人身安全事故，带来极大的社会影响和经济损失。</p><p>所以输电线路的巡检作业是高压线维护中最重要的作业之一，通过对输电线路周围环境和线路运行环境的检查，及时发现并消除隐患，实现对事故的提前预防，保证供电安全万无一失。然而当前阶段，我国多采取操作人员借助绝缘斗臂车带电作业方式，需要多名操作人员在高空和地面，在高压、强电磁场等极端危险环境下进行接线、解线、并线等手工操作，劳动强度大，精神高度紧张。这种带电作业方式不仅培训难度大，给操作人员带来人身危险，而且作业效率低下。</p><p>因此，我们想设计一款高压线巡检机器人，可沿输电线路行走的同时还需要能跨越障碍物，可以使用便携式仪器设备近距离检查，既能完成巡检，又能完成线路的简单维护。</p><h2 id="1-2-巡检线路环境-1"><a href="#1-2-巡检线路环境-1" class="headerlink" title="1.2 巡检线路环境"></a>1.2 巡检线路环境</h2><p>在我国的架空输电线路中 110kv 以上的超高压线路是主要的输电线路，其覆盖面广，一般的通过高度为 12-30 米，两耐张塔间隔为 200-600 米，线缆直径为。</p><p>高压输电线路的主要元器件导线、耐张塔以及包括绝缘子串、联结金具、保护金具等在内的线路上附属设备，这些元器件组合在一起，构成特殊的线路环境。</p><ul><li><p>典型障碍物</p><ul><li><p>防震锤：</p><p>防震锤常挂在靠近绝缘子两侧的线路上，来平衡因外力引起的振动，减轻对线路的损伤</p></li><li><p>悬垂线夹：</p><p>将导线固定在直线杆塔的绝缘子串上，或将避雷线（地线）悬挂在直线杆塔上，也可用于换位杆塔上支持换位导线以及耐张转角杆塔跳线的固定</p></li></ul></li></ul><p>依据悬垂线夹的悬垂角确定巡检机器人线上爬坡最大角度<strong>一般小于25°</strong></p><p><img src="https://s2.loli.net/2023/04/17/KVeCTBL5dyEIli1.png" alt="悬垂线夹.png"></p><p>悬垂线夹</p><p><img src="https://s2.loli.net/2023/04/17/QF74oR53SbZjaiL.png" alt="耐张绝缘子串.png"></p><p>耐张绝缘子串</p><p><img src="https://s2.loli.net/2023/04/17/KyLZUSu3sHPY1nR.png" alt="间隔棒.png"></p><p>间隔棒</p><h2 id="1-3-机构设计的具体要求-1"><a href="#1-3-机构设计的具体要求-1" class="headerlink" title="1.3 机构设计的具体要求"></a>1.3 机构设计的具体要求</h2><ol><li>线上行走，至少具有30°的爬坡能力；</li><li>为减轻高压线承重，整体机构尽量设计轻便；</li><li>能较为平稳地跨越障碍物；</li><li>具有足够的稳定性，能够抵抗高空环境下风力等外部因素的影响；</li><li>预留出合适的空间以加装控制箱及检修相关传感器。</li></ol><hr><h2 id="二、整体方案的拟定及说明-1"><a href="#二、整体方案的拟定及说明-1" class="headerlink" title="二、整体方案的拟定及说明"></a>二、整体方案的拟定及说明</h2><h2 id="2-1-整体机构组成-1"><a href="#2-1-整体机构组成-1" class="headerlink" title="2.1 整体机构组成"></a>2.1 整体机构组成</h2><ul><li>行走避障机构</li><li>机体平衡机构</li><li>夹爪机构</li><li>脱线控制机构</li></ul><h2 id="2-2-整体方案分析-1"><a href="#2-2-整体方案分析-1" class="headerlink" title="2.2 整体方案分析"></a>2.2 整体方案分析</h2><p>高压线直径一般为78mm左右；</p><p>根据常见障碍物尺寸，机器人在线上跨越障碍时应有几十公分的跨距。</p><p>常见的行走越障机构系统为轮臂组合式，设计行走轮和压紧轮，防止侧翻和打滑，实际中技术难点为：跨越式穿越障碍，轮臂会脱离输电线路，要使轮臂再次精准挂线，控制难度非常大；越障过程中存在单点挂线的情况，由机器人自重产生的力矩，会加大上震动的幅度，只能不断调节自身重心，保证线上姿态稳定，使控制系统更加繁杂；同时常见的轮臂式机器人往往具有较多的电机与自由度，控制难度较大。</p><p>因此，我们打算采用轮腿式行走避障机构，并且更多地将运动控制通过机械设计的方式实现。使用连杆实现行走，并通过夹爪旋转机构从此分出一部分动力根据行走机构的姿态实现夹爪的松紧控制与旋转，方便脱线与重新上线，配合完成行走。</p><h3 id="2-3-人员分工-1"><a href="#2-3-人员分工-1" class="headerlink" title="2.3 人员分工"></a>2.3 人员分工</h3><p>我们认为整体机构应该由行走避障机构、机体平衡机构、夹爪机构和夹爪旋转机构组成。组内每个成员负责各自机构的设计，包括结构设计、各部分的参数整定、仿真建模、应力分析、零部件选型等任务，最终整合汇总。</p><p>所有方案和设计的具体内容会在接下来的章节中有详细说明</p><ul><li>甲：行走避障机构、总体方案与分配</li><li>乙：机体平衡机构</li><li>丙：夹爪机构</li><li>丁：脱线控制机构</li></ul><h3 id="2-4总体效果预览"><a href="#2-4总体效果预览" class="headerlink" title="2.4总体效果预览"></a>2.4总体效果预览</h3><p><img src="https://s2.loli.net/2023/04/17/xLbi985KpD6Phqk.png" alt="总体预览.png"></p><hr><h1 id="三、行走机构综合设计-1"><a href="#三、行走机构综合设计-1" class="headerlink" title="三、行走机构综合设计"></a>三、行走机构综合设计</h1><h2 id="3-0-总体设计方案-1"><a href="#3-0-总体设计方案-1" class="headerlink" title="3.0 总体设计方案"></a>3.0 总体设计方案</h2><p>传统的轮式结构无法完成对障碍物的翻越，而灵活的轮臂是机器人往往具有复杂的控制方案，而且缺少稳定性。为了实现机体较为稳定地的跨越线上障碍物，我们为高压线巡检机器人设计了一个行走装置，能实现两只腿往复摆动，相互配合，交替承重，在维持机体的整体重心相对平稳的同时通过伸腿，行走机构末端的直线运动，收腿来跨过障碍物。</p><h2 id="3-1-运动结构设计方案-1"><a href="#3-1-运动结构设计方案-1" class="headerlink" title="3.1 运动结构设计方案"></a>3.1 运动结构设计方案</h2><p><strong>预期功能</strong>：</p><ol><li><strong>腿部主体往复摆动的运动方式：</strong>为了使行走机构能越过更大的障碍物，行走机构的尺寸不可避免的会设计的比较大。如果想获得较大的空间，则可以将腿架设在机体两侧，但这样一来为了保持平衡总共便需要四只腿和两根线缆才能使机器人悬挂作业，会带来较大的限制而且结构臃肿。因此考虑将其放在机体中间。为了减少行走机构与机器人主体之间的位置冲突，腿部机构主体应当尽量将杆件的工作角度限制在180°，采用往复摆动的方式实现前进和避障。</li><li><strong>腿部末端工作行程的运动轨迹为接近直线：</strong>高压线缆近似为一条直线，倘若腿部末端（不妨称之为足部）工作的运动轨迹不为一条直线，则其在支撑着机体前进时便会使整体重心上下移动，稳定性较低。故将足部工作轨迹尽可能拟合直线，在平稳机身的同时也可以便于夹爪对线缆的夹取和释放。</li><li><strong>足部回程运动轨迹具有较大的高度收缩：</strong>类似于人们行走时抬起脚跨过障碍物一样，行走机构也需要在回程时能使末端在竖直方向上有一定的收缩，以便于跨过障碍物。</li></ol><p><strong>行走机构效果图</strong></p><p><img src="https://s2.loli.net/2023/04/17/ysLJnwYQp7ej8aF.png" alt="行走机构渲染.png"></p><h3 id="3-1-1-连杆机构-1"><a href="#3-1-1-连杆机构-1" class="headerlink" title="3.1.1 连杆机构"></a>3.1.1 连杆机构</h3><p><strong>运动简图</strong></p><p><a href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a956a669-305b-4895-b1b6-5482bde1a871/SOLIDWORKS_Premium_2022_SP0.0_-_菱形腿3.SLDASM___2023-04-07_17-55-24_2.mp4">SOLIDWORKS Premium 2022 SP0.0 - [菱形腿3.SLDASM _] 2023-04-07 17-55-24_2.mp4</a></p><p><strong>杆长调节</strong></p><p><img src="https://s2.loli.net/2023/04/17/5ERUGySXxNL9FcD.png" alt="腿简图.png"></p><p>将整个机构大致分为上下两个部分。上半部分为一个曲柄摇杆机构，下半部分为一个五连杆机构。</p><ol><li><p>为了使行走机构具有尽可能大的步幅，我们希望上半部分的摇杆具有更大的摆动角。因此可以适当增加最上面两根杆件的长度</p></li><li><p>为了使下方的往复运动有更大的摆动角度范围，也是增加步幅，可以适当减小三角形构件的最大内角。该角不能太大，否则在运动过程中可能会出现内测两杆角度出现负值，末端轨迹会产生内折。</p></li><li><p>为了使末端具有更大的回程收缩高度，可以调节三角构件内侧边长度与最下方两杆长度关系，也可以调节上面的内角来增加内侧两边在运动过程中的最大张角。</p></li><li><p>为了使末端工作行程的轨迹中的水平部分占比更高，需要调节上方两个曲柄摇杆机构之间的关系，同时也需要调节下方机构的杆长，避免出现类似于碗装的轨迹，使整个机身尽可能平稳。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd041055-36e4-46e3-9da3-fc9cd0715079/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2023-04-06_175549.png" alt="屏幕截图 2023-04-06 175549.png"></p></li></ol><p>在调节杆长的过程中，杆件的轨迹往往很难通过我们直观的感觉去进行调节。因为可能只是某些杆长或者角度的微小变化，就会使最终的轨迹产生较大的变动；同时在杆件较多的时候，最终轨迹的影响因素也会大量增加。所以想要调节出一个比较理想的轨迹可能会比较困难。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/36e848ad-00e1-4670-89fc-d974da31dbb6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2023-04-09_130202.png" alt="屏幕截图 2023-04-09 130202.png"></p><p>所以我想能不能让电脑帮我去寻找合适的参数呢？于是我就写了一段程序来计算出杆件机构在各种参数下的末端位置，进一步得到曲柄旋转一周过程中的末端轨迹。然后套用机器学习中的梯度下降算法，最后收敛得到较为不错的一组参数。右图即为进一步优化过后得到的曲线，可以看到水平方向上的范围没有太大的变化，但是竖直方向上的高度从二十多厘米增加到了四十多厘米。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0463f01c-3142-41c8-ad15-a8cb0ac45e82/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2023-04-09_130044.png" alt="屏幕截图 2023-04-09 130044.png"></p><p>另外，为了更充分的利用空间，避免连杆之间的碰撞，连杆设计为相互交错的层状分布</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/822a9bc4-a84c-44e3-877d-f2b9e7c3aef8/Untitled.png" alt="Untitled"></p><h3 id="3-1-2-高度补偿机构-1"><a href="#3-1-2-高度补偿机构-1" class="headerlink" title="3.1.2 高度补偿机构"></a>3.1.2 高度补偿机构</h3><p>因为行走机构的工作行程大概只占据整个流程一半的时间，两只腿在交接的时候就不太稳定。就像我们在正常行走的过程中，是一只脚先落地，另一只脚再抬起来，如果一直脚刚落地另一只就立马抬起来，整个人也会不太稳定。</p><p>所以我设计了一个高度补偿装置，在夹爪松开电线的前一刻装置是压缩的，在回程到离机体最近的地方被中间的摇杆顶起来；在夹爪夹住电线的前一刻使伸长的，这样便可以保证在另一只夹爪松开前便已经抓住电线，在腿将夹爪推向电线的时候重新压缩并卡住。</p><p><strong>模型展示</strong></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb276687-39df-4479-a221-665fa5439f54/%E9%A2%84%E8%A7%88.png" alt="预览.png"></p><p><a href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d55d138-2319-4133-bdd9-52f2f4c42064/SOLIDWORKS_Premium_2022_SP0.0_-_脚踝.SLDASM___2023-04-10_22-34-26_Trim.mp4">SOLIDWORKS Premium 2022 SP0.0 - [脚踝.SLDASM _] 2023-04-10 22-34-26_Trim.mp4</a></p><p>这个结构的设计是类似于生活中常见的电风扇的按钮升降设计。当被压缩时，内部的卡槽横向移动，到最下方时弹簧将卡槽弹回，升降平台被卡在下面；当腿部连杆机构回程收缩时，提杆被中间的摇杆顶起，卡槽向左移动，平台被弹回到伸长的状态。</p><p><strong>配合连杆机构运动动画</strong></p><p><a href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/08d11488-adb9-47a3-ad95-f506964ffb70/SOLIDWORKS_Premium_2022_SP0.0_-_装机.SLDASM___2023-04-11_13-51-13_Trim_Trim.mp4">SOLIDWORKS Premium 2022 SP0.0 - [装机.SLDASM _] 2023-04-11 13-51-13_Trim_Trim.mp4</a></p><h3 id="3-1-3-动力装置-1"><a href="#3-1-3-动力装置-1" class="headerlink" title="3.1.3 动力装置"></a>3.1.3 动力装置</h3><p>将电机安装于箱体，通过皮带轮带动两个曲柄，两个腿部机构的曲柄保持180°的相位差同速运转。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a470e460-ec85-457d-ad80-bb32684a76eb/Untitled.png" alt="Untitled"></p><h3 id="3-1-4-整体运动流程-1"><a href="#3-1-4-整体运动流程-1" class="headerlink" title="3.1.4 整体运动流程"></a>3.1.4 整体运动流程</h3><p>没有遇到障碍时，通过末端轮子滚动，驱动机器人在线上移动。</p><p>机器靠近障碍</p><p>前腿收起越过障碍，后腿抓住电线并推动整体向前移动；</p><p>前腿末端接触电线，后腿仍然保持抓住电线；</p><p>前腿末端被压向电线，末端夹爪通过翻转卡住电线并夹紧，同时高度补偿机构被压缩并锁住；</p><p>前后夹爪均夹住高压线；</p><p>后腿末端夹爪翻转开始脱线，前腿拉动机体向前运动；</p><p>后腿收起越过障碍，前腿继续拉动机体向前运动；</p><p>后腿收至最低处时，摇杆推起高度补偿装置上的提杆，横板平移，高度补偿装置弹回伸长状态；</p><p>后腿夹爪回到线上，前腿夹爪也保持在线上</p><p>完成越障，回到通过末端轮子滚动，驱动机器人在线上移动的状态。</p><h2 id="3-2-尺寸综合与应力分析-1"><a href="#3-2-尺寸综合与应力分析-1" class="headerlink" title="3.2 尺寸综合与应力分析"></a>3.2 尺寸综合与应力分析</h2><h3 id="3-2-1-机体尺寸与越障尺寸-1"><a href="#3-2-1-机体尺寸与越障尺寸-1" class="headerlink" title="3.2.1 机体尺寸与越障尺寸"></a>3.2.1 机体尺寸与越障尺寸</h3><div class="table-container"><table><thead><tr><th>尺寸名称</th><th>参数大小</th></tr></thead><tbody><tr><td>机架长度</td><td>800mm</td></tr><tr><td>机架高度</td><td>450mm</td></tr><tr><td>机架宽度</td><td>350mm</td></tr><tr><td>水平方向步幅</td><td>700mm</td></tr><tr><td>竖直方向收腿距离</td><td>420mm</td></tr><tr><td>两腿中心间距</td><td>600mm</td></tr></tbody></table></div><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/402f21de-4f9d-420a-891a-b97386d5435a/Untitled.png" alt="Untitled"></p><p>可以看出，在保持一定机身尺寸的情况下该行走机构的越障能力较为不错。</p><h3 id="3-2-2-连杆机构应力优化-1"><a href="#3-2-2-连杆机构应力优化-1" class="headerlink" title="3.2.2 连杆机构应力优化"></a>3.2.2 连杆机构应力优化</h3><p>为了尽量减轻对高压线的负荷，机体应该设计的尽可能轻便，整体结构选择使用密度低强度高的铝合金。在整个机构中，负荷较大的为中间的三角形构件，主要受到剪切力的作用。</p><p>使用solidworks的simulation插件对该构件进行有限元分析，在下方两轴设置固定铰链约束，在末端施加剪切力与轴向力</p><p><strong>应力图</strong></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c31a9cac-0384-432a-9d2b-604c7e76abc3/Untitled.png" alt="Untitled"></p><p><strong>位移图</strong></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b7a035ef-91ee-4b1e-bf67-8662d0eb17a5/Untitled.png" alt="Untitled"></p><p>在中间凹陷处两侧均产生了很大的应力，最大应力达到了2.92 x 107N/m²，超过了屈服力（2.757 x 107N/m²），属于危险情况。在与固定铰支座接近的部位应力情况较为不错。在末端产生了较大的位移，相对于450mm的杆件产生了2mm左右的位移。</p><p>为了使应力分布更加均匀合理，但是同时也不过多的挤占两行走机构之间用于连接两侧箱体的空间，减小腿部机构整体的形变情况，尝试更充分利用连杆机构内侧空间，对连杆形状进行优化，重新进行分析，结果如下</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7dec4297-93c2-4de6-8b17-22d46d378ee8/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1c53ba80-5e8c-4658-a830-54c4ad8e4c44/Untitled.png" alt="Untitled"></p><p>相较于之前的情况，新机构的应力分布更为均匀，板材适量增加，所以变动是有价值的。</p><h2 id="3-3-动力分析与选型-1"><a href="#3-3-动力分析与选型-1" class="headerlink" title="3.3 动力分析与选型"></a>3.3 动力分析与选型</h2><h3 id="3-3-1-速度与位移分析"><a href="#3-3-1-速度与位移分析" class="headerlink" title="3.3.1 速度与位移分析"></a>3.3.1 速度与位移分析</h3><p><strong>水平方向速度</strong></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1816824c-9e36-4df5-ab54-46a423963618/Untitled.png" alt="Untitled"></p><p><strong>水平方向位移</strong></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b40a63af-36b4-44c4-9179-9f03be5759d0/Untitled.png" alt="Untitled"></p><p>由图可知，腿部机构末端在工作行程时基本保持匀速，可以保证在行进时机体尽可能的保持稳定；同时，机构稳定的匀速运动使得动力装置的负担减小，这让我们在选择主动力电机的时候有了更为广泛的选择，也大大降低了电控方案的复杂度。</p><h3 id="3-3-2-机架设计"><a href="#3-3-2-机架设计" class="headerlink" title="3.3.2 机架设计"></a>3.3.2 机架设计</h3><p>机架采用较为轻便的铝合金，在满足强度要求的情况下，选用欧标4040Q-1.3铝架。单位长度质量为0.9kg/m</p><p>在先前设计的基础上，可以设计出大致的基本框架。具体设计可根据实际测量设备的空间需求进一步细化设计。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0486aa9e-adfe-4553-8b1c-cff334fd10f1/Untitled.png" alt="Untitled"></p><p>总长度为0.8x4+0.45x4+0.35x2=5.7m，总质量为5.13kg</p><h3 id="3-3-3-电机选型"><a href="#3-3-3-电机选型" class="headerlink" title="3.3.3 电机选型"></a>3.3.3 电机选型</h3><p>在行走时由平衡机构的钢丝与夹爪机构共同提供拉力以平衡重力。同时，行走机构在维持机体平衡并且带动机体前进时，也需要提供足够的扭矩防止重力与上述拉力产生的残差力矩使机身倾斜。</p><p><strong>机箱大致由以下部分组成</strong></p><ul><li>电机质量 0.36kg</li><li>皮带质量 0.1kg</li><li>皮带轮质量 0.4kg</li><li>24v电池质量 1kg</li><li>机架质量 5.13kg</li><li>平衡机构质量 3kg</li><li>其他测量仪器</li></ul><p>动力轴与质心距离300mm，加上其它测量设备，整机质量保守估计为15kg，平衡机构可抵消90%力矩，设安全系数为1.5，则需求力矩为6.75NM</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/73e93010-a7da-4103-9159-0198f3dc51f6/Untitled.png" alt="Untitled"></p><p>选取F86-H114型号的步进电机即可</p><h3 id="3-3-3-控制补偿"><a href="#3-3-3-控制补偿" class="headerlink" title="3.3.3 控制补偿"></a>3.3.3 控制补偿</h3><p>步进电机通过脉冲信号控制。可以通过改变脉冲频率来调节电机转速。虽然整个行走机构在行走过程中有较为稳定的行走速度，但是仍然会有部分波动。因此，可以通过调节电机转速来对速度控制进行补偿。</p><p>电机保持转速</p><hr><h1 id="四、机体平衡机构设计"><a href="#四、机体平衡机构设计" class="headerlink" title="四、机体平衡机构设计"></a>四、机体平衡机构设计</h1><h3 id="4-1平衡机构设计要求及方案-1"><a href="#4-1平衡机构设计要求及方案-1" class="headerlink" title="4.1平衡机构设计要求及方案"></a>4.1平衡机构设计要求及方案</h3><p>机体平衡机构在避障时发挥作用，采用调整质心的方案使前爪在脱线-越障-搭线时机体能够保持平衡。</p><p>首先的想法是使用丝杠直线运动机构，电机驱动丝杠使后爪端滑块从端点滑动至机体中部附近，同时前爪端滑块保持不动，使整体质心位于中部，箱体保持水平。前爪完成越障后，后爪端滑块滑至端点，前爪端滑至中部，以使后爪完成越障。</p><p>滑块与行走避障机构间采用钢丝与弹簧连接。最终设计如下：（仅为一端）</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/835e2c1c-9eba-48e2-97f9-163a2dc0b7f1/Untitled.png" alt="Untitled"></p><h3 id="4-2齿轮齿条传动-1"><a href="#4-2齿轮齿条传动-1" class="headerlink" title="4.2齿轮齿条传动"></a>4.2齿轮齿条传动</h3><p>采用丝杠传动的不妥之处在于需要安排两条丝杠机构，这将会增加成本，于是采用齿轮齿条传动，为加强稳定性，前后爪各设两个弹簧。此机构将安装在箱体内部。</p><p>初次设计时，电机与齿轮间的传动零件太长，为增加稳定性应缩短。并且发现两齿条间距过短导致无法与避障机构配合，故增加了轴的长度。</p><p><a href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2dd8c65-fdbd-46e6-9239-adacf08158cc/11111.mp4">11111.mp4</a></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dee970b7-866d-40db-a923-d3c52a5152a4/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90750bfa-c6ef-434f-a990-4805fd6bc69f/Untitled.png" alt="Untitled"></p><h3 id="4-3-齿轮齿条传动平衡机构与行走机构配合-1"><a href="#4-3-齿轮齿条传动平衡机构与行走机构配合-1" class="headerlink" title="4.3 齿轮齿条传动平衡机构与行走机构配合"></a>4.3 齿轮齿条传动平衡机构与行走机构配合</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/77deec18-cb66-4b2a-b2a9-98565c3c9aba/Untitled.png" alt="Untitled"></p><hr><h1 id="五、夹爪机构具体设计方案-1"><a href="#五、夹爪机构具体设计方案-1" class="headerlink" title="五、夹爪机构具体设计方案"></a>五<strong>、</strong>夹爪机构具体设计方案</h1><h2 id="5-1总体设计方案-1"><a href="#5-1总体设计方案-1" class="headerlink" title="5.1总体设计方案"></a>5.1总体设计方案</h2><p>该结构由一大两小共三个轮子、底座和T形结构组成。T形结构插在底座的开孔中，孔中有弹簧，将T形结构连同两个小轮向上推，与大轮一起夹紧高压线，在底座背面有与丅形结构固连的齿条，通过齿轮转动可以将T型结构下压，从而松开高压线。考虑的高压线与地面可能并不水平，将T形结构设计为上下两部分，中间插入一根轴，使T形结构的上半部分可以进行顺时针或逆时针方向30度的转动，从而使三个轮子与高压线贴合更紧密。同时，在底座上方开槽，使大轮可以向上抬升和绕平行于高压线的轴转动。大轮为主动轮，由大轮后方电机驱动，从而实现机器人在高压线上的行进。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/06886a3a-7b69-49d0-9adb-c9271970956d/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/286c34ef-3541-4658-99bf-463aef33b237/Untitled.png" alt="Untitled"></p><h2 id="5-2夹爪机构爆炸图-1"><a href="#5-2夹爪机构爆炸图-1" class="headerlink" title="5.2夹爪机构爆炸图"></a>5.2夹爪机构爆炸图</h2><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18b9354e-5c90-42b4-a04d-3ef3d56f1cc3/Untitled.png" alt="Untitled"></p><h2 id="5-3夹爪机构应力分析-1"><a href="#5-3夹爪机构应力分析-1" class="headerlink" title="5.3夹爪机构应力分析"></a>5.3夹爪机构应力分析</h2><p>对T形结构中间转轴进行应力分析</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6adca293-456f-423f-ad65-ccab14733087/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5c652dd2-ab1e-4321-9b23-739cb419df3e/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e2e69567-66d6-488d-9462-b2e299c57f80/Untitled.png" alt="Untitled"></p><hr><h1 id="六、脱线控制机构综合设计"><a href="#六、脱线控制机构综合设计" class="headerlink" title="六、脱线控制机构综合设计"></a><strong>六、脱线控制机构综合设计</strong></h1><h2 id="6-1-总体设计方案"><a href="#6-1-总体设计方案" class="headerlink" title="6.1 总体设计方案"></a>6.1 总体设计方案</h2><p>为实现遇到障碍时，夹持机构能够从线上脱离，分别设计了凸轮齿轮齿条机构控制大轮运动、不完全齿轮齿条机构控制小轮运动以及两套齿轮系整合大轮小轮同步运动。</p><h2 id="6-2-凸轮齿轮齿条机构"><a href="#6-2-凸轮齿轮齿条机构" class="headerlink" title="6.2 凸轮齿轮齿条机构"></a>6.2 凸轮齿轮齿条机构</h2><p>遇到障碍时，我们需要使夹持装置的大轮脱离高压线，若仅抬升大轮，在配合连杆机构向下运动时将被高压线阻挡，因此我们选择旋转大轮，又因为大轮结构问题，直接旋转会与高压线冲突，因此我们选择让大轮先抬升一部分，再进行旋转。为了尽量减少电控的使用，实现仅用一个原动件控制实现该运动，我们设计了一个凸轮与齿轮齿条的配合机构。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a50a135-a2fb-4936-baa7-fdea944a991f/Untitled.png" alt="Untitled"></p><p>其运动分为两部分完成：</p><h3 id="第一阶段：抬升阶段"><a href="#第一阶段：抬升阶段" class="headerlink" title="第一阶段：抬升阶段"></a>第一阶段：抬升阶段</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6267aeb2-f80a-4919-bb2a-f586056bb940/Untitled.png" alt="Untitled"></p><h3 id="第二阶段：旋转阶段"><a href="#第二阶段：旋转阶段" class="headerlink" title="第二阶段：旋转阶段"></a>第二阶段：旋转阶段</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65cf00e0-056c-4e62-b2a6-5048ad4e9c0d/Untitled.png" alt="Untitled"></p><h2 id="6-3-不完全齿轮齿条机构"><a href="#6-3-不完全齿轮齿条机构" class="headerlink" title="6.3 不完全齿轮齿条机构"></a>6.3 不完全齿轮齿条机构</h2><p>为了使夹持机构中小轮行走时能够通过弹簧控制夹紧高压线，在遇到障碍时能够由齿轮系控制向下松开高压线，我们设计一个不完全齿轮齿条机构。</p><h3 id="1、行走状态"><a href="#1、行走状态" class="headerlink" title="1、行走状态"></a>1、行走状态</h3><p>齿轮与齿条未啮合，小轮由弹簧控制与线夹紧。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/969a67f2-30fc-48d9-a6ce-b5a237ffb20f/Untitled.png" alt="Untitled"></p><h3 id="2、脱线状态"><a href="#2、脱线状态" class="headerlink" title="2、脱线状态"></a>2、脱线状态</h3><p>遇到障碍时，齿轮与齿条啮合，小轮由齿轮系控制向下运动松开线路。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c3df8c31-d02c-424b-adb2-baac1a575661/Untitled.png" alt="Untitled"></p><h2 id="6-4-齿轮系机构"><a href="#6-4-齿轮系机构" class="headerlink" title="6.4 齿轮系机构"></a>6.4 齿轮系机构</h2><h3 id="1、连接凸轮机构部分"><a href="#1、连接凸轮机构部分" class="headerlink" title="1、连接凸轮机构部分"></a>1、连接凸轮机构部分</h3><p>根据凸轮机构尺寸，两凸轮转轴之间水平距离x=50mm，竖直距离可在一定范围内自主设计，为计算方便定为y=270mm，在此基础之上我们设计一个传动比为1：1的齿轮系。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8fb7d0a8-d7ba-4b34-a24d-faac4e3e8546/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5c2bb20e-390d-4d70-8889-ba68a5c3a8f5/Untitled.png" alt="Untitled"></p><h3 id="2、连接不完全齿轮机构部分"><a href="#2、连接不完全齿轮机构部分" class="headerlink" title="2、连接不完全齿轮机构部分"></a>2、连接不完全齿轮机构部分</h3><p>根据夹持装置和凸轮装置尺寸，可以得出齿条分度线与凸轮机构中的齿轮中心水平距离x=45mm，竖直高度可在一定范围内自主设计，我们选取一个较为合适的距离，使得不完全齿轮位于齿条槽靠近中点位置，取图1中的轮5到不完全齿轮中心竖直距离y=445mm。在此基础上我们设计一个传动比为3：2的齿轮系。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/288d6cca-a7b3-4e9f-8977-46359287acf2/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eaf49a03-2ef3-4b7d-bc76-b4fa6141670c/Untitled.png" alt="Untitled"></p><h2 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h2><p>最终将三个机构与夹持装置安装配合好之后效果如图</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4dfef081-ed01-4533-8e64-af92ebb556c5/Untitled.png" alt="Untitled"></p><p>将各零件组装配合好之后，转动主动件齿轮2，大轮先抬升再旋转，小轮同时向下松开，与预期效果相符。</p><h1 id="七、收获与感想-1"><a href="#七、收获与感想-1" class="headerlink" title="七、收获与感想"></a>七、收获与感想</h1><h3 id="吴磊："><a href="#吴磊：" class="headerlink" title="吴磊："></a>吴磊：</h3><p>在本次设计中，我收获了很多。我设计的机构主要用到了连杆机构，能将在课堂上学到的知识投入到实际应用中，也让我对课堂上的知识有了更深刻的理解与感悟。在设计机构的过程中，真切的感受到了机械学科中书本内容与实际生活的密切联系，也感受到了“纸上得来终觉浅，绝知此事要躬行”的道理。从在脑海中浮现出一个机构的大致设计方案，到将其实际建模出来，其中涉及到的具体尺寸，零件之间的配合关系，实际效果与预期效果之间的差距，应力分析，运动分析等等等等。有时候就是简单的做一个动画，也可能会遇到一些意外，耽误掉很多时间。然而这仅仅是仿真，想要实际加工出来，投入到生活生产应用中去，肯定更加的困难，对机械工作者们的敬意油然而生。</p><p>还有就是团队合作的重要性，一个复杂的机器人，将其分解为一个个部分之后就会轻松不少。在学科交叉趋势愈加明显的当下，想要一个人单打独斗是很困难的。当然团队之间的配合也十分重要，各个部分之间最后的相互配合需要队员之间相互协调。</p><p>总之，本次设计让我受益匪浅，不仅提高了我的机械设计水平和团队协作能力，也让我更加深入地了解了机器人设计的过程和要点，对我的未来学习和工作都有很大的帮助。我相信，在未来的学习和工作中，我会继续努力，不断提高自己的能力和水平，为实现更好的设计和创新做出更大的贡献。</p><h3 id="崔庆垚："><a href="#崔庆垚：" class="headerlink" title="崔庆垚："></a>崔庆垚：</h3><p>本次我们小组的设计中我的任务是负责设计脱线控制机构，投入了很多也收获了很多。</p><p>首先是运用到了许多课堂上的学习到的理论知识，能够将课堂上学习的凸轮齿轮系等知识转化为实践，对于我更深刻地理解课堂所学大有裨益，在实际的设计过程中，除了理论的计算之外还有很多现实因素需要考量，比如相邻齿轮之间齿数比不能过大、凸轮转动时尽量消除冲击等。</p><p>其次，我对于建模软件的使用水平也得到了很大提升，现在已经能够熟练使用各种基本配合，还学会了凸轮推杆配合、齿轮啮合、齿轮齿条配合等机械配合。</p><p>最后，团队协作能力也得到了培养。因为是小组设计，首先对于整体方案的讨论需要进行大量讨论协商，其次每个人的任务也不是一个完全独立的板块，各部分之间的参数要协调好，才能完成最后的同一组装。</p><h3 id="曾宇航："><a href="#曾宇航：" class="headerlink" title="曾宇航："></a>曾宇航：</h3><p>通过本次课设，我学习到了如何运用课本知识，加深了对其的理解，并且阅读了关于高压线巡线机器人的论文，惊叹于前辈们的构思、对本科知识的综合运用以及强大的实践能力。本次课设我们将该机器人设计分为了四个机构，包括齿轮齿条传动、夹爪机构具体设计、脱线控制机构综合设计等方面。本次设计不仅提高了个人的建模技能，还培养了团队协作能力。</p><p>我们小组的设计中每个人都有自己的任务，我从中学到了许多课本知识的实践应用和建模技巧。通过团队讨论和协作，我们协调了各部分之间的参数，最终完成了机器人的同一组装。通过本次课设，我学习到了如何运用理论知识解决实际问题，并且深入了解了高压线巡检机器人的构造和工作原理。同时，我也在团队协作和建模技能方面有了很大的提升。本次课设让我更加熟练地掌握了机械设计软件的使用。</p><h2 id="陈嘉浩："><a href="#陈嘉浩：" class="headerlink" title="陈嘉浩："></a>陈嘉浩：</h2><p>通过本次创新设计，我认识到了实践的重要性。原本我认为只要熟练掌握了课本上的知识点，就能较为轻松地完成这项设计。但当我真正开始动手设计时，一个又一个问题接踵而来。首先就是自己设计的结构尺寸不合理，难以和队友的结构组装在一起。还有自己对建模软件不太熟悉，总是出现各种问题。书上的知识只是我们进行设计的基础，要想真正设计出能实现某些功能并且有新意的成品，需要我们在一次一次的实践中积累经验。通过本次创新设计，让我对机械设计有了更深入的了解，对机械工作者的敬意油然而生。</p><p>这次设计也让我体会到了团队合作的重要性，有了团队，我们就能将复杂的设计分解为一个个简单的版块，每个人负责一部分，这样大大降低了设计难度。当然，在团队合作中也要多进行沟通交流，这样才能确保最后每个人负责的版块能顺利拼接到一起。</p><p>通过这次课设，加深了我对书本上知识的理解，提升了我建模水平，也培养了我团队合作的意识和能力。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机械设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Balancebot&#39;s LQR controller &amp; Rhomberg observer</title>
      <link href="/2023/04/04/Balancebot-s-LQR-controller-Rhomberg-observer/"/>
      <url>/2023/04/04/Balancebot-s-LQR-controller-Rhomberg-observer/</url>
      
        <content type="html"><![CDATA[<h1 id="平衡小车的LQR控制器与Rhomberg观测器"><a href="#平衡小车的LQR控制器与Rhomberg观测器" class="headerlink" title="平衡小车的LQR控制器与Rhomberg观测器"></a>平衡小车的LQR控制器与Rhomberg观测器</h1><h2 id="动力学分析"><a href="#动力学分析" class="headerlink" title="动力学分析"></a>动力学分析</h2><p><img src="https://s2.loli.net/2023/04/04/KMY2DAwlgVj4FsW.jpg" alt="动力学分析.jpg"></p><h2 id="控制器设计"><a href="#控制器设计" class="headerlink" title="控制器设计"></a>控制器设计</h2><h3 id="状态空间方程"><a href="#状态空间方程" class="headerlink" title="状态空间方程"></a>状态空间方程</h3><p>令$\xi = [\theta,\dot{\theta},x,\dot{x}]$；且令$\theta\to 0; \dot{\theta} \to 0$，相当于在0处进行泰勒展开</p><p>化简得到</p><script type="math/tex; mode=display">\dot{\xi} = \begin{bmatrix}0 & 1 & 0 & 0 \\\frac{M+m}{Ml}g & 0 & 0 & 0 \\0 & 0 & 0 & 1 \\-\frac{mg}{M} & 0 & 0 & 0\end{bmatrix}\xi+\begin{bmatrix}0 \\-\frac{1}{Ml} \\0 \\\frac{1}{M}\end{bmatrix}u</script><p>取输出水平力 $u = -K_1X_1-K_2X_2-K_3X_3-K_4X_4$</p><h3 id="Simulink仿真"><a href="#Simulink仿真" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p>取m=1kg, M=1kg, g=10m/s^2, l=1m</p><script type="math/tex; mode=display">Q=\begin{bmatrix}10&0&0&0 \\0&1&0&0 \\0&0&1&0 \\0&0&0&1\end{bmatrix},\quad R=0.1</script><p>取代价函数最小值，得到</p><script type="math/tex; mode=display">K = \begin{bmatrix}-70.7312  -18.9427   -3.1623   -6.4873\end{bmatrix}</script><p>使用Simulink进行仿真，设置初始Pithch角为5°</p><script type="math/tex; mode=display">\dot{x_1} = x_2 \\\dot{x_2} = 20x_1 - u \\\dot{x_3} = x_4 \\\dot{x_4} = -10x_1 + u \\u = -k_1x_1-k_2x_2-k_3x_3-k_4x_4</script><p><img src="https://s2.loli.net/2023/04/04/RuN3SLQ7ZcOwkei.png" alt="simulink-只有控制器.png"></p><p>运行得到结果</p><p><img src="https://s2.loli.net/2023/04/04/tpNQh3zaRqJCAr2.png" alt="曲线-controller only.png"></p><p><img src="https://s2.loli.net/2023/04/04/Q865WhwOrqkZfym.png" alt="曲线.png"></p><h2 id="观测器设计"><a href="#观测器设计" class="headerlink" title="观测器设计"></a>观测器设计</h2><p>观测器设计的初步学习可以参考下面这篇笔记</p><h3 id="不考虑机械中值"><a href="#不考虑机械中值" class="headerlink" title="不考虑机械中值"></a>不考虑机械中值</h3><h4 id="观测器方程"><a href="#观测器方程" class="headerlink" title="观测器方程"></a>观测器方程</h4><p>方便起见，状态变量暂时只取 $X_1,X_2$，即为 $\theta$ 和 $\dot{\theta}$ ；</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{X_1}\\\dot{X_2}\end{bmatrix} =\begin{bmatrix}0 & 1 \\ \frac{M+m}{Ml}g & 0\end{bmatrix}\begin{bmatrix}X_1 \\ X_2\end{bmatrix} +\begin{bmatrix}0 \\ -\frac{1}{Ml}\end{bmatrix} u</script><p>取输出$y=\begin{bmatrix}1&amp;0\end{bmatrix}\begin{bmatrix}X_1\\X_2\end{bmatrix}$, 则$C=\begin{bmatrix}1&amp;0\end{bmatrix}$</p><p><strong>可观测性检测</strong></p><script type="math/tex; mode=display">O=\begin{bmatrix}C\\CA\end{bmatrix}=\begin{bmatrix}1&0 \\ 0&1\end{bmatrix}</script><p>满秩，可观测</p><p><strong>观测方程</strong></p><script type="math/tex; mode=display">\begin{bmatrix}\dot{\hat{X_1}} \\ \hat{\dot{X_2}} \end{bmatrix} =\begin{bmatrix}0 & 1 \\ \frac{M+m}{Ml}g & 0\end{bmatrix}\begin{bmatrix}\hat{X_1} \\ \hat{X_2}\end{bmatrix} +\begin{bmatrix}0 \\ -\frac{1}{Ml}\end{bmatrix} u + L(y - \hat{y})</script><p><strong>由观测器和控制器分离原理</strong></p><p>令<strong>A-LC</strong>和<strong>A-BK</strong>的特征值实部分别小于<strong>0</strong>计算出<strong>L矩阵和K矩阵</strong>即可</p><h4 id="Simulink仿真-1"><a href="#Simulink仿真-1" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h4><p>直接令$(\lambda+1)^2=0$得到L矩阵和K矩阵</p><p><img src="https://s2.loli.net/2023/04/04/EjUtuBDpFL158Z3.png" alt="observer-without alpha.png"></p><p>​    左半部分为观测器系统，右半部分为理想情况下的现实物理系统。观测器能获得的数据只有角度值θ即$X_1$，由此估计出 $\hat{X_1},\hat{X_2}$，并依据这两个估计值给出控制量$u$，输入到物理系统中。</p><p>​    将物理系统中的角度初始值设为<strong>5°</strong>，将观测器中的角度初始值设置为<strong>0°</strong>，仿真运行结果如下。</p><p><img src="https://s2.loli.net/2023/04/04/m1oXUlVEHcb8vhB.png" alt="曲线3.png"></p><p><img src="https://s2.loli.net/2023/04/04/AWwOPh9sFSRDgfN.png" alt="曲线4.png"></p><p>最后观测器收敛至真实值，但是由于初始信息差的存在，导致控制效果受到了一定的影响。</p><h3 id="机械中值的收敛"><a href="#机械中值的收敛" class="headerlink" title="机械中值的收敛"></a>机械中值的收敛</h3><p>​    实际上的机械中值是没法精确测得的，并且也有可能随时间变化，所以需要设计观测器使系统可以得到真实的机械中值。</p><h4 id="不寻找机械中值的效果"><a href="#不寻找机械中值的效果" class="headerlink" title="不寻找机械中值的效果"></a>不寻找机械中值的效果</h4><p><img src="https://s2.loli.net/2023/04/04/RhmLETK2oQAtsOZ.png" alt="不寻找alpha.png"></p><p><img src="https://s2.loli.net/2023/04/04/f6Mn42WpNSoCx8r.png" alt="曲线5.png"></p><p>​    在之前的观测器系统中，直接添加 $\alpha$ 后控制系统失控，而且观测器也不再收敛。</p><p>​    如果是之前的没有观测器的模型的话，大致是这样的一个过程。平衡点在3°，当车子为0°时车子会向后倾，角度值减小；此时为了使车身回到0°，轮子也向后移动，最后角度不变，趋于匀加速移动。</p><p><img src="https://s2.loli.net/2023/04/04/vXYmMF5ySwtxTjo.png" alt="simulink.png"></p><h4 id="观测器设计-1"><a href="#观测器设计-1" class="headerlink" title="观测器设计"></a>观测器设计</h4><p>将真实的机械中值设为$\alpha$，则$\theta$应当变为$\theta - \alpha$，得到新的状态空间方程</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{X_1}\\\dot{X_2}\end{bmatrix} =\begin{bmatrix}0 & 1 \\ \frac{M+m}{Ml}g & 0\end{bmatrix}\begin{bmatrix}X_1 \\ X_2\end{bmatrix} +\begin{bmatrix}0 \\ -\frac{1}{Ml}\end{bmatrix} u + \begin{bmatrix}0 \\ -\frac{M+m}{Ml}g\end{bmatrix}\alpha</script><p>状态空间取$\hat{X} = \begin{bmatrix}\hat{\theta} &amp; \dot{\hat{\theta}} &amp; \hat{\alpha}\end{bmatrix}^T$，输出 $y = \begin{bmatrix}1&amp;0&amp;0\end{bmatrix}\begin{bmatrix}\theta \\ \dot{\theta} \\ \alpha \end{bmatrix}$</p><p>可观测性检测得可观测</p><p><strong>观测器方程</strong></p><script type="math/tex; mode=display">\begin{bmatrix}\dot{\hat{X_1}} \\ \dot{\hat{X_2}} \\ \dot{\hat{X_3}}\end{bmatrix} =\begin{bmatrix}0 & 1 & 0 \\ \frac{M+m}{Ml}g & 0 & -\frac{M+m}{Ml}g \\ 0 & 0 & 0\end{bmatrix}\begin{bmatrix}\hat{X_1} \\ \hat{X_2} \\ \hat{X_3}\end{bmatrix} +\begin{bmatrix}0 \\ -\frac{1}{Ml} \\ 0\end{bmatrix} u + \begin{bmatrix}l_1 \\ l_2 \\ l_3\end{bmatrix}(y - \hat{y})</script><p>同样可令<strong>A-LC</strong>和<strong>A-BK</strong>的特征值实部分别小于<strong>0</strong>计算出<strong>L矩阵和K矩阵</strong>即</p><p><strong>输出</strong></p><p>$u = -K_1(X_1-X_3)-K_2X_2$</p><h4 id="Simulink仿真-2"><a href="#Simulink仿真-2" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h4><p><img src="https://s2.loli.net/2023/04/04/t1fSoAO8WzYEdXj.png" alt="simulink observer.png"></p><p><img src="https://s2.loli.net/2023/04/04/kQoaeYtBSzlypbT.png" alt="曲线6.png"></p><p><img src="https://s2.loli.net/2023/04/04/ujckFSdrNGPTvHg.png" alt="曲线7.png"></p><p><img src="https://s2.loli.net/2023/04/04/wFgnhzqyjfK9c8W.png" alt="曲线8.png"></p><p>​    在观测器添加了 $\alpha$ 后，估计值 $\hat{\alpha}$ 确实可以收敛到 $\alpha$。但是在$\alpha$的估计值与真实值相差较大时，X1与X2的观测效果都不太好，导致控制效果也不太好。</p><h5 id="调整k"><a href="#调整k" class="headerlink" title="调整k"></a>调整k</h5><p>上面的控制中，为了加快收敛，我直接将输出u*5后给到系统中。u的峰值达到了580左右。</p><p>但是这样做显然是不合理的，这直接改变了系统的状态方程，虽然确实有一些用。可是更改了Q,R矩阵后依然没有太大改善。</p><h5 id="调整L矩阵"><a href="#调整L矩阵" class="headerlink" title="调整L矩阵"></a>调整L矩阵</h5><p>​    DR_CAN在课程中提到过，我们希望观测器的收敛速度大于控制器，所以尝试使<strong>A-LC</strong>矩阵的特征值更小一些。令$\lambda_1=\lambda_2=\lambda_3=-2$，得到新的$L=[6,32,-0.4]^T$</p><p><img src="https://s2.loli.net/2023/04/04/8TV97J2O5d4WLht.png" alt="曲线9.png"></p><p><img src="https://s2.loli.net/2023/04/04/4sgeKTIkS59ulL1.png" alt="曲线11.png"></p><p><img src="https://s2.loli.net/2023/04/04/CPOhJ5zEi6SB8rQ.png" alt="曲线10.png"></p><p>继续令$\lambda_1=\lambda_2=\lambda_3=-3$，得到的效果似乎更好，角度偏差峰值只有4°多一点</p><p>那$\lambda$是不是越小越好呢？令$\lambda=-100$后仿真出来的结果也不错，也没有很夸张。不过我也不太清楚，仿真并不能完全的模拟实际情况，也不能太相信仿真结果。</p><h5 id="添加初始误差"><a href="#添加初始误差" class="headerlink" title="添加初始误差"></a>添加初始误差</h5><p>令$X_1=5°,\hat{X_1}=0°$，得到的效果也不错。</p><p><img src="https://s2.loli.net/2023/04/04/4u8n63Lq5myTQAN.png" alt="曲线12.png"></p><p><img src="https://s2.loli.net/2023/04/04/Efs3J4dLxjgSAbn.png" alt="曲线13.png"></p><h2 id="STM32控制实现"><a href="#STM32控制实现" class="headerlink" title="STM32控制实现"></a>STM32控制实现</h2><h4 id="极性约定"><a href="#极性约定" class="headerlink" title="极性约定"></a>极性约定</h4><p>根据上面的模型，小车朝向右方：</p><ul><li><p>​    向右倾斜时倾斜角θ为正；</p></li><li><p>​    使小车向右运动，即轮子顺时针转为正</p></li></ul><h4 id="参数确定"><a href="#参数确定" class="headerlink" title="参数确定"></a>参数确定</h4><ul><li>m=0.55kg</li><li>M=0.4kg</li><li>l=0.05m</li></ul><p>得到</p><script type="math/tex; mode=display">A = \begin{bmatrix}0 & 1 & 0 & 0 \\465.5 & 0 & 0 & 0 \\0 & 0 & 0 & 1 \\-13.475 & 0 & 0 & 0 \\\end{bmatrix}, \quadB = \begin{bmatrix}0 \\-50 \\0 \\2.5\end{bmatrix}</script><p>仍然取</p><script type="math/tex; mode=display">Q=\begin{bmatrix}10&0&0&0 \\0&1&0&0 \\0&0&1&0 \\0&0&0&1\end{bmatrix},\quad R=0.1</script><p>使用MATLAB计算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lqr(A,B,Q,R)</span><br></pre></td></tr></table></figure><p>得到</p><script type="math/tex; mode=display">K=\begin{bmatrix}-32.3606 & -3.6129 & -3.1623 & -4.9876\end{bmatrix}</script><p>则</p><script type="math/tex; mode=display">u = -KX \\Motor = -a*KX</script><p>其中u是水平外力，可以认为控制电机输出的信号正比于u</p><p>利用系统定时器可以得到控制函数的实际调用周期为0.01s</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运动学分析 </tag>
            
            <tag> 平衡小车 </tag>
            
            <tag> LQR controller </tag>
            
            <tag> Rhomberg observer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>note of Tactile Sensor Papers</title>
      <link href="/2023/04/03/note-of-Tactile-Sensor-Papers/"/>
      <url>/2023/04/03/note-of-Tactile-Sensor-Papers/</url>
      
        <content type="html"><![CDATA[<h2 id="Soft-Bubble"><a href="#Soft-Bubble" class="headerlink" title="Soft Bubble"></a>Soft Bubble</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li>深度相机：尺寸小，帧率高，支持USB等</li><li>气囊外壳：顺应性强，摩擦力大，便于抓取</li></ul><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><h4 id="物体分类"><a href="#物体分类" class="headerlink" title="物体分类"></a>物体分类</h4><p>使用<strong>深度神经网络ResNet</strong>作为对象分拣器。</p><ul><li><p>输入</p><p>传感器受压时的深度图像</p></li><li><p>输出</p><p>施压物体属于某类别的概率</p><ul><li>具体种类<ul><li>Cube</li><li>Robot</li><li>Frustum</li><li>Triangular prism</li><li>Bridge</li><li>Hemisphere</li><li>none</li></ul></li></ul></li><li><p>算法</p><ul><li>lost function: cross-entropy loss（交叉熵损失？还没学到）</li><li>optimizer: stochastic gradient descent（随机梯度下降？也还没学到）</li></ul></li></ul><h4 id="纹理识别"><a href="#纹理识别" class="headerlink" title="纹理识别"></a>纹理识别</h4><p>在前一个实验的基础上添加三种具有不同表面纹理但具有同大小规格的立方体进行分类</p><p><strong>结论</strong></p><p>分辨成功率与图像分辨率正相关，但会有一些波动。</p><h4 id="姿态估计与跟踪"><a href="#姿态估计与跟踪" class="headerlink" title="姿态估计与跟踪"></a>姿态估计与跟踪</h4><ul><li><p>输入信息</p></li><li><p>算法：Iterative Closest Point (<strong>ICP</strong>) algorithm</p><p>将两组曲线、两组曲面或两组点云进行配准</p><ul><li><p>基本思想</p><p>输入为两组点和变换的初始估计，输出为两组点之间的最优变换。</p><p>（自己概括的，可能不全面）通过迭代的方式寻找初始点阵发生的变换矩阵，代入得出估计的变换后点阵，与真实点阵比较以寻找出误差足够小的变换。</p></li><li><p>基本流程</p><p>1）将当前估计的变换应用于第一组点；</p><p>2）对于第一组变换后的每个点，在第二组中找到最近的点；3）通过剔除异常值来更新点匹配；</p><p>4）使用更新后的点匹配计算变换，直到估计的变换收敛。</p></li><li><p>更多</p><p><a href="https://blog.csdn.net/kksc1099054857/article/details/80280964">ICP算法的原理与实现_酷小川的博客-CSDN博客</a></p></li></ul></li><li><p>姿态估计</p><p>物体的实际轮廓是已知的，作为<strong>目标点云</strong>；传感器得到的点云为<strong>初始点云</strong>，使用ICP算法找出两者之间的最优变换关系，便可得到物体的姿态。</p><p>从十二个不同方向分别匹配，寻找最合适的一个。</p></li><li><p>姿态跟踪</p><p>每一次处理中，深度图像即为传感器弹性膜的外表面的点云。使用ICP算法不断地迭代出各采样点的点云与上一个样本点云之间的变换矩阵，最终合并全部的变换矩阵，依此得出施压物体的轮廓与姿态。</p><p>以1-2Hz的频率运行，那么各个采样点之间由ICP迭代出的各个最优变换矩阵即为物体的运动轨迹</p></li></ul><hr><h2 id="TacTip"><a href="#TacTip" class="headerlink" title="TacTip"></a>TacTip</h2><h3 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h3><ul><li>仿生探针：在传感器内表面排列光学探针模仿生物皮肤下方的MCC（中间脊）</li><li>指纹：通过3D打印技术为传感器设计出特殊的指纹，一定程度上可以提高检测精度</li></ul><h3 id="Data-processing"><a href="#Data-processing" class="headerlink" title="Data processing"></a>Data processing</h3><p>每一个点位的数据包括时间与维度数据，每个针脚的X，Y方向的偏移各自独立。</p><p>通过数据训练推测出各个探针的位置状态对应的位置。（这一块基本看不懂）</p><hr><h2 id="Tokyo-University"><a href="#Tokyo-University" class="headerlink" title="Tokyo University"></a>Tokyo University</h2><p>这两篇文章所介绍的传感器大致框架不变，作者人员也有较多重合。但是二者也有所不同，第二篇文章更侧重于理论推导。</p><h3 id="Measurement-of-force-vector-field-of-robotic-finger-using-vision-based-haptic-sensor"><a href="#Measurement-of-force-vector-field-of-robotic-finger-using-vision-based-haptic-sensor" class="headerlink" title="Measurement of force vector field of robotic finger using vision-based haptic sensor"></a>Measurement of force vector field of robotic finger using vision-based haptic sensor</h3><h4 id="硬件结构-1"><a href="#硬件结构-1" class="headerlink" title="硬件结构"></a>硬件结构</h4><ul><li>透明硅胶：受力载体，同时提供有规律可循的形变</li><li>红蓝点阵：作为胶体形变参照物，由形变反推受力</li><li>摄像头：捕捉图像</li></ul><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><ul><li>前提假设<ul><li>the sensor is a semi-infinite elastic body.</li><li>the deformation of the elastic body is linear.</li></ul></li></ul><p>u=hf</p><p>某一维度上的作用力会在另一维度产生分力；</p><p>某一维度上的力可使标记在另一维度上产生位移；</p><p>h则为作用力与标记位移之间的转换矩阵。</p><p>通过观测标记的位移与施加的已知力的关系得到h矩阵。</p><p>便可通过位移u和转换矩阵h反推出施加于传感器的外力。</p><hr><h3 id="Vision-Based-Sensor-for-RealTime-Measuring-of-Surface-Traction-Fields"><a href="#Vision-Based-Sensor-for-RealTime-Measuring-of-Surface-Traction-Fields" class="headerlink" title="Vision-Based Sensor for RealTime Measuring of Surface Traction Fields"></a>Vision-Based Sensor for RealTime Measuring of Surface Traction Fields</h3><h4 id="硬件结构-2"><a href="#硬件结构-2" class="headerlink" title="硬件结构"></a>硬件结构</h4><ul><li>Transparent elastic body：透明弹性介质</li><li>black layer：遮光层</li><li>Two layers of spherical markers：两层红蓝点阵标记物</li><li>CCD camera：相机</li></ul><h4 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h4><ul><li><p>前提假设</p><p>elastic medium is linear, isotropic, and homogeneous.（线性、各向同性、均匀性）</p></li><li><p>推导出表面法向力Fn使作用点在三个维度发生的位移公式</p></li><li><p>推导出表面切向力Ft使作用点在三个维度发生的位移公式</p></li><li><p>公式包含材料的杨氏模量E和泊松比R，可适用于多种材料</p></li><li><p>根据线性假设，可以认为各作用力对标记物产生的位移作用也可线性叠加，可用H变换矩阵表示</p></li></ul><h4 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h4><p>threshold：消除背景噪音的阈值，类似于提高水位以将丘陵分割为岛屿</p><p>精度：15微米</p><p>标记坐标的计算</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b63b31b9-1ddf-439a-b58f-164e7689b95a/Untitled.png" alt="Untitled"></p><p>这个P是pixels，这里是什么意思呢</p><hr><h2 id="GelSlim"><a href="#GelSlim" class="headerlink" title="GelSlim"></a>GelSlim</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li><strong>incipient slip：</strong>初始滑移，指接触表面的一部分区域开始滑移（通常是外围区域）</li><li><strong>ICR：</strong>旋转中心（速度瞬心），类似于“<em>基点法</em>”求各点运动状态。</li></ul><p>在没有发生滑移时，将接区域理想化为二维刚性模型，以此来计算出传感器上的标记位移的估计值；当估计值与实际值相差较大时，则可认为初始滑移开始发生。</p><p>因为将接区域理想化为二维刚性模型，接触区域的运动就理想化为<strong>平面刚体运动，</strong>由此方便预估姿态与判断。</p><ul><li><p>具体步骤</p><ol><li><p>检测并滤波处理得到接触区域</p></li><li><p>利用opencv库得到标记点在区域内的坐标。选取一个参考坐标系，由此计算各个时刻接触区域的位移。</p><p><aside> 💡 当标记的位移接近标记间的间距时，更新参考坐标系，这样可以避免多个区域内各标记点错误匹配（因为选择离自己最近的一个点就可以认为是下一时刻的自己？）</p></li><li><p>去除接触区域的<strong>外部区域</strong>，使用内部区域的标记位移来代表刚体的位移，并计算速度。（因为外围更可能先发生初始滑移）</p></li><li><p>估计位移并由此计算或判断是否发生滑移</p></li></ol></li></ul><h3 id="拧瓶盖实验"><a href="#拧瓶盖实验" class="headerlink" title="拧瓶盖实验"></a>拧瓶盖实验</h3><ul><li>黄色箭头：真实位移</li><li>红色箭头：估计位移</li></ul><p>相当于在拧瓶盖的过程中通过触觉传感器的滑移信息形成闭环控制。</p><hr><h2 id="GelSlim-application"><a href="#GelSlim-application" class="headerlink" title="GelSlim-application"></a>GelSlim-application</h2><blockquote><p>Tactile-Based Insertion for Dense Box-Packing</p></blockquote><p>这篇文章主要是上一篇文章中介绍的<strong>GelSlim</strong>在实际应用中的尝试</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在摄像机给出大致的空隙位置信息后，机械臂借助触觉传感器进行具有更高精度的物品放置。对周围物体与加持物体没有较多的了解，且机器人要在不破坏周围物体位置的情况下正确放置，允许试错与纠错。</p><ul><li>角度误差阈值：5°</li><li>位置误差阈值：2.5mm</li></ul><h3 id="误差获取"><a href="#误差获取" class="headerlink" title="误差获取"></a>误差获取</h3><ul><li><p>误差被分为八个种类</p><p>角度正负误差与位移正负误差排列组合</p></li><li><p>由GelSlim获取碰撞时的触觉信息</p><p>物体在碰撞或接触过程中产生的触觉信息（实际上是图像信息）被捕获并且有序存储</p></li></ul><h4 id="误差类型的判断"><a href="#误差类型的判断" class="headerlink" title="误差类型的判断"></a>误差类型的判断</h4><p><strong>卷积神经网络DirectionNN</strong></p><ul><li>输入：触觉传感器给出的接触信息</li><li>输出：属于各个误差类型的概率</li></ul><h4 id="误差大小的判断"><a href="#误差大小的判断" class="headerlink" title="误差大小的判断"></a>误差大小的判断</h4><p>即便是方向相同，误差大小的改变也会引起触觉信息的改变</p><p><strong>递归神经网络MagnitudeNN</strong></p><p>估计误差大小</p><h3 id="控制策略"><a href="#控制策略" class="headerlink" title="控制策略"></a>控制策略</h3><p>根据两个网络输出的结果一致性进行判断，更相信<strong>DirectionNN。</strong></p><ul><li>根据两个结果的差别大小制定不同的控制策略</li></ul><h4 id="迭代流程"><a href="#迭代流程" class="headerlink" title="迭代流程"></a>迭代流程</h4><ol><li>尝试放置物品</li><li>若失败，则捕获触觉信息</li><li>两个神经网络分别根据信息估计误差</li><li>控制器根据误差进行运动决策</li><li>若失败，则重复2~4，直到成功</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Tactile Sensor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,FreeRTOS!</title>
      <link href="/2023/01/06/Hello_FreeRTOS!/"/>
      <url>/2023/01/06/Hello_FreeRTOS!/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello，FreeRTOS！"><a href="#Hello，FreeRTOS！" class="headerlink" title="Hello，FreeRTOS！"></a>Hello，FreeRTOS！</h1><p><strong>官网链接</strong></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://www.freertos.org/zh-cn-cmn-s/">FreeRTOS - Market leading RTOS (Real Time Operating System) for embedded systems with Internet of Things extensions</a></p></div><p><strong>正点原子教程手册</strong></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://semitia.top/upload_flies/STM32F1_FreeRTOS_V1.1.pdf">https://semitia.top/upload_flies/STM32F1_FreeRTOS_V1.1.pdf</a></p></div><h1 id="DEMO1-Blink-LED移植"><a href="#DEMO1-Blink-LED移植" class="headerlink" title="DEMO1: Blink_LED移植"></a>DEMO1: Blink_LED移植</h1><p>按照教程移植的时候，编译出来会有报错</p><blockquote><p>..\OBJ\LED.axf: Error: L6200E: Symbol PendSV_Handler multiply defined (by port.o and stm32f10x_it.o).</p><p>..\OBJ\LED.axf: Error: L6200E: Symbol SVC_Handler multiply defined (by port.o and stm32f10x_it.o).</p></blockquote><p>报错信息显示 <strong>PendSV_Handler</strong>和<strong>SVC_Handler</strong>在<strong>port</strong>和<strong>stm32f10x_it</strong>里面重复定义了。网上查到了有人说要把配置文件<strong>FreeRTOSConfig.h</strong>里的宏定义注释掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xPortPendSVHandler PendSV_Handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vPortSVCHandler SVC_Handler</span></span><br></pre></td></tr></table></figure><p>但是这两个是与与中断函数有关的配置，直接注释掉肯定不合适。在<strong>stm32法f10x_it.c</strong>里面找到这两个函数是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SVC_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PendSV_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以选择将这两个函数给注释掉（实际上教程看到后面发现这几个函数早晚要注释掉的），这样这两个函数分别会指向<strong>port.c</strong>里面的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">vPortSVCHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* *INDENT-OFF* */</span></span><br><span class="line">    PRESERVE8</span><br><span class="line"></span><br><span class="line">    ldr r3, = pxCurrentTCB   <span class="comment">/* Restore the context. */</span></span><br><span class="line">    ldr r1, [ r3 ] <span class="comment">/* Use pxCurrentTCBConst to get the pxCurrentTCB address. */</span></span><br><span class="line">    ldr r0, [ r1 ]           <span class="comment">/* The first item in pxCurrentTCB is the task top of stack. */</span></span><br><span class="line">    ldmia r0 !, &#123; r4 - r11 &#125; <span class="comment">/* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */</span></span><br><span class="line">    msr psp, r0 <span class="comment">/* Restore the task stack pointer. */</span></span><br><span class="line">    isb</span><br><span class="line">    mov r0, # <span class="number">0</span></span><br><span class="line">    msr basepri, r0</span><br><span class="line">    orr r14, # <span class="number">0xd</span></span><br><span class="line">    bx r14</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__asm <span class="type">void</span> xPortPendSVHandler( <span class="type">void</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> uxCriticalNesting;</span><br><span class="line">    <span class="keyword">extern</span> pxCurrentTCB;</span><br><span class="line">    <span class="keyword">extern</span> vTaskSwitchContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *INDENT-OFF* */</span></span><br><span class="line">    PRESERVE8</span><br><span class="line"></span><br><span class="line">    mrs r0, psp</span><br><span class="line">    isb</span><br><span class="line"></span><br><span class="line">    ldr r3, =pxCurrentTCB <span class="comment">/* Get the location of the current TCB. */</span></span><br><span class="line">    ldr r2, [ r3 ]</span><br><span class="line"></span><br><span class="line">    stmdb r0 !, &#123; r4 - r11 &#125; <span class="comment">/* Save the remaining registers. */</span></span><br><span class="line">    str r0, [ r2 ] <span class="comment">/* Save the new top of stack into the first member of the TCB. */</span></span><br><span class="line"></span><br><span class="line">    stmdb sp !, &#123; r3, r14 &#125;</span><br><span class="line">    mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><span class="line">    msr basepri, r0</span><br><span class="line">    dsb</span><br><span class="line">    isb</span><br><span class="line">    bl vTaskSwitchContext</span><br><span class="line">    mov r0, #<span class="number">0</span></span><br><span class="line">    msr basepri, r0</span><br><span class="line">    ldmia sp !, &#123; r3, r14 &#125;</span><br><span class="line"></span><br><span class="line">    ldr r1, [ r3 ]</span><br><span class="line">    ldr r0, [ r1 ] <span class="comment">/* The first item in pxCurrentTCB is the task top of stack. */</span></span><br><span class="line">    ldmia r0 !, &#123; r4 - r11 &#125; <span class="comment">/* Pop the registers and the critical nesting count. */</span></span><br><span class="line">    msr psp, r0</span><br><span class="line">    isb</span><br><span class="line">    bx r14</span><br><span class="line">    nop</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FreeRTOSConfig-h"><a href="#FreeRTOSConfig-h" class="headerlink" title="FreeRTOSConfig.h"></a>FreeRTOSConfig.h</h1><p>​    这一部分在教程中有详细的讲解，在这里摘录过来，全部记住可能不太容易，主要是在具体使用的时候能方便具体查看就行了。</p><h2 id="INCLUDE"><a href="#INCLUDE" class="headerlink" title="INCLUDE_"></a>INCLUDE_</h2><h3 id="INCLUDE-xTaskGetSchedulerState"><a href="#INCLUDE-xTaskGetSchedulerState" class="headerlink" title="INCLUDE_xTaskGetSchedulerState"></a>INCLUDE_xTaskGetSchedulerState</h3><h3 id="INCLUDE-vTaskPrioritySet"><a href="#INCLUDE-vTaskPrioritySet" class="headerlink" title="INCLUDE_vTaskPrioritySet"></a>INCLUDE_vTaskPrioritySet</h3><h3 id="INCLUDE-uxTaskPriorityGet"><a href="#INCLUDE-uxTaskPriorityGet" class="headerlink" title="INCLUDE_uxTaskPriorityGet"></a>INCLUDE_uxTaskPriorityGet</h3><h3 id="INCLUDE-vTaskDelete"><a href="#INCLUDE-vTaskDelete" class="headerlink" title="INCLUDE_vTaskDelete"></a>INCLUDE_vTaskDelete</h3><h3 id="INCLUDE-vTaskCleanUpResources"><a href="#INCLUDE-vTaskCleanUpResources" class="headerlink" title="INCLUDE_vTaskCleanUpResources"></a>INCLUDE_vTaskCleanUpResources</h3><h3 id="INCLUDE-vTaskSuspend"><a href="#INCLUDE-vTaskSuspend" class="headerlink" title="INCLUDE_vTaskSuspend"></a>INCLUDE_vTaskSuspend</h3><h3 id="INCLUDE-vTaskDelayUntil"><a href="#INCLUDE-vTaskDelayUntil" class="headerlink" title="INCLUDE_vTaskDelayUntil"></a>INCLUDE_vTaskDelayUntil</h3><h3 id="INCLUDE-vTaskDelay"><a href="#INCLUDE-vTaskDelay" class="headerlink" title="INCLUDE_vTaskDelay"></a>INCLUDE_vTaskDelay</h3><h3 id="INCLUDE-eTaskGetState"><a href="#INCLUDE-eTaskGetState" class="headerlink" title="INCLUDE_eTaskGetState"></a>INCLUDE_eTaskGetState</h3><h3 id="INCLUDE-xTimerPendFunctionCall"><a href="#INCLUDE-xTimerPendFunctionCall" class="headerlink" title="INCLUDE_xTimerPendFunctionCall"></a>INCLUDE_xTimerPendFunctionCall</h3><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><h1 id="DEMO2：中断屏蔽"><a href="#DEMO2：中断屏蔽" class="headerlink" title="DEMO2：中断屏蔽"></a>DEMO2：中断屏蔽</h1><h2 id="中断屏蔽寄存器"><a href="#中断屏蔽寄存器" class="headerlink" title="中断屏蔽寄存器"></a>中断屏蔽寄存器</h2><ul><li>PRIMASK</li></ul><blockquote><p>PRIMASK 用于禁止除 NMI 和 HardFalut 外的所有异常和中断，清除后使能中断</p></blockquote><ul><li>FAULTMASK  </li></ul><blockquote><p>与 PRIMASK相比 ， FAULTMASK 可以连 HardFault 都屏蔽掉 ，它在退出时自动清零。</p></blockquote><ul><li>BASEPRI</li></ul><blockquote><p>在有些场合需要对中断屏蔽进行更细腻的控制， 比如只屏蔽优先级低于某<br>一个阈值的中断。那么这个作为阈值的优先级值存储在哪里呢？BASEPRI 寄存器中。如果向 BASEPRI 写 0 的话就会停止屏蔽中断。  </p></blockquote><h2 id="中断屏蔽的配置宏"><a href="#中断屏蔽的配置宏" class="headerlink" title="中断屏蔽的配置宏"></a>中断屏蔽的配置宏</h2><p>​    FreeRTOS 的开关中断是操作 BASEPRI 寄存器来实现的，它可以关闭低于某个阈值的中断，高于这个阈值的中断就不会被关闭 。</p><h3 id="configLIBRARY-MAX-SYSCALL-INTERRUPT-PRIORITY"><a href="#configLIBRARY-MAX-SYSCALL-INTERRUPT-PRIORITY" class="headerlink" title="configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY"></a>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</h3><p>​    此宏用来设置 FreeRTOS 系统可管理的最大优先级，也就是<strong>BASEPRI</strong>寄存器说的那个阈值优先级，这个大家可以自由设置，这里我设置为了 5。也就是高于 5 的优先级(优先级数小于 5)不归 FreeRTOS 管理。</p><h3 id="configMAX-SYSCALL-INTERRUPT-PRIORITY"><a href="#configMAX-SYSCALL-INTERRUPT-PRIORITY" class="headerlink" title="configMAX_SYSCALL_INTERRUPT_PRIORITY"></a>configMAX_SYSCALL_INTERRUPT_PRIORITY</h3><p>​    此宏是 configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 左移 4 位而来的。<strong>此宏设置好以后，低于此优先级的中断可以安全的调用 FreeRTOS 的 API 函数，高于此优先级的中断 FreeRTOS 是不能禁止的，<emp>中断服务函数也不能调用 FreeRTOS 的 API 函数！</emp></strong> </p><h2 id="临界段代码："><a href="#临界段代码：" class="headerlink" title="临界段代码："></a>临界段代码：</h2><p>​    临界段代码也叫做临界区，是指那些必须完整运行，不能被打断的代码段，比如有的外设的初始化需要严格的时序，初始化过程中不能被打断。FreeRTOS 在进入临界段代码的时候需要关闭中断，当处理完临界段代码以后再打开中断。  </p><h2 id="任务级临界段代码保护函数"><a href="#任务级临界段代码保护函数" class="headerlink" title="任务级临界段代码保护函数"></a>任务级临界段代码保护函数</h2><p>对<strong>任务</strong>中的临界段代码语句使用的保护函数</p><ul><li>taskENTER_CRITICAL() </li><li>taskEXIT_CRITICAL()  </li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">taskcritical_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        taskENTER_CRITICAL();<span class="comment">//进入临界区</span></span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        taskEXIT_CRITICAL();<span class="comment">//退出临界区</span></span><br><span class="line">        vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中断级临界段代码保护函数"><a href="#中断级临界段代码保护函数" class="headerlink" title="中断级临界段代码保护函数"></a>中断级临界段代码保护函数</h2><p>对<strong>中断函数</strong>中的临界段代码语句使用的保护函数</p><ul><li>taskENTER_CRITICAL_FROM_ISR()</li><li>taskEXIT_CRITICAL_FROM_ISR()</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(TIM_GetITStatus(TIM3,TIM_IT_Update)==SET) <span class="comment">//溢出中断</span></span><br><span class="line">    &#123;</span><br><span class="line">        status_value=taskENTER_CRITICAL_FROM_ISR();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">            </span><br><span class="line">        taskEXIT_CRITICAL_FROM_ISR(status_value);</span><br><span class="line">    &#125;</span><br><span class="line">    TIM_ClearITPendingBit(TIM3,TIM_IT_Update); <span class="comment">//清除中断标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,esp32!</title>
      <link href="/2023/01/03/Hello-ESP32/"/>
      <url>/2023/01/03/Hello-ESP32/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello，-esp32！"><a href="#Hello，-esp32！" class="headerlink" title="Hello， esp32！"></a>Hello， esp32！</h1><p>​    今天终于在windows上配置好了esp32的开发环境，感谢这个up主提供的方式。</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://www.bilibili.com/video/BV1QF411u72A/?spm_id_from=333.880.my_history.page.click&amp;vd_source=0f383e93e945bca07eaef9a9ee5d9db3">乐鑫ESP32官方开发环境 Espressif IDE 一键安装教程-无需插件和手动配置_哔哩哔哩_bilibili</a></p></div><p>​    我之前也试过其他的开发方式，platformIO开发呢局限性比较大，VScode上的ESpressif IDF呢一直下载失败，最后也没折腾出来。在这里总结一下这个配置方式，结合自己遇到的一些小问题。</p><h2 id="IDE安装"><a href="#IDE安装" class="headerlink" title="IDE安装"></a>IDE安装</h2><p>可以在乐鑫官方的Github下载，也可以在视频里的百度网盘下载。安装过程非常惬意，但还是有一点注意事项。</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/espressif/idf-installer#espressif-ide-offline-installer">espressif/idf-installer: ESP IDF Windows Installer (github.com)</a></p></div><p><img src="https://s2.loli.net/2023/01/04/8qiAbfNxI27vupz.png" alt="IDE.png"></p><h2 id="连接-amp-烧录"><a href="#连接-amp-烧录" class="headerlink" title="连接 &amp; 烧录"></a>连接 &amp; 烧录</h2><p>​    我这个板子直接用microUSB连接至电脑。但是数据线也要用稍微靠谱的，我一开始用的俩数据线不太行，插上去板子能取电，但是电脑识别不到串口。如果不是驱动的问题，估计就是线的问题。换了个线之后就好了。我这里是 <strong>com9</strong></p><p><img src="https://s2.loli.net/2023/01/04/PzNvTuql8oGcIB6.png" alt="esp串口.png" style="zoom:200%;" /></p><p>​    烧录的时候有一个小问题，就是connect不上板子，这个在之前用PlatformIO的时候也有类似的情况，只要按住 <strong>boot</strong> 键烧录就好了。</p><p><img src="https://s2.loli.net/2023/01/04/Cw9gNGEkP7l3piY.png" alt="connecting.png"></p><h2 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h2><p>​    打开终端，就可以看到板子发送的消息了。串口的波特率没有在代码里看到，但是实测是 <strong>115200</strong>，其他串口助手也可以接收消息。</p><p><img src="https://s2.loli.net/2023/01/04/tc2jYemq1WxQR87.png" alt="esp终端.png"></p><p><img src="https://s2.loli.net/2023/01/04/vSZ7y2fYiwIphgq.png" alt="esp串口2.png"></p><p>这位博主很厉害，在之前学习蓝牙协议栈的时候也是跟着这位博主学的，</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://wlink.blog.csdn.net/article/details/123952643">(15条消息) 一篇文章足够你学习ESP32，提供史上最全的ESP32教程(驱动/蓝牙/Wi-Fi/LVGL/Arduino…)_Wireless_Link的博客-CSDN博客_esp32</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab logs</title>
      <link href="/2022/12/29/Matlab-logs/"/>
      <url>/2022/12/29/Matlab-logs/</url>
      
        <content type="html"><![CDATA[<p>​    MATLAB各功能使用的简单记录。</p><h2 id="lsqcurvefit参数拟合"><a href="#lsqcurvefit参数拟合" class="headerlink" title="lsqcurvefit参数拟合"></a>lsqcurvefit参数拟合</h2>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PID波形绘制及积分优化</title>
      <link href="/2022/11/26/PID%E6%B3%A2%E5%BD%A2%E7%BB%98%E5%88%B6%E5%8F%8A%E7%A7%AF%E5%88%86%E4%BC%98%E5%8C%96/"/>
      <url>/2022/11/26/PID%E6%B3%A2%E5%BD%A2%E7%BB%98%E5%88%B6%E5%8F%8A%E7%A7%AF%E5%88%86%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="MATLAB串口绘制波形"><a href="#MATLAB串口绘制波形" class="headerlink" title="MATLAB串口绘制波形"></a>MATLAB串口绘制波形</h2><p>​    对于<strong>MATLAB</strong>我也是久仰大名，最近安装了一个，感觉功能很丰富，也比较有意思。当然本人也是刚安装<strong>MABLAB</strong>不久，对其理解还是分浅薄，暂时也只是一些简单的使用。</p><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><h4 id="plot-二维绘图"><a href="#plot-二维绘图" class="headerlink" title="plot( ) 二维绘图"></a>plot( ) 二维绘图</h4><p><a href="https://ww2.mathworks.cn/help/matlab/ref/plot.html">二维线图 - MATLAB plot - MathWorks 中国</a></p><h4 id="axis-显示范围"><a href="#axis-显示范围" class="headerlink" title="axis( ) 显示范围"></a>axis( ) 显示范围</h4><p><a href="https://blog.csdn.net/youshijian99/article/details/80842218">(15条消息) Matlab axis函数_Geek猫的博客-CSDN博客_matlab axis</a></p><h4 id="grid-栅格"><a href="#grid-栅格" class="headerlink" title="grid 栅格"></a>grid 栅格</h4><p><a href="https://www.mathworks.com/help/matlab/ref/grid.html">Display or hide axes grid lines - MATLAB grid (mathworks.com)</a></p></div><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>新建函数文件——<strong>Serial.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Serial</span><span class="params">()</span>   %创建函数</span></span><br><span class="line">delete(instrfindall);   <span class="comment">%先关闭串口，否则可能导致出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> x            <span class="comment">%全局变量，供串口中断函数使用</span></span><br><span class="line"><span class="keyword">global</span> t;<span class="comment">%全局变量，这里根据需要绘制图形的个人需要而设</span></span><br><span class="line"><span class="keyword">global</span> m;</span><br><span class="line"><span class="keyword">global</span> <span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">t = [<span class="number">0</span>];      <span class="comment">%时间轴</span></span><br><span class="line">m = [<span class="number">0</span>];      <span class="comment">%数据轴</span></span><br><span class="line"><span class="built_in">i</span> = <span class="number">0</span>;        <span class="comment">%用于计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%串口参数配置</span></span><br><span class="line">x = serial(<span class="string">&#x27;com3&#x27;</span>);</span><br><span class="line">set(x,<span class="string">&#x27;BaudRate&#x27;</span>,<span class="number">115200</span>);</span><br><span class="line">set(x,<span class="string">&#x27;BytesAvailableFcnMode&#x27;</span>,<span class="string">&#x27;Terminator&#x27;</span>) <span class="comment">%ASCII触发，字符触发</span></span><br><span class="line">set(x,<span class="string">&#x27;Terminator&#x27;</span>,<span class="string">&#x27;CR/LF&#x27;</span>)         <span class="comment">%接收到\r\n后触发中断</span></span><br><span class="line">x.BytesAvailableFcn = @Callback  <span class="comment">%定义中断响应函数对象，类似于中断函数名</span></span><br><span class="line">fopen(x);</span><br><span class="line">pause</span><br><span class="line">fclose(x);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另建回调函数文件<strong>Callback.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Callback</span><span class="params">(obj,event)</span>   %创建中断服务函数，绘制图像</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> t; <span class="comment">%时间</span></span><br><span class="line"><span class="keyword">global</span> m; <span class="comment">%纵坐标</span></span><br><span class="line"><span class="keyword">global</span> <span class="built_in">i</span>; <span class="comment">%时间变化值</span></span><br><span class="line"></span><br><span class="line">    out = fscanf(obj);</span><br><span class="line">    data = str2num(out)<span class="comment">%将接收到的字符转换为数值</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">%%----------------------以下根据需要自行编写-------------------------------</span></span><br><span class="line">    t = [t <span class="built_in">i</span>];</span><br><span class="line">    m = [m data];</span><br><span class="line">    <span class="built_in">plot</span>(t,m)</span><br><span class="line">    xlabel(<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">    axis([<span class="built_in">i</span><span class="number">-50</span> <span class="built_in">i</span>+<span class="number">50</span> <span class="number">0</span> <span class="number">1000</span>]);</span><br><span class="line">    grid on;</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="样式预览"><a href="#样式预览" class="headerlink" title="样式预览"></a>样式预览</h3><p>可以参考下文。</p><h2 id="积分优化"><a href="#积分优化" class="headerlink" title="积分优化"></a>积分优化</h2><h3 id="梯形积分PID"><a href="#梯形积分PID" class="headerlink" title="梯形积分PID"></a>梯形积分PID</h3><p>​    从微积分的角度来说，当微分到无限小时，矩形积分与梯形积分是没有区别的。但是实际上采样时间不可能无穷小，采样周期越大，偏差就越大。而梯形积分则是更加接近实际曲线，所以用梯形积分可以得到更高的精度。</p><script type="math/tex; mode=display">\int _0^t e(t) \mathrm{d} t = \sum_{i=0}^t \frac{e(i) + e(i-1)}{2}</script><h3 id="积分分离PID"><a href="#积分分离PID" class="headerlink" title="积分分离PID"></a>积分分离PID</h3><p>在普通的PID控制算法中，由于积分系数是常数，所以在整个控制过程中，积分增量不变。而系统对积分项的要求是：<emp>系统偏差大时积分减弱甚至全无，偏差小时积 分加强。</emp>积分系数大了会产生超调，小了又不能消除静差。变速积分PID可以根据<strong>系统偏差大小</strong>改变积分的速度。<br>    在普通的PID控制算法中，引入积分环节目的主要是为了消除静差。<emp>但在过程的启动、结束或大幅度增减设定时，短时间内系统输出有很大的偏差，</emp>会造成PID运算的积分积累，使控制量超过可能允许的最大动作范围对应的极限控制量，引起系统较大的超调，甚至引起较大的振荡。积分分离PID可以较好地解决这⼀问题。</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>​    思路是偏差值较大时，取消积分作用，以免超调量增大；而偏差值较小时，引入积分作用，以便消除静差，提⾼控制精度。<br>具体的实现步骤是：根据实际情况，设定⼀个阈值</p><ul><li>当偏差大于阈值时，消除积分仅用PD控制；</li><li>当偏差小于等于阈值时，引⼊积分采⽤PID控制。</li></ul><h4 id="积分项表达式"><a href="#积分项表达式" class="headerlink" title="积分项表达式"></a>积分项表达式</h4><script type="math/tex; mode=display">U_i(k) = \beta K_i\sum_{j=0}^{k-1}e(j)</script><p>其中<em>β</em>称为<strong>积分开关系数</strong></p><script type="math/tex; mode=display">\beta = \begin{cases}1, & |e(k)| \leq \varepsilon \\ 0, & |e(k)| > \varepsilon\end{cases}</script><p>由上述表述及公式我们可以知道，积分分离算法的效果其实与<strong>ε</strong>值的选取有很大的关系，所以ε值的选取是实现的难点</p><ul><li><p>ε值过大则达不到积分分离的效果</p></li><li><p>ε值过小则难以进入积分区。</p></li></ul><h3 id="变速积分PID"><a href="#变速积分PID" class="headerlink" title="变速积分PID"></a>变速积分PID</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>变速积分PID的基本思想是<emp>设法改变积分项的累加速度，使其与偏差大小相对应。</emp></p><ul><li>偏差越大，积分越慢；</li><li>偏差越小则越快。</li></ul><p>为此，设置系数<strong>f(e(k))</strong> ，它是<strong>e(k)</strong>的函数。当<strong>e(k)</strong>增大时， <strong>f</strong>减小，反之增大。</p><h4 id="积分项表达式-1"><a href="#积分项表达式-1" class="headerlink" title="积分项表达式"></a>积分项表达式</h4><script type="math/tex; mode=display">U_i(k) = K_i[\sum_{j=0}^{k-1} + f(e(k))*e(k) ]</script><p><strong>f(e(k))</strong>可根据具体情况设定，比较简单的设置为：</p><script type="math/tex; mode=display">f(e(k)) = \begin{cases}1, & |e(k)| \leq B \\\frac{A - |e(k)| + B}{A}, & B < |e(k)| \leq A + B \\0, & |e(k)| > A + B\end{cases}</script><p>由上述公式可知，<strong>f(e(k))</strong>的值在[0,1]区间变化。</p><ul><li><p>当偏差值<strong>e(k)</strong>大于分离区间<strong>A + B</strong>时，不对当前<strong>e(k)</strong>进行累加；</p></li><li><p>当偏差值<strong>e(k)</strong>小于<strong>B</strong>时，加入当前偏差<strong>e(k)</strong>进行累加；</p></li><li><p>介于<strong>B</strong>和<strong>A + B</strong>之间时，按一定函数关系变化。</p></li></ul><p>这种算法对A，B两个参数的要求不精确，参数整定较容易。 </p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">PID_t</span>&#123;</span></span><br><span class="line">    <span class="type">float</span> target;</span><br><span class="line">    <span class="type">float</span> actual;</span><br><span class="line">    <span class="type">float</span> dead_zone;</span><br><span class="line">    <span class="type">float</span> Kp, Ki, Kd;</span><br><span class="line">    <span class="type">float</span> last_error, pre_error, sum_error;</span><br><span class="line">    <span class="type">float</span> I_MAX;</span><br><span class="line">    <span class="type">float</span> P_out, I_out, D_out, D_last_out;</span><br><span class="line">    <span class="type">float</span> out_MAX, out, out_last;</span><br><span class="line">    <span class="type">float</span> I_up, I_low;</span><br><span class="line">    <span class="type">float</span> RC_DF;</span><br><span class="line">&#125;PID_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ABS(p-&gt;pre_error) &lt; P-&gt;I_low)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;sum_error += (p-&gt;pre_error + p-&gt;last_error)/<span class="number">2</span>;</span><br><span class="line">    p-&gt;sum_error = limit(p-&gt;sum_error, p-&gt;I_MAX, -p-&gt;I_MAX);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ABS(p-&gt;pre_error) &lt; p-&gt;I_up)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;sum_error += ((ABS(p-&gt;pre_error) - p-&gt;I_low)/(p-&gt;I_up - p-&gt;I_low)) * ((p-&gt;last_error + p-&gt;pre_error)/<span class="number">2</span>);</span><br><span class="line">    p-&gt;sum_error = limit(p-&gt;sum_error, p-&gt;I_MAX, -p-&gt;I_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然定义的是<strong>I_up,I_low</strong>, 但是实际上这是与<strong>error</strong>相比较的</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>Kp = 350<img src="https://s2.loli.net/2022/11/27/JFxsQNWeq4nuVEP.png" alt="Kp350.png"></p><p>ki = 120</p><p><img src="https://s2.loli.net/2022/11/27/zjaUvYJpVNBcbif.png" alt="Kp350Ki120.png"></p><p>Kd = 100</p><p><img src="https://s2.loli.net/2022/11/27/rZwV9psKjQ8toIJ.png" alt="Kd80.png"></p><p>Kd = 80, up = 80, low = 50</p><p><img src="https://s2.loli.net/2022/11/27/RsTAucIzvqlJtpk.png" alt="up80low50.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 控制方法 </tag>
            
            <tag> PID </tag>
            
            <tag> MATLAB </tag>
            
            <tag> USART </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D-H参数法与机械臂正逆解</title>
      <link href="/2022/11/20/D-H%E5%8F%82%E6%95%B0%E6%B3%95%E6%9C%BA%E6%A2%B0%E8%87%82%E6%AD%A3%E9%80%86%E8%A7%A3/"/>
      <url>/2022/11/20/D-H%E5%8F%82%E6%95%B0%E6%B3%95%E6%9C%BA%E6%A2%B0%E8%87%82%E6%AD%A3%E9%80%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="D-H参数法"><a href="#D-H参数法" class="headerlink" title="D-H参数法"></a>D-H参数法</h1><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/maple_2014/article/details/105612912">(14条消息) 一文带你完全掌握机器人DH参数建模(详细步骤+实例+代码)_Marc Pony的博客-CSDN博客_dh建模</a></p></div><h2 id="坐标变换矩阵"><a href="#坐标变换矩阵" class="headerlink" title="坐标变换矩阵"></a>坐标变换矩阵</h2><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/weixin_44097528/article/details/122182393">(14条消息) 详解坐标变换矩阵_Akinaze的博客-CSDN博客_坐标变换矩阵</a></p></div><h2 id="D-H参数"><a href="#D-H参数" class="headerlink" title="D-H参数"></a>D-H参数</h2><p>​    一般来说，想要得到两个坐标系之间的变换矩阵，需要知道六个量。但是在使用<strong>D-H</strong>参数法时，需要按照特定方式建立坐标系，依托于这些<em>“前提约束”</em>，我们只需要4个参数便可以得出两坐标系之间的变换矩阵。</p><p>先要理解坐标系的<strong>建立规定</strong></p><blockquote><ul><li><p><strong>z轴</strong>的方向垂直于旋转面，即为<strong>转轴</strong>;</p></li><li><p><strong>x[i]</strong>方向的确定：同时垂直于z[i]与z[i-1];</p></li></ul></blockquote><p>依据这样的规定，可以发现：</p><blockquote><ul><li><p>z[i-1]<strong>同时垂直</strong>于x[i-1]与x[i];</p></li><li><p>x[i]<strong>同时垂直</strong>于z[i-1]与z[i];</p></li></ul></blockquote><p>由此，<strong>z[i-1]和x[i]</strong>便成了连接坐标系[i-1]和坐标系[i]的重要参考。再看四个参数的定义</p><div class="note blue icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><ul><li><strong>d[i]</strong>:坐标轴x[i-1]与坐标轴x[i]沿着<strong>z[i-1]</strong>的有向距离；</li><li><strong>θ[i]</strong>:坐标轴x[i-1]与坐标轴x[i]以<strong>z[i-1]</strong>为转轴的旋转角(逆时针，xi在前为正，或者说从x0转到x1的角度)；</li><li><strong>a[i]</strong>:坐标轴z[i-1]与坐标轴z[i]沿着<strong>x[i]</strong>的有向距离；</li><li><strong>α[i]</strong>:坐标轴z[i-1]与坐标轴z[i]以<strong>x[i]</strong>为转轴的旋转角；</li></ul></div><h2 id="正向求解"><a href="#正向求解" class="headerlink" title="正向求解"></a>正向求解</h2><p>在已知各关节角度的条件下，求出机械臂末端的坐标。</p><p>由<strong>D-H</strong>参数可以得到坐标系变换矩阵（将其记作<strong>$T_i$</strong>）：</p><script type="math/tex; mode=display">\begin{bmatrix}x_{i-1} \\ y_{i-1} \\ z_{i-1} \\ 1\end{bmatrix}= \begin{bmatrix} \cos{θ_i} & -\sin{θ_i} \cos{\alpha_i} & \sin{θ_i}\sin{\alpha_i} & a_i\cos{θ_i} \\\sin{θ_i} & \cos{θ_i} \cos{\alpha_i} & -\cos{θ_i}\sin{\alpha_i} & a_i\sin{θ_i} \\ 0 & \sin{\alpha_i} & \cos{\alpha_i} & d_i \\ 0 & 0 & 0 & 1\end{bmatrix}\begin{bmatrix}x_{i} \\ y_{i} \\z_{i} \\ 1\end{bmatrix}</script><p>​    代入<strong>i</strong>系的点$(x_i,y_i,z_i)$，左乘变换矩阵$T_i$，得到这个点在<strong>i-1</strong>系的坐标。由此，将末端坐标$C_n$不断左乘各变换矩阵，便可以递推出其在第一个坐标系的坐标$C_0$。</p><script type="math/tex; mode=display">C_0 = T_1 T_2 \cdots T_{n-1} T_n C_n</script><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>主要就是两个部分</p><blockquote><ul><li>矩阵<strong>Matrix</strong>的构建及其运算</li><li>机械臂<strong>robotic_arm</strong>的构建及基本功能</li></ul></blockquote><p>​    都是直接模拟手算过程，矩阵相乘的时间复杂度是<strong>O(mnk)</strong>，三次方量级的，好在矩阵规模都比较小。</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">Matrix_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> matrix[Matrix_MX][Matrix_MX];</span><br><span class="line">&#125;Matrix_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">robotic_arm_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;<span class="comment">//number of nodes</span></span><br><span class="line">    <span class="type">float</span> d[arm_MX_nodes],a[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> theta[arm_MX_nodes],alpha[arm_MX_nodes];</span><br><span class="line">    Matrix_t *T[arm_MX_nodes];</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">robotic_arm_t</span>;</span><br></pre></td></tr></table></figure><h4 id="机械臂初始化"><a href="#机械臂初始化" class="headerlink" title="机械臂初始化"></a>机械臂初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param n the number of the nodes</span></span><br><span class="line"><span class="comment"> * @param d D-H parameters</span></span><br><span class="line"><span class="comment"> * @param a D-H parameters</span></span><br><span class="line"><span class="comment"> * @param theta D-H parameters</span></span><br><span class="line"><span class="comment"> * @param alpha D-H parameters</span></span><br><span class="line"><span class="comment"> * @return robotic_arm_t* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">robotic_arm_t</span> *<span class="title function_">robotic_arm_init</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> *d, <span class="type">float</span> *a, <span class="type">double</span> *theta, <span class="type">double</span> *alpha)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">robotic_arm_t</span> *arm;</span><br><span class="line">    arm = (<span class="type">robotic_arm_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">robotic_arm_t</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    arm-&gt;T[i] = (Matrix_t*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Matrix_t));</span><br><span class="line"></span><br><span class="line">    arm-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arm-&gt;d[i] = d[i];</span><br><span class="line">        arm-&gt;a[i] = a[i];</span><br><span class="line">        arm-&gt;alpha[i] = alpha[i];</span><br><span class="line">        arm-&gt;theta[i] = theta[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get_Trans(arm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里构建的模型</p><p><img src="https://s2.loli.net/2022/11/23/FJehTzpxDroZPBg.jpg" alt="robotic_arm.jpg" style="zoom:50%;" /></p><div class="table-container"><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>d</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>θ</td><td>0</td><td>$\omega_0$</td><td>-$\omega_1$</td><td>$\frac{\Pi}{2} - \omega_2$</td></tr><tr><td>α</td><td>0</td><td>$-\frac{\Pi}{2}$</td><td>0</td><td>0</td></tr><tr><td>a</td><td>0</td><td>0</td><td>10</td><td>10</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> test_d[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,test_a[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">double</span> test_theta[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;,test_alpha[<span class="number">4</span>]=&#123;<span class="number">0</span>,-PI/<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">test_arm = robotic_arm_init(<span class="number">3</span>,test_d,test_a,test_theta,test_alpha);</span><br></pre></td></tr></table></figure><p>$\omega$为关节（舵机）角度，以图中状态作为初始值，认为此时关节（舵机）角度为0。所以还有一个由关节角度到DH参数的转换函数，这个函数就是根据机械臂具体情况具体修改了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DH_update</span><span class="params">(<span class="type">robotic_arm_t</span> *arm, <span class="type">double</span> *servo)</span></span><br><span class="line">&#123;</span><br><span class="line">    arm-&gt;theta[<span class="number">1</span>] =  servo[<span class="number">0</span>];</span><br><span class="line">    arm-&gt;theta[<span class="number">2</span>] = -servo[<span class="number">1</span>];</span><br><span class="line">    arm-&gt;theta[<span class="number">3</span>] =  PI/<span class="number">2</span>-servo[<span class="number">2</span>];</span><br><span class="line">    get_Trans(arm);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算转移矩阵T"><a href="#计算转移矩阵T" class="headerlink" title="计算转移矩阵T"></a>计算转移矩阵T</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get the Transparent Matrix relay on the current arm state</span></span><br><span class="line"><span class="comment"> * @param arm </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_Trans</span><span class="params">(<span class="type">robotic_arm_t</span> *arm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=arm-&gt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arm-&gt;T[i]-&gt;m=<span class="number">4</span>, arm-&gt;T[i]-&gt;n=<span class="number">4</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">0</span>] =  <span class="built_in">cos</span>(arm-&gt;theta[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">1</span>] = -<span class="built_in">sin</span>(arm-&gt;theta[i])*<span class="built_in">cos</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">2</span>] =  <span class="built_in">sin</span>(arm-&gt;theta[i])*<span class="built_in">sin</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">3</span>] =  arm-&gt;a[i]*<span class="built_in">cos</span>(arm-&gt;theta[i]);</span><br><span class="line"></span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">0</span>] =  <span class="built_in">sin</span>(arm-&gt;theta[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">1</span>] =  <span class="built_in">cos</span>(arm-&gt;theta[i])*<span class="built_in">cos</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">2</span>] = -<span class="built_in">cos</span>(arm-&gt;theta[i])*<span class="built_in">sin</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">3</span>] =  arm-&gt;a[i]*<span class="built_in">sin</span>(arm-&gt;theta[i]);</span><br><span class="line"></span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">0</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">1</span>] =  <span class="built_in">sin</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">2</span>] =  <span class="built_in">cos</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">3</span>] =  arm-&gt;d[i];</span><br><span class="line"></span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">0</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">1</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">2</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">3</span>] =  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="正向求解-1"><a href="#正向求解-1" class="headerlink" title="正向求解"></a>正向求解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get the coordinates of the point in the end coordinate system in the main coordinate system</span></span><br><span class="line"><span class="comment"> *        Suppose the main coordinate system&#x27;s number is 0</span></span><br><span class="line"><span class="comment"> *        得到末端坐标系中的一个点在主坐标系中的坐标,假设主坐标系编号为0</span></span><br><span class="line"><span class="comment"> * @param arm </span></span><br><span class="line"><span class="comment"> * @param point </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foward_solve</span><span class="params">(<span class="type">robotic_arm_t</span> *arm, Matrix_t *point)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=arm-&gt;n; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">    *point = multiply_matrix2(arm-&gt;T[i],point);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向求解"><a href="#逆向求解" class="headerlink" title="逆向求解"></a>逆向求解</h2><p>​    针对于我手上的机械臂，直接采用几何法分析。可是方程我解不出来😂，于是将其稍微变形，利用<strong>二分法</strong>也能迅速求得符合精度要求的解。</p><p><img src="https://s2.loli.net/2022/11/23/ksmLN1CvphgzIEj.jpg" alt="几何逆解.jpg" style="zoom:50%;" /></p><div class="note blue icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>具体二分的思路就是<strong>alpha</strong>越大，机械臂伸得越短，<strong>alpha</strong>越小，伸得越长。比较伸的长短是否到达</p></div><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Use the dichotomy method to find the angle of each joint according to the target coordinates </span></span><br><span class="line"><span class="comment"> *        用二分法根据目标坐标求出关节角度。（使用了几何法，仅适用于特定机械臂）</span></span><br><span class="line"><span class="comment"> *        根据末端机械手位姿求出最后一个关节的坐标(这一步还没实现)，由此计算其余关节角度。</span></span><br><span class="line"><span class="comment"> * @param arm 自己的机械臂，非通解</span></span><br><span class="line"><span class="comment"> * @param point 最后一个关节的坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_solve_dichonomy</span><span class="params">(<span class="type">robotic_arm_t</span> *arm, Matrix_t point)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> angle0, angle1, angle2, alpha_l=<span class="number">0</span>, alpha_r=PI, alpha_mid, beta, theta, len_xy, x, y, z, l1, l2, d;</span><br><span class="line">    x = point.matrix[<span class="number">0</span>][<span class="number">0</span>], y = point.matrix[<span class="number">1</span>][<span class="number">0</span>], z = point.matrix[<span class="number">2</span>][<span class="number">0</span>] - arm-&gt;d[<span class="number">1</span>];</span><br><span class="line">    d = <span class="built_in">sqrt</span>(x*x + y*y + z*z);</span><br><span class="line">    l1 = arm-&gt;a[<span class="number">2</span>], l2 = arm-&gt;a[<span class="number">3</span>];</span><br><span class="line">    len_xy = <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">    <span class="keyword">if</span>(len_xy == <span class="number">0</span>) &#123;theta = PI/<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;theta = <span class="built_in">atan</span>(z/len_xy);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(alpha_r-alpha_l &gt; <span class="number">0.00175</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        alpha_mid = (alpha_l+alpha_r)/<span class="number">2</span>;</span><br><span class="line">        beta = <span class="built_in">asin</span>(<span class="built_in">sin</span>(alpha_mid)*l1/l2);</span><br><span class="line">        <span class="keyword">if</span>(l1*<span class="built_in">cos</span>(alpha_mid) + l2*<span class="built_in">cos</span>(beta) &gt; d)</span><br><span class="line">        &#123;alpha_l = alpha_mid;&#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;alpha_r = alpha_mid;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) &#123;angle0 = PI/<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;angle0 = <span class="built_in">atan</span>(y/x);&#125;</span><br><span class="line">    angle1 = theta - alpha_mid;</span><br><span class="line">    angle2 = alpha_mid + beta + PI/<span class="number">2</span>;</span><br><span class="line">    arm-&gt;theta[<span class="number">1</span>] =  angle0;</span><br><span class="line">    arm-&gt;theta[<span class="number">2</span>] = -angle1;</span><br><span class="line">    arm-&gt;theta[<span class="number">3</span>] = PI/<span class="number">2</span> - angle2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也尝试了使用MATLAB解方程，得出的结果十分的复杂，我觉得还是直接用二分法比较好。</p><p><img src="https://s2.loli.net/2022/11/24/EtFa9Bnypj4YwlZ.png" alt="MATLAB.png"></p><h1 id="粒子群优化算法"><a href="#粒子群优化算法" class="headerlink" title="粒子群优化算法"></a>粒子群优化算法</h1><p>​    在之前的逆解过程中，只能针对单个机械臂的几何特征单独求解，不具有泛用性。而且以我的数学水平也只能求解结构简单的机械臂🤣，当关节数增加甚至冗余时，无法直接用数学方法求解，或者说是多解。所以尝试采用<strong>粒子群优化算法(Particle Swarm Optimization, PSO)</strong>来实现一种通用的解法。</p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://zhuanlan.zhihu.com/p/346355572">粒子群优化算法(Particle Swarm Optimization, PSO)的详细解读 - 知乎 (zhihu.com)</a></p></div><p>这位大佬写得非常详细，我这里是使用c语言实现的，并将其用在了机械臂逆解上面。</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ul><li>粒子群初始化及各粒子随机初始化</li><li>开始迭代<ul><li>计算适应值</li><li>更新个体及群体最优解与最优适应值</li><li>更新w值，粒子速度，粒子位置</li></ul></li><li>结束迭代</li><li>返回寻得的最优解</li></ul><h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><p>看完上面的博客之后，想必这些定义是很容易理解的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param X current state 目前坐标（解）</span></span><br><span class="line"><span class="comment"> * @param V current velocity 目前速度</span></span><br><span class="line"><span class="comment"> * @param opt_X optimal solution of individual&#x27;s history 个体历史最优解</span></span><br><span class="line"><span class="comment"> * @param opt_A optimal adaptability of individual&#x27;s history 个体历史最优适应值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">bird_t</span>&#123;</span></span><br><span class="line">    <span class="type">double</span> X[arm_MX_nodes], V[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> opt_X[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> opt_A;</span><br><span class="line">&#125;<span class="type">bird_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param N size of the bird population 种群规模</span></span><br><span class="line"><span class="comment"> * @param D 解的维度</span></span><br><span class="line"><span class="comment"> * @param K 迭代次数</span></span><br><span class="line"><span class="comment"> * @param W 惯性权重</span></span><br><span class="line"><span class="comment"> * @param C_ind 个体学习因子</span></span><br><span class="line"><span class="comment"> * @param C_pop 群体学习因子</span></span><br><span class="line"><span class="comment"> * @param opt_X_pop optimal solution of population&#x27;s history 群体历史最优解</span></span><br><span class="line"><span class="comment"> * @param opt_A_pop optimal adapatability of population&#x27;s history 群体历史最优解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">bird_population_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> N, D, K;</span><br><span class="line">    <span class="type">double</span> W, C_ind, C_pop;</span><br><span class="line">    <span class="type">double</span> opt_X_pop[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> opt_A_pop;</span><br><span class="line">    <span class="type">bird_t</span> *bird[N_MX_SIZE];</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">bird_population_t</span>;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​    单个粒子的初始化，至于为什么要用 <em>‘bird’</em> 来命名呢，因为这个算法其实也算是一种仿生的思路，作者是受到鸟群觅食的启发发明了这个算法。我第一眼看到这个算法想到的就是遗传算法，其实感觉都是优化的搜索方法，不过相比于遗传算法此算法在求机械臂逆解的应用中更胜一筹，具体怎么个优势法还有待去研究研究。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 粒子随机初始化</span></span><br><span class="line"><span class="comment"> * 在这里面分配空间一定程度上也可以防止空间浪费</span></span><br><span class="line"><span class="comment"> * @param pop </span></span><br><span class="line"><span class="comment"> * @return bird_t* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bird_t</span> *<span class="title function_">bird_init</span><span class="params">(<span class="type">bird_population_t</span> *pop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">bird_t</span> *bird;</span><br><span class="line">    bird = (<span class="type">bird_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bird_t</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pop-&gt;D; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bird-&gt;X[i] = PI*(rand()%<span class="number">180</span>)/<span class="number">180</span>;</span><br><span class="line">        bird-&gt;V[i] = PI*(rand()%<span class="number">20</span><span class="number">-10</span>)/<span class="number">180</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bird-&gt;opt_A = BADDEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bird;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 粒子群初始化</span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @param d </span></span><br><span class="line"><span class="comment"> * @param k </span></span><br><span class="line"><span class="comment"> * @param w </span></span><br><span class="line"><span class="comment"> * @param c_ind </span></span><br><span class="line"><span class="comment"> * @param c_pop </span></span><br><span class="line"><span class="comment"> * @return bird_population_t* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bird_population_t</span> *<span class="title function_">bird_population_init</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> k, <span class="type">double</span> w, <span class="type">double</span> c_ind, <span class="type">double</span> c_pop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bird_population_t</span> *bird_population;</span><br><span class="line">    bird_population = (<span class="type">bird_population_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bird_population_t</span>));</span><br><span class="line"></span><br><span class="line">    bird_population-&gt;N = n, bird_population-&gt;D = d, bird_population-&gt;K = k;</span><br><span class="line">    bird_population-&gt;W = w, bird_population-&gt;C_ind = c_ind, bird_population-&gt;C_pop = c_pop;</span><br><span class="line"></span><br><span class="line">    srand((<span class="type">unsigned</span>)time( <span class="literal">NULL</span> ) );     </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bird_population-&gt;bird[i] = bird_init(bird_population);</span><br><span class="line">    &#125;</span><br><span class="line">    bird_population-&gt;opt_A_pop = BADDEST;</span><br><span class="line">    <span class="keyword">return</span> bird_population;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;bird_pop-&gt;K; i++)<span class="comment">//K</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;bird_pop-&gt;N;j++)<span class="comment">//N</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算适应值</span></span><br><span class="line">            Matrix_t *judge_point = point_init(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="type">double</span> ada=<span class="number">0</span>;<span class="comment">//适应值</span></span><br><span class="line">            DH_update(arm,bird_pop-&gt;bird[j]-&gt;X);</span><br><span class="line">            foward_solve(arm,judge_point);</span><br><span class="line">            ada += (point.matrix[<span class="number">0</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">0</span>][<span class="number">0</span>])*(point.matrix[<span class="number">0</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            ada += (point.matrix[<span class="number">1</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">1</span>][<span class="number">0</span>])*(point.matrix[<span class="number">1</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            ada += (point.matrix[<span class="number">2</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">2</span>][<span class="number">0</span>])*(point.matrix[<span class="number">2</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新个体与群体最优适应值与最优解</span></span><br><span class="line">            <span class="keyword">if</span>(ada &lt; bird_pop-&gt;bird[j]-&gt;opt_A)</span><br><span class="line">            &#123;</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;opt_A = ada;</span><br><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++)</span><br><span class="line">                &#123;bird_pop-&gt;bird[j]-&gt;opt_X[k] = bird_pop-&gt;bird[j]-&gt;X[k];&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ada &lt; bird_pop-&gt;opt_A_pop)</span><br><span class="line">            &#123;</span><br><span class="line">                bird_pop-&gt;opt_A_pop = ada;</span><br><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++)</span><br><span class="line">                &#123;bird_pop-&gt;opt_X_pop[k] = bird_pop-&gt;bird[j]-&gt;X[k];&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新w值，更新各维度速度与位置</span></span><br><span class="line">            w = W_MAX - (W_MAX - W_MIN)*((<span class="type">double</span>)i/bird_pop-&gt;K);</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;V[k] = (w+(rand()/<span class="number">16384</span><span class="number">-1</span>)*<span class="number">0.15</span>)*(bird_pop-&gt;bird[j]-&gt;V[k]) + (rand()/<span class="number">16384</span>)*<span class="number">1.8</span>*(bird_pop-&gt;opt_X_pop[k] - bird_pop-&gt;bird[j]-&gt;X[k]) + (rand()/<span class="number">16384</span>)*<span class="number">1.6</span>*(bird_pop-&gt;bird[j]-&gt;opt_X[k] - bird_pop-&gt;bird[j]-&gt;X[k]);</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;V[k] = (bird_pop-&gt;bird[j]-&gt;V[k] &gt; V_MAX) ? V_MAX : bird_pop-&gt;bird[j]-&gt;V[k];</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;V[k] = (bird_pop-&gt;bird[j]-&gt;V[k] &lt; V_MIN) ? V_MIN : bird_pop-&gt;bird[j]-&gt;V[k];</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;X[k] += bird_pop-&gt;bird[j]-&gt;V[k]; </span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;X[k] = (bird_pop-&gt;bird[j]-&gt;X[k] &gt; X_MAX) ? X_MAX : bird_pop-&gt;bird[j]-&gt;X[k];</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;X[k] = (bird_pop-&gt;bird[j]-&gt;X[k] &lt; X_MIN) ? X_MIN : bird_pop-&gt;bird[j]-&gt;X[k];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//打印调试</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    bird%d: \r\n        当前位置X: &quot;</span>,j);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;arm-&gt;n; m++) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%.3f|%.1f, &quot;</span>,bird_pop-&gt;bird[j]-&gt;X[m],rad_angle(bird_pop-&gt;bird[j]-&gt;X[m]));&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r\n        当前速度V: &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;arm-&gt;n; m++) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%.3f|%.1f, &quot;</span>,bird_pop-&gt;bird[j]-&gt;V[m],rad_angle(bird_pop-&gt;bird[j]-&gt;V[m]));&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(judge_point);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//打印调试</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 最适值: %.3f 惯性w: %.3f\r\n&quot;</span>,i,bird_pop-&gt;opt_A_pop,w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   角度X: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%.2f|%.1f &quot;</span>,bird_pop-&gt;opt_X_pop[k],rad_angle(bird_pop-&gt;opt_X_pop[k]));&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一些小细节"><a href="#一些小细节" class="headerlink" title="一些小细节"></a>一些小细节</h3><p><img src="https://s2.loli.net/2022/11/23/2PGk5JcVnpuKwIq.png" alt="bug1.png"  /></p><p>​    可以看到，虽然我添加了时间随机数种子，但是生成的粒子仍然是全都一样的。这里要将<code>srand((insigned)time(NULL));</code>提前至初始化函数外。</p><p>​    </p><p><code>w = W_MAX - (W_MAX - W_MIN)*((double)i/bird_pop-&gt;K);</code> 在给<strong>w</strong>加权的时候别忘了<code>double</code>，不然后面算出来一直是0。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>感谢大家耐心看完了本篇博客，如果觉得不错的话欢迎分享给他人。由于本人水平有限，难免有错误的地方，也欢迎在评论区批评指正。完整的代码可以在我的代码仓库找到，后续也会将其移植到STM32上。在这里贴上主要代码方便随时查看，思路与代码相互对照也更容易理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运动学分析 </tag>
            
            <tag> 机械臂 </tag>
            
            <tag> D-H参数法 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 粒子群优化算法 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIY平衡小车</title>
      <link href="/2022/11/12/DIY%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6/"/>
      <url>/2022/11/12/DIY%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="前期基本方案"><a href="#前期基本方案" class="headerlink" title="前期基本方案"></a>前期基本方案</h1><h2 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h2><h3 id="基本目标"><a href="#基本目标" class="headerlink" title="基本目标"></a>基本目标</h3><ul><li>根据指令实现精准的速度控制</li><li>自身坐标和姿态的解算</li><li>与上位机传输数据</li></ul><h3 id="更有意思的目标"><a href="#更有意思的目标" class="headerlink" title="更有意思的目标"></a>更有意思的目标</h3><ul><li>双轮平衡车</li><li>控制雷达平稳</li></ul><h2 id="电机驱动"><a href="#电机驱动" class="headerlink" title="电机驱动"></a>电机驱动</h2><p>​    电机使用<strong>12V</strong>供电，可以直接由电源模块供电。使用<strong>TB6612驱动模块</strong>可以满足两个电机的驱动需求。</p><h2 id="位姿测量"><a href="#位姿测量" class="headerlink" title="位姿测量"></a>位姿测量</h2><p>​    使用<strong>MPU6050</strong>可以获取角速度和加速度值（但是之前试用的时候发现其自带的库位姿解算会有不少时间的初始化延迟）。</p><p>​    MPU6050使用<strong>IIC</strong>通信，在获得了新的测量之后会在<strong>INT</strong>脚输出高电平，为了保证数据的即时性，将一个GPIO配置为外部中断，在中断函数里更新数据。</p><h2 id="轮速获取"><a href="#轮速获取" class="headerlink" title="轮速获取"></a>轮速获取</h2><p>​    将两个定时器配置为<strong>编码器接口模式</strong>，分别接收两个电机对应的编码器数据。我们使用的是AB双相输入的编码器，参考手册：</p><blockquote><p>如果计数器只在TI2的边沿计数，则置TIMx_SMCR寄存器中的SMS=001；如果只在TI1边沿计数，则置SMS=010；如果计数器同时在TI1和TI2边沿计数，则置SMS=011。  </p></blockquote><p>对寄存器的配置已经被封装在库函数<strong>TIM_EncoderInterfaceConfig（ ）</strong>里了，只需要选择配置<strong>模式3</strong>即可，在这个情况下，TI1和TI2分别对应TIMx的<strong>channel1</strong>和<strong>channel2</strong>的引脚，默认情况下TIM2就是<strong>PA0 PA1</strong>,TIM3是<strong>PA6 PA7</strong>。</p><p>也可以与MPU6050传感器数据融合。</p><h2 id="运动控制"><a href="#运动控制" class="headerlink" title="运动控制"></a>运动控制</h2><h3 id="直立环"><a href="#直立环" class="headerlink" title="直立环"></a>直立环</h3><p>直立环使小车保持直立，即保持在<strong>机械中值θ</strong>的位置，理想情况下是保持0°。</p><script type="math/tex; mode=display">$PWM_{balance} = KP * θ + KD * \Delta θ</script><h3 id="速度环"><a href="#速度环" class="headerlink" title="速度环"></a>速度环</h3><p>​    根据上位机发布的速度指令或者由<strong>位置环</strong>计算出的目标速度计算出输出力矩。</p><script type="math/tex; mode=display">PWM_{speed} = KP_s * Error + KD_s * \Delta Error</script><h3 id="速度环（平衡车）"><a href="#速度环（平衡车）" class="headerlink" title="速度环（平衡车）"></a>速度环（平衡车）</h3><p>​    但是由于安装等外界因素影响，小车以为的<strong>0°</strong>并非真正的平衡态，于是我们引入了<strong>速度环</strong>。当小车速度稳定时，便可以认为小车进入平衡态。速度环的输出可以看作是一个<strong>角度</strong>，作为直立环的输入，直立环便演变成了使小车保持一定角度，在保持角度的时候便会产生速度。</p><script type="math/tex; mode=display">balance \_ IN \_ speed = KP_S * Error + KD_S * \Delta Error</script><script type="math/tex; mode=display">PWM \_ balance \_ speed=KP * (θ + balance \_ IN \_ speed) + KD * \Delta θ</script><p>合并整理后便可得到</p><script type="math/tex; mode=display">PWM \_ balance \_ speed = KP * θ + KD * \Delta θ + KP（ KP_S * Error + KD_S * \Delta Error）</script><p>两者其实是线性相加的，直接将KP <em> KP_S合并为KP_S，KP </em> KD_S合并为KD_S，最终简化为</p><script type="math/tex; mode=display">PWM_{balance} = KP * \theta + KD * \Delta \theta</script><script type="math/tex; mode=display">PWM_{speed} = KP_s *Error + KD_s * \Delta Error</script><script type="math/tex; mode=display">PWM = PWM_{speed} + PWM_{balance}</script><h3 id="转向环"><a href="#转向环" class="headerlink" title="转向环"></a>转向环</h3><p>​    转向环比较简单，直接根据<strong>角度</strong>输出一个速度差，用<strong>PD</strong>控制即可。</p><h2 id="控制雷达平稳"><a href="#控制雷达平稳" class="headerlink" title="控制雷达平稳"></a>控制雷达平稳</h2><p>​    根据车子姿态控制舵机角度以尽可能保证雷达平稳。</p><h2 id="运动模型"><a href="#运动模型" class="headerlink" title="运动模型"></a>运动模型</h2><p>​    设：车子速度为<strong>v</strong> ； 两轮速度分别为<strong>v1，v2</strong> ；两轮间距为<strong>d</strong> ；速度瞬心为点 <strong>P</strong> ； 速度瞬心离两轮距离分别为 <strong>r1 , r2</strong> ；车身角速度为 <strong>w</strong> ； 车子运动轨迹半径为<strong>R</strong> ；<strong>逆时针</strong>转为正方向</p><p>​    可以算得：</p><script type="math/tex; mode=display">v =\frac{1}{2} ( v_1 + v_2 )</script><script type="math/tex; mode=display">\omega = \frac{v_2 - v_1}{d}</script><p>​    </p><script type="math/tex; mode=display">R = d\frac{v_1 + v_2}{2(v_2 - v_1)}</script><p>目前的想法是建立一个<strong>世界坐标系</strong>和一个<strong>车子坐标系</strong>。</p><ul><li>在<strong>车子坐标系</strong>中可以轻松地计算出<strong>下一时刻</strong>车子的位置和姿态 ；</li><li>而通过<strong>这一时刻</strong>车子的位置和姿态又可以得到此时车子坐标系与世界坐标系的<strong>变换矩阵</strong>；</li><li>利用<strong>变换矩阵</strong>可以将<strong>车子坐标系中</strong>下一时刻的位姿转换到<strong>世界坐标系</strong>。</li></ul><p>​    如此便可以完成状态递推。</p><script type="math/tex; mode=display">\Delta \theta_k = \frac{v_{k-1}}{R_{k-1}} \Delta t</script><script type="math/tex; mode=display">\Delta x_k = R_{k-1} (1 - \cos {\Delta \theta_k})</script><script type="math/tex; mode=display">\Delta y_k = R_{k-1} \sin{\Delta \theta_k}</script><script type="math/tex; mode=display">x_k = x_{k-1} + \Delta x_k \sin{\theta_{k-1}} + \Delta y_k \cos{\theta_{k-1}}</script><script type="math/tex; mode=display">y_k = y_{k-1} - \Delta x_k \cos{\theta_{k-1}} + \Delta y_k \sin{\theta_{k-1}}</script><script type="math/tex; mode=display">\theta_k = \theta_{k-1} + \Delta \theta_k</script><h1 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h1><h1 id="STM32代码"><a href="#STM32代码" class="headerlink" title="STM32代码"></a>STM32代码</h1><h2 id="运动控制调试"><a href="#运动控制调试" class="headerlink" title="运动控制调试"></a>运动控制调试</h2><p>​    调试里<strong>程计正解出位姿</strong>的时候，由于方向不一致，所以需要修改<strong>读取速度</strong>的极性。不过改完之后一定要记得把几个控制函数里的极性也做修改。比如角度控制环可能变成正反馈，速度环又可能变成逆反馈。</p><h2 id="串口调试"><a href="#串口调试" class="headerlink" title="串口调试"></a>串口调试</h2><p>​    DEBUG或者远程控制的时候选择使用串口外设。其中用到了三个串口，可以根据情况选择使用。</p><h3 id="接收中断问题"><a href="#接收中断问题" class="headerlink" title="接收中断问题"></a>接收中断问题</h3><p>​    程序主要由一个核心中断函数构成，在调试的过程中我发现由于这个中断函数的存在，串口通讯会经常出现通讯错误。显然是因为串口中断函数和这个核心中断函数冲突了，不过是中断优先级配置的问题。</p><p>​    可是我发现了这样一个问题，USART_IRQn配置为0x00,0x00，EXTI9_5_IRQn配置为0x00,0x01会严重影响串口数据接收的正确性，但是将后者配置为0x01,0x01就不会。<u>同样是优先级低于串口，为什么改变了后者的**抢断优先级**就会产生这样的区别呢？</u></p><p>​    当中断优先级配置完成后，若多个中断同时发生则先比较抢占优先级谁的值小谁先进行，若抢占优先级相同则比较子优先级谁的值小谁先进行，若两者都相同，就比较硬件中断编号（该编号由硬件自身决定），值得注意的是当一中断正在进行时又一中断发生若后者的抢占优先级的值比前者小则后者可以打断正在发生的中断执行后者的中断进程，需要注意 <emp>若后者的抢占优先级与前者相等但子优先级的值比前者小此时后者不能打断正在发生的中断, 必须等其完成后才能进行，</emp> 至于后者的优先级比正在发生的中断优先级低的情况，那就肯定是等待正在进行的中断完成后再进行。</p><p>​    所以说<em>“抢占”</em>一词，还是比较生动的。</p><p>​    <em>当然，如果直接用DMA的话就没这些问题了。</em></p><h3 id="USART2-DMA"><a href="#USART2-DMA" class="headerlink" title="USART2_DMA"></a>USART2_DMA</h3><p>​    在DMA初始化函数的最后，设置的<strong>TX</strong>与<strong>RX</strong>的开闭状态是不一样的，为什么呢？在理顺了具体的DMA收发过程之后便很容易理解了。</p><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><blockquote><p>判断DMA是否处于发送完毕的空闲状态。flag=1，正在发送</p><p>设置发送数据的地址与大小</p><p>CMD使能开始发送</p><p>（可执行其他操作）</p><p>DMA发送完成中断</p><p>清除标志位（包括flag）</p><p>CMD失能关闭通道</p></blockquote><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><blockquote><p>（DMA事先保持开启）</p><p>串口输入，DMA同时转运数据</p><p>传输完毕，串口空闲中断</p><p>清除标志位</p><p>CMD失能关闭DMA通道</p><p>获取DMA缓存中数据长度与数据</p><p>（切换接收缓冲器）</p><p>更新DMA剩余缓存（CNDTR）</p><p>CMD使能开启通道等待接收  </p></blockquote><p>sendbyte(u8 t)，串口会以对应的字符显示</p><h3 id="USART1-DMA"><a href="#USART1-DMA" class="headerlink" title="USART1_DMA"></a>USART1_DMA</h3><p>​    因为usart2的引脚可能要拿去做别的，给USART1也配个DMA。</p><p>给usart1配置DMA，想用这些控制代码编译的,这样只用改一个宏定义就可以选择配置或不配置DMA，但是出现了莫名其妙的错误，先不用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USART1_DMA 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​    配置了DMA后，串口1的printf就不能用了，会卡死循环。不过可以根据自己的通讯需求写几个函数，用起来反而更加方便。</p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h5 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof( )"></a>sizeof( )</h5><p>返回的是不算结束符的字节数，而不是位数。如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">则</span><br><span class="line"><span class="comment">//printf_s(char *s, u8 newline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(s) == <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>​    我天真的以为这是字符串的大小，我是后来我发现这个size一直是4，我愕然，这其实是指针的大小。</p><h5 id="malloc-n"><a href="#malloc-n" class="headerlink" title="malloc(n)"></a>malloc(n)</h5><p>n也是分配的<strong>字节数</strong>，所以也常常会看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">something_t</span> *p = (something *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">something_t</span>));</span><br></pre></td></tr></table></figure><h5 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf( )"></a>sprintf( )</h5><p>会直接覆盖原字符串，而不是向末尾添加，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(s,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">则</span><br><span class="line">s[<span class="number">0</span>]=<span class="string">&#x27;\r&#x27;</span>, s[<span class="number">1</span>]=<span class="string">&#x27;\n&#x27;</span>, s[<span class="number">2</span>]=<span class="string">&#x27;\0&#x27;</span>, s[<span class="number">3</span>]=<span class="string">&#x27;4&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="strcat-amp-strncat"><a href="#strcat-amp-strncat" class="headerlink" title="strcat( ) &amp; strncat( )"></a>strcat( ) &amp; strncat( )</h5><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其它位调用</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">printf_s(str,<span class="number">1</span>);<span class="comment">//方法一</span></span><br><span class="line">printf_s(<span class="string">&quot;1234&quot;</span>,<span class="number">1</span>);<span class="comment">//方法二</span></span><br><span class="line"><span class="comment">//printf_s(char *s, u8 newline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(s);</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">strcat</span>(s,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(s,<span class="string">&quot;1234\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    方法一可以正常运行，但是太麻烦；方法二会让32停止运行，个人认为是因为传递过去的是一个常量，不能够修改。但是size能正常返回，如果不尝试对数据进行修改，也可以正常打印。</p><p>​    想换行的话，如果<code>printf_s(&quot;1234\r\n&quot;)</code>，sizeof(s)返回的值依然是4，比较奇怪。为了调用起来方便，干脆直接新建一个字符串指针算了。</p><p><img src="C:\Users\Semitia\AppData\Roaming\Typora\typora-user-images\image-20230115153411523.png" alt="image-20230115153411523"></p><p>我在debug里面一步步进行就没有问题，结果全速运行的时候就出问题，我真的栓q了。</p><p><img src="C:\Users\Semitia\AppData\Roaming\Typora\typora-user-images\image-20230115154538616.png" alt="image-20230115154538616"></p><p>​    </p><p>​    发送字符串的时候计算len的时候别忘了多算一个，是留给结束符的空间。如果没有算上的话，串口打印出来会有一些乱码，加上之后就没有了，应该是这个原因吧。</p><h3 id="蓝牙SPP"><a href="#蓝牙SPP" class="headerlink" title="蓝牙SPP"></a>蓝牙SPP</h3><h4 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h4><p>手机发消息的时候别忘了加回车</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>​    之前UART2，UART3都是没问题的，但是今天调试的时候发现插在UART3上面，连接到蓝牙的时候单片机就会停止运行。</p><p>​    DEBUG发现竟然卡在15_10的中断函数里面，查询手册发现UART3的RX是PB11，而这个代码正好把PB11配置为了超声波模块的中断引脚，中断函数里会等待超声波模块回复的高电平，导致一直在等待。一般这两个功能是没有一起使用的必要的，所以直接关闭其中一个即可。</p><p>​    但是还有一个问题，就是串口接收到的数据解析出现错误。结果是因为USART3_RX_BUF写成了复制的USART_RX_BUF没改过来😂。</p><h3 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h3><h4 id="USART1——STM32与ROS"><a href="#USART1——STM32与ROS" class="headerlink" title="USART1——STM32与ROS"></a>USART1——STM32与ROS</h4><p><strong>消息类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WARN_MSG 1 <span class="comment">//warn</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPD_MSG  2 <span class="comment">//speed</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POS_MSG  3 <span class="comment">//position</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PARA_MSG 4 <span class="comment">// param</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DES_MSG  5 <span class="comment">//destination</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACK_MSG  6 <span class="comment">//ACK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO_MSG 7 <span class="comment">//</span></span></span><br></pre></td></tr></table></figure><h5 id="DES-MSG"><a href="#DES-MSG" class="headerlink" title="DES_MSG"></a>DES_MSG</h5><p>stm32发送目的地及当前位置</p><p><strong>示例：”5+1234-4321+1111-2222+3333”</strong></p><ul><li>帧头：5</li><li>目的地横坐标+1234：1.234m</li><li>目的地纵坐标-4321：4.321m</li><li>当前横坐标+1111：1111mm</li><li>当前纵坐标-2222：2222mm</li><li>当前朝向+3333：弧度制3.333(不会超过±π)</li><li>结束符：\r\n</li></ul><h5 id="POS-MSG"><a href="#POS-MSG" class="headerlink" title="POS_MSG"></a>POS_MSG</h5><h6 id="stm32发送当前坐标与朝向角度"><a href="#stm32发送当前坐标与朝向角度" class="headerlink" title="stm32发送当前坐标与朝向角度"></a>stm32发送当前坐标与朝向角度</h6><p><strong>示例</strong>：<strong>“3+0282+9999+0000”</strong></p><ul><li>帧头</li></ul><h6 id="ROS发送需要到达的位置"><a href="#ROS发送需要到达的位置" class="headerlink" title="ROS发送需要到达的位置"></a>ROS发送需要到达的位置</h6><h5 id="SPD-MSG"><a href="#SPD-MSG" class="headerlink" title="SPD_MSG"></a>SPD_MSG</h5><p>ROS发送小车运动指令</p><p><strong>运动消息类型</strong></p><ul><li>for_bac=1：前后</li><li>turn=2：转向</li></ul><p><strong>示例：”21+1325\r\n”</strong></p><ul><li>帧头：2</li><li>运动类型1：直线速度为13.25</li><li>value+1325：</li></ul><h5 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a>ACK</h5><p>ROS发送ACK表示已经接收DES_MSG</p><p><strong>示例：”6\r\n”</strong></p><ul><li>帧头：6</li><li>结束符：\r\n</li></ul><h4 id="USART3——STM32与蓝牙模块"><a href="#USART3——STM32与蓝牙模块" class="headerlink" title="USART3——STM32与蓝牙模块"></a>USART3——STM32与蓝牙模块</h4><p>帧头不能用简单的字符，因为蓝牙模块在初始化的时候会发送大量的信息。</p><h5 id="DES-MSG-1"><a href="#DES-MSG-1" class="headerlink" title="DES_MSG"></a>DES_MSG</h5><p><em>手机通过蓝牙SPP发送小车目的地</em></p><p>示例：<strong>66612344321\r\n</strong></p><ul><li>帧头：666</li><li>目的地横坐标：1234——1.234m</li><li>目的地纵坐标：4321——4.321m</li><li>结束符：\r\n</li></ul><h5 id="SPD-MSG-1"><a href="#SPD-MSG-1" class="headerlink" title="SPD_MSG"></a>SPD_MSG</h5><p>示例：<strong>“668 +1673 +1293\r\n”</strong></p><ul><li>帧头：668</li><li>间隔：<strong>‘ ‘</strong></li><li>直线速度+1673：16.73</li><li>角速度+1293：12.93</li><li>结束符：\r\n</li></ul><h5 id="PARAM-MSG"><a href="#PARAM-MSG" class="headerlink" title="PARAM_MSG"></a>PARAM_MSG</h5><p><strong>参数消息类型：</strong></p><ul><li>1：</li><li>2：</li><li>3：</li><li>4：</li><li>5:</li><li>6:</li><li>7：转向环KP，倍率3</li><li>8：转向环KI，倍率2</li></ul><p>示例：<strong>“667 8 +1000\r\n”</strong></p><ul><li><p>帧头：668</p></li><li><p>间隔：<strong>‘ ‘</strong></p></li><li><p>参数类型8：转向环KI</p></li><li><p>value+1000：KI=10</p></li><li></li></ul><h2 id="控制代码"><a href="#控制代码" class="headerlink" title="控制代码"></a>控制代码</h2><h1 id="LattePanda"><a href="#LattePanda" class="headerlink" title="LattePanda"></a>LattePanda</h1><h2 id="前言与Ubuntu18-04安装"><a href="#前言与Ubuntu18-04安装" class="headerlink" title="前言与Ubuntu18.04安装"></a>前言与Ubuntu18.04安装</h2><p>​    原本用的是树莓派3B，官方的desktop版本只有22.04版的，装上之后奇卡无比，浏览器都会闪退。但是这样也能用，之后装上了ROS2，惨痛的发现在终端编译都会闪退，所以尝试换成18.04（感觉对性能要求会低一些），正好18.04也与厂家代码更适配，所以尝试装了server版本，因为没有图形化界面，需要自己联网，安装图形化界面，过程比较曲折。可以参考这一篇博客</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://zhuanlan.zhihu.com/p/372861457">树莓派4B安装Ubuntu18.04+ROS Melodic终极教程 - 知乎 (zhihu.com)</a></p></div><p>安装ROS的话我发现了一个神仙博主提供的一键安装命令，非常方便。</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/qq_27865227/article/details/120191557?ops_request_misc=%7B%22request%5Fid%22%3A%22166141462416782391868234%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=166141462416782391868234&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-120191557-null-null.nonecase&amp;utm_term=如何一行代码&amp;spm=1018.2226.3001.4450">(15条消息) 如何一行代码安装ROS|2022最新版|一行代码安装ROS2|一行代码解决rosdep|一行代码配置多ROS环境_鱼香ROS的博客-CSDN博客_ros安装脚本</a></p></div><p>可是安装完了之后我悲惨的发现，就是树莓派性能不够，图形化界面装完了之后直接显示花屏。</p><p>​    所以我干脆一鼓作气买了个<strong>LattePanda2</strong>，性能据说约等于两个树莓派4B，八个树莓派3B。是X86架构的，自带Win10，还附带了一个Leonardo型号的Arduino，真不错。</p><h3 id="安装Ubuntu18-04"><a href="#安装Ubuntu18-04" class="headerlink" title="安装Ubuntu18.04"></a>安装Ubuntu18.04</h3><p>​    Tips：</p><ul><li>供电需要一个手机充电头和一个质量不错的数据线，至少2A。(之前树莓派先是随便找了一根线，结果一直显示供电不足)</li><li>用作启动盘的U盘质量也要好一点，不然会一直刻录失败（一开始用的送的U盘，结果折腾半天）</li></ul><p>可以参考这一篇文章（虽然是英文的，但是也可以看懂，而且说的很详细）</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation/blob/master/README_UBUNTU.md">LattePanda-Ubuntu18.04-Spinnaker-Installation/README_UBUNTU.md at master · imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation (github.com)</a></p></div><p>镜像下载链接</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://releases.ubuntu.com/18.04/">Ubuntu 18.04.6 LTS (Bionic Beaver)</a></p></div><p>​    接下来就是安装系统，具体可以参考上面的博客。有一点需要额外提一嘴，就是安装到后面发现一直是一个橙黄色背景，没有显示任何其他窗口，但是会发现能拖出鼠标，按键盘也有反应。其实是因为LattePanda内置一个屏幕，但是如果直接只用HDMI连显示屏的话这个是看不到的，相当于在左上角有一个看不见主屏幕，系统安装的操作窗口在那边。所以只能尝试用鼠标把那边的窗口拖过来，多试几次总能抓过来的😂。</p><h3 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h3><ul><li>使用软件：No machine</li></ul><p>​    在同一个局域网下，主机上的客户端可以搜索到Ubuntu，双击连接。接下来需要输入用户和密码，就是对应Ubuntu上的用户名和密码。我设置的用户名是<strong>Anya</strong>，计算机名是<strong>Bonder</strong>，所以输入 <strong>anya</strong> 和 <strong>密码</strong>。</p><emp>注意这里的用户名是不用输入大写的，区分了大小写反而会连接不上。</emp><h2 id="ROS1"><a href="#ROS1" class="headerlink" title="ROS1"></a>ROS1</h2><h3 id="安装melodic"><a href="#安装melodic" class="headerlink" title="安装melodic"></a>安装melodic</h3><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation/blob/master/README_UBUNTU.md">LattePanda-Ubuntu18.04-Spinnaker-Installation/README_UBUNTU.md at master · imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation (github.com)</a></p></div><h3 id="工作空间配置"><a href="#工作空间配置" class="headerlink" title="工作空间配置"></a>工作空间配置</h3><p>按照准备工作手册配置，不过还是会碰到不少问题。</p><p>手册链接</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i></div><h4 id="还要先安装一大堆包"><a href="#还要先安装一大堆包" class="headerlink" title="还要先安装一大堆包"></a>还要先安装一大堆包</h4><ul><li>geographic-msgs</li><li>moveit-core</li><li>world-canvas-msgs</li><li>moveit-visual-tools</li><li>moveit-ros-move-group</li><li>moveit-ros-planning-interface</li></ul><h4 id="中间出现了一些问题"><a href="#中间出现了一些问题" class="headerlink" title="中间出现了一些问题"></a>中间出现了一些问题</h4><blockquote><p>E: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用)<br>E: 无法获取 dpkg 前端锁 (/var/lib/dpkg/lock-frontend)，是否有其他进程正占用它？</p></blockquote><p>可以参考这一篇文章</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/zhang33565417/article/details/105164356">(17条消息) 解决 Ubuntu中 ‘E: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用) ’ 问题_程序猿秃头之路的博客-CSDN博客</a></p></div><p>里面的一些命令的解释：</p><blockquote><p>无法定位软件包 ros-melodic-world-canvas-msgs</p></blockquote><p>这样的话干脆直接在<strong>Github</strong>下载，然后粘贴到 <em>/工作空间/src</em> 下面，重命名为 <strong>world_canvas_msgs</strong>。</p><p><a href="https://github.com/corot/world_canvas_msgs">corot/world_canvas_msgs: Messages and services for the semantic maps framework (github.com)</a></p><p>​    但是编译出来报错，不知道是不是包不对，其他地方也找不到这个包了。这个包实际上也不是 <strong>melodic</strong> 版本的，不知道这个商家咋搞的。</p><p>​    那这样一直卡着也不是个办法，所谓<strong>断臂求生</strong>，干脆直接把 <strong>/src</strong>里面的包都删掉，只留个驱动包，总算是成功编译。</p><blockquote><p>RVIZ不显示图形化界面</p></blockquote><p>​    不管我怎么试，RVIZ只是显示应用图标，不显示图形化界面。最后当我想不管这个的时候，我右键了一下这个软件图标，发现可以看到这个小窗口，而且是动态的。我静默片刻，赫然一惊，又如触电一般想起来LattePanda内置有一个虚拟屏幕，我颤抖着将鼠标拽向左上角的虚空，试探性的拖着什么，还真拖出来了个窗口……哈哈哈哈！</p><p>​    虽然我更改了主屏幕，但是我还是毅然决然的停用了这个内置屏幕，太害人了。</p><h4 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h4><pre><code>因为每次新打开一个终端就要source运行一下功能包的启动脚本，比较麻烦，所以干脆直接添加到环境变量当中，这样每次新开终端就会自动运行。</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source ~/[工作空间]/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="启动雷达"><a href="#启动雷达" class="headerlink" title="启动雷达"></a>启动雷达</h4><p>运行<strong>launch文件</strong>，雷达总算是可以正常工作了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch ydlidar_ros_driver X2.launch</span><br></pre></td></tr></table></figure><h3 id="订阅雷达报文"><a href="#订阅雷达报文" class="headerlink" title="订阅雷达报文"></a>订阅雷达报文</h3><pre><code>可以通过`rostopic type [topic]`查看话题消息类型，雷达返回的报文类型是`&lt;sensor_msgs::LaserScan&gt;`，话题是`scan`要注意的一点是在新终端使用`rostopic echo`的时候也要先`source [工作空间]/devel/setup.bash`，不然是会报错的。如果事先添加过环境变量的话就没有关系了。</code></pre><blockquote><p>ERROR:Cannot load message class foe [message]. Are your messages built?</p></blockquote><h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><ul><li>seq 是消息的顺序标识发布节点在发布消息时，会自动累加</li><li>stamp 是消息中与数据相关联的时间戳</li><li>frame_id 是消息中与数据相关联的参考系id</li><li>angle_min 起始角度（rad）</li><li>angle_max 结束角度（rad）</li><li>angle_increment 角度分辨率（rad）</li><li>time_increment 每个角度扫描时间</li><li>scan_time 扫描间隔</li><li>range_min 测量的最小距离</li><li>range_max 测量的最大距离</li><li>ranges 各个角度的测量距离</li><li>intensities 各个角度的强度值</li></ul><p><img src="https://s2.loli.net/2023/01/09/A53aZ4CfiVo6TRr.png" alt="雷达报文.png"></p><h4 id="报文解析"><a href="#报文解析" class="headerlink" title="报文解析"></a>报文解析</h4><pre><code>从0到n，均匀分为8组。假设雷达三角指向的方向为前方，那么这8组可以依次划分为 **back, back_right, right, front_right, front, front_left, left, back_left**</code></pre><h3 id="避障实现"><a href="#避障实现" class="headerlink" title="避障实现"></a>避障实现</h3><pre><code>大致知道雷达报文的意思之后，就可以写一个很简单的避障思路了。根据八个方向的**ranges[]** 判断是否离障碍物过近，过近则将`unsigned char warn`的相应位置一，最后只需要用串口传输一个 **8字节**的数就可以帮助32进行避障了。自己写呢主要是实现起来相对简单，而且自己用起来也比较方便，所以没有去研究使用更厉害的避障算法。不过还是先收集一个看起来很不错的博客</code></pre><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>]</p><p><a href="https://blog.csdn.net/ben_xiao_hai_123/article/details/119541384">激光雷达SLAM建图导航相关算法（gmapping DWA teb）及原理（Costmap）资料收录_kay880的博客-CSDN博客_gmapping 获取costmap</a></p></div><h3 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h3><pre><code>  可以先用cutecom测试一下串口功能，不过好像要设置为**CR/LF**才能正常通讯。**CR**表示回车，**LF**表示换行，也就是分别对应着**\r\n**，stm32上串口消息接收的结束标志是**\r\n**</code></pre><p>​    我这里使用的串口是<strong>/dev/ttyUSB0</strong></p><h4 id="自定义msg"><a href="#自定义msg" class="headerlink" title="自定义msg"></a>自定义msg</h4><blockquote><p>find_package(</p><p>)</p><p>catkin_package(</p><p>)</p></blockquote><p>​    find_package里面的是编译我们这个功能包时所依赖的包。而catkin_pckage里面的又是依赖的这些包所依赖的包。前者配置没问题而后者配置有问题时，可能导致编译无误但是运行时出错。所以又可以将这两个分别记为 <em>编译时依赖</em> 与 <em>运行时依赖</em>。</p><p>(按照autolabor官方手册配置)</p><p>功能包下新建msg目录，添加<strong>UART.msg</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> warn_msg</span><br></pre></td></tr></table></figure><p><strong>package.xml</strong>添加包依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>CmakeLists.txt</strong>添加msg配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line">## 配置 msg 源文件</span><br><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  Person.msg</span><br><span class="line">)</span><br><span class="line"># 生成消息时依赖于 std_msgs</span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line">#执行时依赖</span><br><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES demo02_talker_listener</span><br><span class="line">  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/10/4doaeZhf9W6TPlz.png" alt="debug_msg2.png"></p><p><img src="https://s2.loli.net/2023/01/10/MWpUkriCHITc7wK.png" alt="debug_msg1.png"></p><p>需要在<strong>.xml</strong>里添加<strong>std_msg</strong>包；<strong>CmakeLists</strong>里 <em>generate_messages</em> 重复定义，需要删掉。</p><h4 id="串口调用"><a href="#串口调用" class="headerlink" title="串口调用"></a>串口调用</h4><p>因为是<strong>melodic</strong>版本，有对应的<strong>serial</strong>包，所以配置起来就比在<strong>noetic</strong>上面要方便不少。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-serial</span><br></pre></td></tr></table></figure><h5 id="调用自定义头文件serial-head-h"><a href="#调用自定义头文件serial-head-h" class="headerlink" title="调用自定义头文件serial_head.h"></a>调用自定义头文件serial_head.h</h5><p>​    为了方便在各个文件里调用串口，干脆直接写一个封装串口各个功能的头文件，供其他源文件调用。</p><p>​    需要在<code>/功能包/include/功能包名</code>下创建<strong>头文件</strong>，为了方便在vscode编写代码，需要添加路径。</p><p><code>&quot;/home/用户/工作空间/src/功能包/include/**&quot;</code></p><p>​    源文件里调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;[包名]/[头文件].h&quot;</span></span></span><br></pre></td></tr></table></figure><p>​    配置<strong>CmakeLists</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p>​    串口包发送的数据需要是<code>string</code>类型。</p><p>​    如果直接发送固定的字符串倒是没有什么问题，可以直接与32通讯。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string msgs = <span class="string">&quot;123456\r\n&quot;</span>;</span><br><span class="line">ser.<span class="built_in">SendMsgs</span>(msgs);</span><br></pre></td></tr></table></figure><p>​    但是实际上需要将<code>u8</code>类型的数据转化为<code>string</code>类型然后发送。</p><p>​    但是不能直接像这样把数据转化为字符串类型。一开始的时候我就是这样做的，但是让ROS自己发送自己接收测试发现根本显示不出字符串，如果直接发送给32的话，32会直接停止运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string msgs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> number=<span class="number">123</span>;</span><br><span class="line">msgs[<span class="number">0</span>] = number/<span class="number">100</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">number%=<span class="number">100</span>;</span><br><span class="line">msgs[<span class="number">1</span>] = number/<span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">number%=<span class="number">10</span>;</span><br><span class="line">msgs[<span class="number">2</span>] = number + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">msgs[<span class="number">3</span>] = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">msgs[<span class="number">4</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">msgs[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">SendMsgs</span>(msgs);</span><br></pre></td></tr></table></figure><p>但是如果直接输入字符串就没有任何问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string msgs = <span class="string">&quot;123\r\n&quot;</span>;</span><br><span class="line"><span class="built_in">SendMsgs</span>(msgs);</span><br></pre></td></tr></table></figure><p>​    很奇怪的是如果将两者的元素都分别打印出来的话明明是没有任何区别的，包括字符串结束符。</p><p>​    不得不说用这玩意儿DEBUG是真心难受，卡得不得了。下次尽量要现在自己电脑上调好，直接移植过去。</p><p>​    最后实现通过串口发送周围障碍情况给stm32,32依此完成运动规划。终于不用再碰这个鬼东西了，┭┮﹏┭┮</p><p>​    当然如果想进一步发挥上位机功能，实现更高级的避障，建图等功能的话还是要碰┭┮﹏┭┮</p><h2 id="ROS2"><a href="#ROS2" class="headerlink" title="ROS2"></a>ROS2</h2><p>​    直接跟着教程走基本没什么问题，可以得到雷达的报文，话题名为<strong>scan</strong>。当然前提是板子不能太卡，我之前用的树莓派3B直接编译到一半闪退，卡的不行，压根用不了。</p><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><h2 id="避障算法"><a href="#避障算法" class="headerlink" title="避障算法"></a>避障算法</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 运动学分析 </tag>
            
            <tag> 平衡小车 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波学习笔记</title>
      <link href="/2022/11/04/Kalman%20filter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/04/Kalman%20filter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    最近在学习卡尔曼滤波算法，这其中用到了一些数学和现代控制理论的知识。由于我在学习之前没有啥知识储备，在网上看了很多博客、花了很多时间之后依然是一种似懂非懂的感觉。终于找到了一些很棒的教程，感觉算是稍微理解了一些，整理了一些学习笔记，梳理思路，也方便日后查阅。</p><p><strong>教程链接</strong></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><a href="https://www.bilibili.com/video/BV1ez4y1X7eR/?spm_id_from=333.788&amp;vd_source=0f383e93e945bca07eaef9a9ee5d9db3">【卡尔曼滤波器】1_递归算法_Recursive Processing_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1Rh41117MT/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0f383e93e945bca07eaef9a9ee5d9db3">从放弃到精通！卡尔曼滤波从理论到实践~_哔哩哔哩_bilibili</a></li><li><a href="https://blog.csdn.net/Yemiekai/article/details/116372288">https://blog.csdn.net/Yemiekai/article/details/116372288</a></li></ul></div><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><h3 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h3><blockquote><p>将<strong>方差、协方差</strong>在一个矩阵中表现出来，体现变量间的<strong>联动关系</strong></p></blockquote><p>假设有<strong>X,Y,Z</strong>三组数据，每组数据有<strong>n</strong>个</p><h4 id="方差："><a href="#方差：" class="headerlink" title="方差："></a>方差：</h4><script type="math/tex; mode=display">\sigma_x^2 = \frac{1}{n}\sum(x_i - \bar{x})^2</script><p>方差越大，数据波动越大</p><h4 id="协方差："><a href="#协方差：" class="headerlink" title="协方差："></a>协方差：</h4><script type="math/tex; mode=display">\sigma_x\sigma_y = \sigma_y\sigma_x = \frac{1}{n}\sum(x_i - \bar{}x)(y_i - \bar{y})</script><p>协方差越小，X,Y相关性越低</p><h4 id="协方差矩阵："><a href="#协方差矩阵：" class="headerlink" title="协方差矩阵："></a>协方差矩阵：</h4><script type="math/tex; mode=display">\begin{bmatrix}\sigma_x^2 & \sigma_x\sigma_y & \sigma_x\sigma_z \\ \sigma_y\sigma_x & \sigma_y^2 & \sigma_y\sigma_z \\ \sigma_z\sigma_x & \sigma_z\sigma_y & \sigma_z^2\\ \end{bmatrix}</script><h4 id="过渡矩阵"><a href="#过渡矩阵" class="headerlink" title="过渡矩阵"></a>过渡矩阵</h4><p>过渡矩阵<strong>a</strong>用以计算协方差矩阵<strong>P</strong>：</p><script type="math/tex; mode=display">P = \frac{1}{n}a^Ta</script><p>结合公式容易理解：(此处为3x3矩阵)</p><script type="math/tex; mode=display">a = \begin{bmatrix}x1 & y1 & z1 \\ x2 & y2 & z2 \\ x3 & y3 & z3 \\ \end{bmatrix} - \frac{1}{3}\begin{bmatrix}1 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \\ \end{bmatrix}\begin{bmatrix}x1 & y1 & z1 \\ x2 & y2 & z2 \\ x3 & y3 & z3 \\ \end{bmatrix}</script><p>被减数即为<strong>原矩阵</strong>，而减数则为<strong>平均值矩阵</strong></p><h3 id="状态空间方程"><a href="#状态空间方程" class="headerlink" title="状态空间方程"></a>状态空间方程</h3><script type="math/tex; mode=display">\hat{X}_k = A\hat{X}_{k-1} + Bu_{k-1} + W_{k-1}</script><script type="math/tex; mode=display">Z_k = HX_k + V_k</script><p><strong>变量说明：</strong></p><ul><li><script type="math/tex">\hat{X}_k</script>：实际状态值</li><li><script type="math/tex">\hat{X}_{k-1}</script>：上一时刻状态值</li><li>$u_k-1$：控制输入量</li><li><em>A、H、B</em>：转换矩阵</li><li>$Z_k$：测量值</li><li>$W_{k-1}$：过程噪声</li><li>$V_k$：测量噪声</li></ul><p><strong>关于传递方程：</strong></p><p>​    如果我们掌握了一个物体的运动规律，那么这个时刻的状态可以通过上一个时刻的状态计算出来。但是也不能保证完全精准，所以添加了<strong>过程噪声——W</strong></p><p>​    举个例子——经典的阻尼弹簧振子模型：</p><p><img src="https://s2.loli.net/2022/11/05/njC8ubrIcYQRiF9.jpg" alt="阻尼弹簧.jpg"></p><p>弹簧恢复力 = kX，阻力 = Bv。将X的导数v记作$\dot{X}$，X的二阶导a记作$\ddot{X}$，便可以得到：</p><script type="math/tex; mode=display">m\ddot{X} + B\dot{X} + kX = F</script><p>取状态变量<strong>X1为位移</strong>，<strong>X2为速度</strong>，F记为控制输入<strong>u</strong>，根据之前公式可得：</p><script type="math/tex; mode=display">\dot{X_1} = X_2</script><script type="math/tex; mode=display">\dot{X_2} = \ddot{X} = \frac{1}{m}u - \frac{B}{m}X_2 - \frac{k}{m}X_1</script><p>写成矩阵的形式就是：</p><script type="math/tex; mode=display">\begin{bmatrix} \dot{X_1} \\ \dot{X_2} \end{bmatrix} = \begin{bmatrix} 0 & 1 \\ -\frac{k}{m} & -\frac{B}{m} \end{bmatrix}\begin{bmatrix} X_1 \\ X_2 \end{bmatrix} + \begin{bmatrix} 0 \\ \frac{1}{m} \end{bmatrix}u</script><p>对应着状态趋势矩阵与状态的关系：</p><script type="math/tex; mode=display">\dot{X_t} = AX_t + Bu_t</script><p>写成离散的形式就是：</p><script type="math/tex; mode=display">X_k = AX_{k-1} + Bu_{k}</script><p>当然最后加上不确定因素W</p><p><strong>关于测量方程：</strong></p><p>​    一般而言我们可能会习惯把<strong>待求量</strong>放在等式左边，已知量放在等式右边。但是在这里$Z_k$才是我们实际获得的数据。</p><p>​    关于转换矩阵H，一般我们无法直接测得需要的待测量，所以会测量其他量计算出待测量。举个例子</p><blockquote><p>激光测距仪测距：发射激光，根据返回用时计算距离。直接获得的物理量是 <strong>时间($Z_n$)</strong>，而我们想获得的 <strong>距离($X_n$)</strong>，于是有了转换矩阵 <strong>H($ \begin{bmatrix}\frac{2}{c}\end{bmatrix}$)</strong></p><script type="math/tex; mode=display">Z_n = \begin{bmatrix}\frac{2}{c}\end{bmatrix}X_n + V_n</script></blockquote><h2 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h2><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p><strong>先验估计方程：</strong></p><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1}</script><p><strong>先验误差协方差矩阵：</strong></p><script type="math/tex; mode=display">P_k^{-} = AP_{k-1}A^T + Q</script><h3 id="矫正"><a href="#矫正" class="headerlink" title="矫正"></a>矫正</h3><p><strong>卡尔曼增益：</strong></p><script type="math/tex; mode=display">K_k = \frac{P_k^- H^T}{HP_k^- H^T + R}</script><p><strong>后验估计：</strong></p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + K_k( Z_k - H\hat{X}_k^-)</script><p><strong>后验误差协方差矩阵：</strong></p><script type="math/tex; mode=display">P_k = ( I - K_kH)P_k^-</script><h3 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h3><ul><li><script type="math/tex">\hat{X}_k^-</script>：k时刻先验估计值——<strong>算出来的</strong></li><li>$\hat{X}_k$：最优估计值</li><li>$\hat{X}_{k-1}$：k-1时刻最优估计值</li><li>$u_k-1$：控制输入量</li><li>$K_k$：卡尔曼增益</li><li>$Z_k$：测量值——<strong>测出来的</strong></li><li>$W_{k-1}$：过程噪声</li><li>$V_k$：测量噪声</li><li>H：由状态量向测量量转换的矩阵</li></ul><p>变量<strong>带个帽子</strong>一般是<strong>估计值</strong>；变量右上角<strong>有个”-“</strong>一般是<strong>先验值</strong>。</p><h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><ol><li>由上一时刻<strong>最优估计值 $\hat{X}_{k-1}$</strong>计算<strong>先验估计值 $\hat{X}_k^-$</strong></li><li>获取<strong>测量值 $Z_k$</strong></li><li>由上一时刻<strong>误差协方差矩阵 $P_{k-1}$</strong>计算<strong>先验误差协方差矩阵 $P_K^-$</strong></li><li>计算<strong>卡尔曼增益$K_k$</strong></li><li>计算<strong>最优估计值<script type="math/tex">\hat{X}_k</script></strong></li><li>更新<strong>后验误差协方差矩阵 $P_k$</strong></li><li>不断更新迭代</li></ol><h2 id="公式说明与推导"><a href="#公式说明与推导" class="headerlink" title="公式说明与推导"></a>公式说明与推导</h2><h3 id="先验估计方程"><a href="#先验估计方程" class="headerlink" title="先验估计方程"></a>先验估计方程</h3><blockquote><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1}</script></blockquote><p>​    由上一时刻的<strong>最优估计值</strong>，根据运动模型推测这一时刻的状态值，即<strong>先验估计值</strong>。和<strong>传递方程</strong>类似。</p><h3 id="后验估计方程"><a href="#后验估计方程" class="headerlink" title="后验估计方程"></a>后验估计方程</h3><blockquote><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + K_k( Z_k - H\hat{X}_k^-)</script></blockquote><p>​    想要得到<strong>最优估计值</strong>，概括来说是根据数据的可靠性将<strong>测量值</strong>和<strong>计算值</strong>加权叠加起来，得到的就是<strong>后验估计值</strong>，也就是滤波过后得到的这一时刻的<strong>最优估计值</strong>。根据<strong>数据融合</strong>原理得到公式：</p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + G( H^-Z_k - \hat{X}_k^-)</script><p>但是我们经常看到的都是令 $G = K_kH$ 变换后的形式，即：</p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_{k}^- + K_k ( Z_k - H\hat{X}_{k}^- )</script><p>其中 $K_k$∈[0, $H^-$]</p><ul><li>当$K_k$ == 0 时，测量误差很大，信任计算出来的值，即 $\hat{X}_{k} == \hat{X}_{k}^-$;</li><li>当$K_k == H^-$时，无测量误差，信任测量值，即$\hat{X}_{k} == H^-Z_k$；</li></ul><h3 id="卡尔曼增益"><a href="#卡尔曼增益" class="headerlink" title="卡尔曼增益"></a>卡尔曼增益</h3><blockquote><script type="math/tex; mode=display">K_k = \frac{P_k^- H^T}{HP_k^- H^T + R}</script></blockquote><p>要计算卡尔曼增益，即求出使误差协方差最小的 $k_k$，在求出其关于$K_k$ 的表达式后再求导得到极值点。</p><h3 id="状态空间方程："><a href="#状态空间方程：" class="headerlink" title="状态空间方程："></a><strong>状态空间方程：</strong></h3><blockquote><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1} + W_{k-1}</script><script type="math/tex; mode=display">Z_k = HX_k + V_k</script></blockquote><p><img src="https://s2.loli.net/2022/11/03/hviNkZWEIeG39sw.jpg" alt="note1.jpg"></p><p><img src="https://s2.loli.net/2022/11/03/iwQRzfS7FlnPmZM.jpg" alt="note2.jpg"></p><h3 id="先后验误差协方差矩阵"><a href="#先后验误差协方差矩阵" class="headerlink" title="先后验误差协方差矩阵"></a>先后验误差协方差矩阵</h3><blockquote><script type="math/tex; mode=display">P_k^{-} = AP_{k-1}A^T + Q</script><script type="math/tex; mode=display">P_k = ( I - K_kH)P_k^-</script></blockquote><p><img src="https://s2.loli.net/2022/11/03/8bS1wKNJ3EoAOy2.jpg" alt="note.jpg"></p><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><h4 id="kalman-filter"><a href="#kalman-filter" class="headerlink" title="kalman_filter"></a>kalman_filter</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">filter</span><span class="params">(Matrix_t Z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    pre_angle1 += Z.matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    pre_angle2 += Z.matrix[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    pre_angle3 = (pre_angle1 + pre_angle2)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    _X = <span class="built_in">mul_matrix</span>(F,X);</span><br><span class="line">    _P = <span class="built_in">add_matrix</span>(<span class="built_in">mul_matrix</span>(<span class="built_in">mul_matrix</span>(F, P), <span class="built_in">tran_matrix</span>(F)), Q);</span><br><span class="line">    K  = <span class="built_in">mul_matrix</span>(<span class="built_in">mul_matrix</span>(_P,<span class="built_in">tran_matrix</span>(H)), <span class="built_in">inv_matrix</span>(<span class="built_in">add_matrix</span>(<span class="built_in">mul_matrix</span>(<span class="built_in">mul_matrix</span>(H,_P),<span class="built_in">tran_matrix</span>(H)),R)));</span><br><span class="line">    X  = <span class="built_in">add_matrix</span>(_X,<span class="built_in">mul_matrix</span>(K,<span class="built_in">sub_matrix</span>(Z,<span class="built_in">mul_matrix</span>(H,_X) ) ) );</span><br><span class="line">    P  = <span class="built_in">mul_matrix</span>(<span class="built_in">sub_matrix</span>(<span class="built_in">get_I</span>(<span class="number">2</span>),<span class="built_in">mul_matrix</span>(K,H)),_P); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\n&quot;</span>,count, pre_angle1, pre_angle2, pre_angle3, X.matrix[<span class="number">0</span>][<span class="number">0</span>], X.matrix[<span class="number">1</span>][<span class="number">0</span>], Z.matrix[<span class="number">0</span>][<span class="number">0</span>], Z.matrix[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行一次<strong>filter( )</strong>就是进行了一次迭代。</p><p>这里使用<strong>fprintf</strong>将数据打印至excel文件，绘出波形。</p><p>当然，这里还用到了一些矩阵运算函数，我写在<strong>Matrix.h</strong>里面，下次想运算矩阵就直接调用啦，非常方便。不过更多的运算函数有待进一步的完善。</p><ul><li>add_matrix：矩阵加法</li><li>sub_matrix：矩阵减法</li><li>mul_matrix：矩阵乘法</li><li>inv_matrix：矩阵求逆</li><li>tran_matrix：矩阵转置</li></ul><h3 id="MPU6050滤波"><a href="#MPU6050滤波" class="headerlink" title="MPU6050滤波"></a>MPU6050滤波</h3><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><script type="math/tex; mode=display">X = \begin{bmatrix}angle \\ bias\end{bmatrix}</script><p>​    选择<strong>angle</strong>和<strong>bias</strong>作为状态变量，其中angle为角度，bias为陀螺仪的零漂。bias就是在传感器静止时也会有的输出的角速度值，这个只是不确定的，而且会变化。但是即使我们随便给它一个初值，最终也会随着迭代次数的增加收敛到真实值附近</p><p><img src="https://s2.loli.net/2022/12/12/i3baZ5zcTdPnUXV.png" alt="零漂收敛.png"></p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><script type="math/tex; mode=display">X^-_k = \begin{bmatrix}angle \\bias\end{bmatrix}=\begin{bmatrix}1 & -dt \\0 & 1 \\\end{bmatrix}X_{k-1}+\begin{bmatrix}gyro*dt \\0\end{bmatrix}</script><h4 id="先验协方差矩阵"><a href="#先验协方差矩阵" class="headerlink" title="先验协方差矩阵"></a>先验协方差矩阵</h4><script type="math/tex; mode=display">P^-_k = \begin{bmatrix}1 & -dt \\ 0 & 1\\\end{bmatrix}P^-_{k-1}\begin{bmatrix}1 & 0 \\-dt & 1 \\\end{bmatrix}+\begin{bmatrix}Q_{angle} & 0 \\0 & Q_{bias} \\\end{bmatrix}</script><h4 id="测量方程"><a href="#测量方程" class="headerlink" title="测量方程"></a>测量方程</h4><p>传入的只有滤波之前的角度值，故有</p><script type="math/tex; mode=display">Z = HX + V \\H = \begin{bmatrix}1 & 0\end{bmatrix}</script><p>这里的原始角度值是由IMU的<strong>三轴加速度值</strong>直接解算而来。</p><p>后面的几个方程就没什么变化了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>​    感谢大家耐心看完了本篇博客，欢迎大家分享；由于我自己也是初学者，对卡尔曼滤波的理解还不算深入，难免会有不完善之处，这篇文章作为一篇笔记由于大家分享，也欢迎大家批评指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kalman Filter </tag>
            
            <tag> 控制方法 </tag>
            
            <tag> 滤波器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC &amp; PCA9685</title>
      <link href="/2022/11/01/%E8%88%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/01/%E8%88%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    有些时候需要同时驱动多个舵机，需要为每一个舵机调制出对应的<strong>PWM</strong>脉冲信号；如果舵机很多的话，会占用主控的很多资源。幸运的是有这样一款模块，只需要<strong>两个GPIO口</strong>，便可以通过<strong>I^2^C通信协议</strong>控制<strong>16</strong>路舵机（事实上可以串联多个模块，控制更多舵机）。在这里记录一下其使用方法和代码实现方法。</p><h1 id="I-2-C通讯协议"><a href="#I-2-C通讯协议" class="headerlink" title="I^2^C通讯协议"></a>I^2^C通讯协议</h1><p>一篇介绍的很详细的文章：<a href="https://zhuanlan.zhihu.com/p/362287272">一文看懂I2C协议 - 知乎 (zhihu.com)</a></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>这里附上较为权威的文件链接</p><ul><li><a href="https://semitia.top/upload_flies/TI_I2C_slva704.pdf">https://semitia.top/upload_flies/TI_I2C_slva704.pdf</a></li><li><a href="https://semitia.top/upload_flies/NXP_I2C_UM10204.pdf">https://semitia.top/upload_flies/NXP_I2C_UM10204.pdf</a></li><li><a href="https://semitia.top/upload_flies/ZLG_I2C.pdf">https://semitia.top/upload_flies/ZLG_I2C.pdf</a></li></ul></div><p>此篇笔记则是结合<strong>《TI_I2C_slva704》</strong>和<strong>代码</strong>简单记录一些基本功能。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    <strong>IIC</strong>使用两个接口<strong>(SCL和SDA)</strong>进行<strong>半双工通信</strong>。分为<strong>主机（Master)</strong>和<strong>从机（Slave device）</strong>，每个设备有自己特定的<strong>地址</strong>，一个设备有一个或多个寄存器储存数据，主机通过IIC总线对设备及其寄存器进行读写和配置。</p><h2 id="主机访问从机的一般流程"><a href="#主机访问从机的一般流程" class="headerlink" title="主机访问从机的一般流程"></a>主机访问从机的一般流程</h2><h3 id="发送数据："><a href="#发送数据：" class="headerlink" title="发送数据："></a>发送数据：</h3><ol><li>主机发送<strong>START</strong>信号和<strong>设备地址</strong>来指定一个设备</li><li>主机发送数据</li><li>主机发送<strong>STOP</strong>信号</li></ol><h3 id="接收数据："><a href="#接收数据：" class="headerlink" title="接收数据："></a>接收数据：</h3><ol><li>主机发送<strong>START</strong>信号和<strong>设备地址</strong>来指定一个设备</li><li>主机指定要读取的<strong>寄存器</strong></li><li>主机读取数据</li><li>主机发送<strong>STOP</strong>信号</li></ol><h2 id="START和STOP信号"><a href="#START和STOP信号" class="headerlink" title="START和STOP信号"></a>START和STOP信号</h2><ul><li><strong>STATRT</strong>：在<strong>SCL</strong>拉高的情况下，<strong>SDA</strong>电平由高变低，即<strong>下降沿</strong></li><li><strong>STOP</strong>：在<strong>SCL</strong>拉高的情况下，<strong>SDA</strong>电平由低变高，即<strong>上升沿</strong></li></ul><p><img src="https://s2.loli.net/2022/11/02/Rkjp2zrVq8NGIy9.png" alt="IIC_1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();     </span><br><span class="line">IIC_SDA=<span class="number">1</span>;    </span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SDA=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><code>SDA_OUT();</code>：将<strong>SDA</strong>端口设置为输出模式；在切换读写状态的时候，也要修改IO口配置</li><li><code>IIC_SCL=0;</code>：IIC总线接上拉电阻，故默认<strong>高电平</strong>状态为<strong>总线空闲</strong>状态；主机接下来要发送指令，所以要拉低电平，主机控制住总线。</li></ul><h4 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();<span class="comment">//sdaÏßÊä³ö</span></span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">IIC_SDA=<span class="number">0</span>;<span class="comment">//STOP:when CLK is high DATA change form low to high</span></span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>; </span><br><span class="line">IIC_SDA=<span class="number">1</span>;<span class="comment">//·¢ËÍI2C×ÜÏß½áÊøÐÅºÅ</span></span><br><span class="line">delay_us(<span class="number">4</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ACK-NACK-有无应答"><a href="#ACK-NACK-有无应答" class="headerlink" title="ACK/NACK 有无应答"></a>ACK/NACK 有无应答</h2><p>​    在完成一个字节的信息传输后，<strong>接收方</strong>可以发送<strong>ACK</strong>以告知发送方数据被成功接收；也可以选择不发送。在接收方发送ACK之前，发送方必须释放SDA线；接收方<strong>拉低SDA</strong>以发送ACK。</p><p>​    倘若在ACK位SDA仍然为高电位，则认为是<strong>NACK——无应答</strong>，无应答的一些情况：</p><ul><li>接收方没有做好接收的准备</li><li>接收方无法理解接收到的数据</li><li>接收方无法再接收更多数据</li><li>主机作为接收方完成了数据接收</li></ul><p>​    在这样的规定下，如果出现了主机数据接收失败的情况的话该如何判定呢？是不是冲突了呢？或许主机可以通过编程判定接受失败，进而选择是否重新请求数据。</p><p><img src="https://s2.loli.net/2022/11/02/4eo2YpZhjNr7V5s.png" alt="IIC_2.png"></p><h2 id="WRITE写操作"><a href="#WRITE写操作" class="headerlink" title="WRITE写操作"></a>WRITE写操作</h2><ul><li><p>数据传输以<strong>一个字(8bits)</strong>节为单位，最先发送<strong>MSB</strong>；</p></li><li><p>在<strong>STOP和START</strong>信号外需保证<strong>SDA</strong>只在<strong>SCL</strong>为<strong>低电平</strong>时发生跳变；<strong>SCL高</strong>时保证<strong>SDA</strong>稳定以读取数据。</p></li></ul><p>注：</p><p><strong>MSB &amp; LSB</strong>：</p><blockquote><p>MSB stands for most significant bit, while LSB is least significant bit. In binary terms, the MSB is the bit that has the greatest effect on the number, and it is the left-most bit. For example, for a binary number 0011 0101, the Most Significant 4 bits would be 0011. The Least Significant 4 bits would be 0101.</p></blockquote><h3 id="协议流程"><a href="#协议流程" class="headerlink" title="协议流程"></a>协议流程</h3><ol><li>主机发送<strong>START</strong>信号</li><li>主机发送<strong>7bits设备地址</strong></li><li><strong>R/W</strong>位置0——写0，读1</li><li>等待应答</li><li>主机发送<strong>从设备寄存器地址</strong></li><li>等待应答</li><li>写入数据</li><li>等待应答</li><li>主机发送<strong>STOP</strong>信号，操作结束。</li></ol><p><img src="https://s2.loli.net/2022/11/02/zMwCgD3Qt1vx5cy.png" alt="IIC_3.png"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>此处仅为发送一个字节的流程，完整流程请参考下方PCA9685实战代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Send_Byte</span><span class="params">(u8 txd)</span></span><br><span class="line">&#123;                        </span><br><span class="line">    u8 t;   </span><br><span class="line">SDA_OUT();     </span><br><span class="line">    IIC_SCL=<span class="number">0</span>;<span class="comment">//À­µÍÊ±ÖÓ¿ªÊ¼Êý¾Ý´«Êä</span></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">    &#123;              </span><br><span class="line">        IIC_SDA=(txd&amp;<span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>;</span><br><span class="line">        txd&lt;&lt;=<span class="number">1</span>;   </span><br><span class="line">delay_us(<span class="number">2</span>); </span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>); </span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="READ读操作"><a href="#READ读操作" class="headerlink" title="READ读操作"></a>READ读操作</h2><h3 id="协议流程-1"><a href="#协议流程-1" class="headerlink" title="协议流程"></a>协议流程</h3><ol><li>前两个字节与写操作相同</li><li>主机重复发送一次<strong>START</strong>信号</li><li>主机发送从设备地址</li><li><strong>R/W置</strong><span class='p red'>1</span>——读操作</li><li>等待应答</li><li>主机读取数据</li><li>主机<strong>不发送</strong>应答信号</li><li>主机发送<strong>STOP</strong>信号</li></ol><p><img src="https://s2.loli.net/2022/11/02/hQueywRLE3xf4v5.png" alt="IIC_4.png"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>同样是只读取一个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">IIC_Read_Byte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i,receive=<span class="number">0</span>;</span><br><span class="line">SDA_IN();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++ )</span><br><span class="line">&#123;</span><br><span class="line">        IIC_SCL=<span class="number">0</span>; </span><br><span class="line">        delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        receive&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(READ_SDA)receive++;   </span><br><span class="line">delay_us(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">        IIC_NAck();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        IIC_Ack();</span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="PCA9685芯片"><a href="#PCA9685芯片" class="headerlink" title="PCA9685芯片"></a>PCA9685芯片</h1><p>芯片手册：<a href="https://semitia.top/upload_flies/PCA9685.pdf">https://semitia.top/upload_flies/PCA9685.pdf</a></p><p>芯片手册的内容比较多，所以在这里只记录一些使用指导性相对更高的一些内容（主要参考第七小节）。</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><h3 id="设备地址"><a href="#设备地址" class="headerlink" title="设备地址"></a>设备地址</h3><p><img src="https://s2.loli.net/2022/11/02/zYo4QDi6RUrBw1L.png" alt="IIC_5.png"></p><p>在默认情况下设备地址是<strong>0x40</strong>，如果算上最后<strong>R/W</strong>位的话就是<strong>0x80</strong>。</p><p>在模块上能够看到六个留空的焊点，可以选择把部分焊点焊上，设备的地址对应位就会被<strong>置一</strong>。比如把<strong>第0位</strong>焊上，地址就变为了<strong>1000001</strong>。</p><h3 id="寄存器地址"><a href="#寄存器地址" class="headerlink" title="寄存器地址"></a>寄存器地址</h3><p>这是部分寄存器总览表，一共有16个led。各个寄存器的地址也都很清楚地列了出来</p><p><img src="https://s2.loli.net/2022/11/02/mXtORuGvFCWUkNr.png" alt="IIC_6.png"></p><h2 id="部分寄存器介绍"><a href="#部分寄存器介绍" class="headerlink" title="部分寄存器介绍"></a>部分寄存器介绍</h2><h3 id="MODE1寄存器"><a href="#MODE1寄存器" class="headerlink" title="MODE1寄存器"></a>MODE1寄存器</h3><p><img src="https://s2.loli.net/2022/11/02/oJsCdm8rMcOBLFj.png" alt="IIC_7.png"></p><p>比较常用的是<strong>第四位</strong>，即<strong>SLEEP</strong>位，因为在读写其他寄存器的时候会需要将芯片休眠，待会在原码介绍中也会见到。</p><p><img src="https://s2.loli.net/2022/11/02/KA7VLulbwsmYzqn.png" alt="IIC_8.png"></p><h3 id="LED-ON-OFF-H-L"><a href="#LED-ON-OFF-H-L" class="headerlink" title="LED_ON_OFF_H_L"></a>LED_ON_OFF_H_L</h3><p>每个PWM(led)输出端口的配置对应四个寄存器</p><ul><li>LEDn_ON_H</li><li>LEDn_ON_L</li><li>LEDn_OFF_H</li><li>LED_OFF_L</li></ul><p>每个寄存器是<strong>8位</strong>寄存器，但是<strong>ON</strong>或<strong>OFF</strong>只会分别储存<strong>十二位</strong>的数据，也就是<em>L</em>存8位，<em>H</em>存4位</p><p><img src="https://s2.loli.net/2022/11/02/lFafpNvyibHqVjo.png" alt="IIC_9.png"></p><p>具体的寄存器数据和PWM波形的关系如下</p><blockquote><p>​    <strong>ON</strong>和<strong>OFF</strong>分别存储着范围<strong>0~4096</strong>的值(确实是4096而非4095)，我们把两个值记作<strong>cnt_on, cnt_off</strong>吧。有一个计数器从0计数到<strong>4095</strong>，我们把计数器的值记作<strong>CNT</strong>。</p><p>一般情况下，都是<code>cnt_on &lt; cnt_off</code>：</p><ul><li>当<code>CNT == cnt_on</code>时，PWM波<strong>由低变高</strong>；</li><li>当<code>CNT == cnt_off</code>时，PWM波<strong>由高变低</strong>；</li></ul><p>当<code>cnt_off &lt; cnt_on</code>时，在第一个周期内<code>CNT == cnt_off</code>不做变化。</p><p>可以看出，控制精度是<strong>1/4096</strong>周期。</p></blockquote><p>具体的PWM调制方法我们结合官方手册里面给出的两个例子就很容易理解了：</p><p><img src="https://s2.loli.net/2022/11/02/e9yZhwCiX5AImpc.png" alt="IIC_10.png"></p><p>（这里我感觉 <em>Fig 7</em> 图里的<strong>819</strong>是不是应该是<strong>410</strong>）</p><p><img src="https://s2.loli.net/2022/11/02/82lKZfsdSYL9EnW.png" alt="IIC_11.png"></p><h3 id="PRE-SCALE"><a href="#PRE-SCALE" class="headerlink" title="PRE_SCALE"></a>PRE_SCALE</h3><p><img src="https://s2.loli.net/2022/11/02/Y9Ch54OApUxLM8e.png" alt="IIC_12.png"></p><p>​    <strong>PRE_SCALE</strong>寄存器用以调制PWM频率。驱动舵机的话我们需要<strong>20ms</strong>的脉冲，频率为<strong>50Hz</strong>。</p><p>​    如果学习过STM32用定时器输出PWM的话应该很容易理解，只不过这里的<strong>自动重装载值</strong>固定为4096。</p><p>​    时钟给出的是<strong>25MHz</strong>的频率，如果我们设置<strong>n分频</strong>，那么<strong>计数器</strong>就会每过<strong>$\frac{n}{25000000}$</strong>秒计数一次，那么$T_n = \frac{4096n}{25000000}$秒就是一个周期。假如我们要<strong>50Hz</strong>的脉冲，那么周期应该是<strong>20ms</strong>，令$T_n == 0.02s$，解得n，那么分频系数设置为<strong>n-1</strong>即可。</p><p>​    为什么要减去一呢？因为不分频其实也就是<strong>一分频</strong>，但是默认<code>prescale value == 0</code>时是不分频。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Write写数据"><a href="#Write写数据" class="headerlink" title="Write写数据"></a>Write写数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_write1</span><span class="params">(u8 adr,u8 data)</span></span><br><span class="line">&#123; </span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(adr);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(data);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/02/zMwCgD3Qt1vx5cy.png" alt="IIC_3.png"></p><p>这里贴上之前的流程图方便比对。</p><h3 id="Read读数据"><a href="#Read读数据" class="headerlink" title="Read读数据"></a>Read读数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">pca_read1</span><span class="params">(u8 adr)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 data;</span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(adr);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1|<span class="number">0x01</span>);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">data=IIC_Read_Byte(<span class="number">0</span>);</span><br><span class="line">IIC_Stop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/02/hQueywRLE3xf4v5.png" alt="IIC_4.png"></p><h3 id="设置分频系数"><a href="#设置分频系数" class="headerlink" title="设置分频系数"></a>设置分频系数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_setfreq1</span><span class="params">(<span class="type">float</span> freq)</span> </span><br><span class="line">&#123;</span><br><span class="line">u8 prescale,oldmode,newmode;</span><br><span class="line"><span class="type">double</span> prescaleval;</span><br><span class="line">freq *= <span class="number">0.92</span>; </span><br><span class="line">prescaleval = <span class="number">25000000</span>;</span><br><span class="line">prescaleval /= <span class="number">4096</span>;</span><br><span class="line">prescaleval /= freq;</span><br><span class="line">prescaleval -= <span class="number">1</span>;</span><br><span class="line">prescale =<span class="built_in">floor</span>(prescaleval + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">oldmode = pca_read1(pca_mode1); <span class="comment">//获取之前mode寄存器配置状态</span></span><br><span class="line"></span><br><span class="line">newmode = (oldmode&amp;<span class="number">0x7F</span>) | <span class="number">0x10</span>; <span class="comment">// 睡眠模式</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, newmode); <span class="comment">// 进入睡眠</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_pre, prescale); <span class="comment">// 设置分频系数</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, oldmode); <span class="comment">//写回原来</span></span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, oldmode | <span class="number">0xa1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意手册里也多次强调，<span class='p red'>只有在设备进入睡眠模式之后才能修改分频系数</span></p><p>这里需要了解一下<strong>MODE1</strong>寄存器里的<emp>RESTART</emp>位</p><div class="note info modern"><p>在<strong>不停止PWM通道输出</strong>的情况下将设备设置为sleep模式，<strong>RESTART</strong>位会在一个PWM周期后被置1，<strong>LED</strong>寄存器里面的数据会被保存。想要重启，向<strong>RESTART</strong>位写1即可，此时该位会被自动<strong>置0</strong>。</p></div><p>​    当然，在这段代码中还设置了<strong>ALLCALL、AL</strong>位。</p><h3 id="调制PWM占空比"><a href="#调制PWM占空比" class="headerlink" title="调制PWM占空比"></a>调制PWM占空比</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_setpwm1</span><span class="params">(u8 num, u32 on, u32 off)</span> </span><br><span class="line">&#123;</span><br><span class="line">pca_write1(LED0_ON_L+<span class="number">4</span>*num,on);</span><br><span class="line">pca_write1(LED0_ON_H+<span class="number">4</span>*num,on&gt;&gt;<span class="number">8</span>);</span><br><span class="line">pca_write1(LED0_OFF_L+<span class="number">4</span>*num,off);</span><br><span class="line">pca_write1(LED0_OFF_H+<span class="number">4</span>*num,off&gt;&gt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个“LED”有四个寄存器，所以<strong>第n个</strong>led地址为<strong>LED0</strong>地址加<strong>4n</strong>。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>感谢大家耐心看完了本篇博客，欢迎大家分享；完整的工程可以在我的<strong>GiHub</strong>仓库找到。由于本人水平有限，可能有不完善之处，欢迎大家批评指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> IIC </tag>
            
            <tag> 舵机 </tag>
            
            <tag> PCA9685 </tag>
            
            <tag> 通讯协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的位运算</title>
      <link href="/2022/10/29/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/10/29/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="有意思的操作"><a href="#有意思的操作" class="headerlink" title="有意思的操作"></a>有意思的操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>位运算是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。常用的位运算符号包括：“∧” 按位异或（取不同）、“&amp;” 按位与（取交）、“|” 按位或（取并）、“~” 取反、“&lt;&lt;” 算术左移和 “&gt;&gt;” 算术右移。</p><ul><li>n &amp; (n - 1) 可以去除 n 的位级表示中最低的那一位，例如对于二进制表示 11110100 ，减去 1 得到 11110011，这两个数按位与得到 11110000。</li><li>n &amp; (-n) 可以得到 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100。</li></ul><h2 id="获取二进制数中1的个数"><a href="#获取二进制数中1的个数" class="headerlink" title="获取二进制数中1的个数"></a>获取二进制数中1的个数</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_contains</span><span class="params">(u32 s,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(((s&gt;&gt;i) &amp; <span class="number">0x01</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_size0</span><span class="params">(u32 s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n += <span class="built_in">bitset_contains</span>(s,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>int bitset_contains(u32 s,int i)</code>就是判断s的<strong>第i位</strong>（从<strong>第0位</strong>开始计起）是否为1。</p><p><code>int bitset_size0(u32 s)</code>就是一位位看是不是1，是就<strong>计数加一</strong>。</p><p>最后效果就是<strong>统计s为1的位数</strong></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_size</span><span class="params">(u32 s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = (s &amp; <span class="number">0x55555555</span>) + ((s&gt;&gt;<span class="number">1</span>) &amp; <span class="number">0x55555555</span>); <span class="comment">//01010101010101010101010101010101</span></span><br><span class="line">    s = (s &amp; <span class="number">0x33333333</span>) + ((s&gt;&gt;<span class="number">2</span>) &amp; <span class="number">0x33333333</span>); <span class="comment">//00110011001100110011001100110011</span></span><br><span class="line">    s = (s &amp; <span class="number">0x0f0f0f0f</span>) + ((s&gt;&gt;<span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>); <span class="comment">//00001111000011110000111100001111</span></span><br><span class="line">    s = (s &amp; <span class="number">0x00ff00ff</span>) + ((s&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>); <span class="comment">//00000000111111110000000011111111</span></span><br><span class="line">    s = (s &amp; <span class="number">0x0000ffff</span>) + ((s&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);<span class="comment">//00000000000000001111111111111111</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    一般来说，看到这样的<strong>十六进制</strong>数就会不由自主地想把它们转换为<strong>二进制</strong>看看。转换之后呢就能稍微看出一些端倪了。😁</p><p>​    <code>0x55555555</code>将s分为<strong>两个一组</strong>，每一组两位数。其实就是==分别判断一组里的两位数是不是1==。</p><ul><li>都是1，则变为<strong>1+1=10</strong>；</li><li>只有一个，就变为<strong>01</strong>；</li><li>没有则为<strong>0</strong></li></ul><p>​    变换完了之后呢，储存的就是这一组里 <em>“1”</em> 的个数。</p><p>​    <code>0x33333333</code>则是将s分为<strong>四个一组</strong>，一组里同样是<strong>两个数</strong>，只不过一个数是<strong>两位</strong>。操作的结果呢就是<strong>将两个数各自两个位里1的个数</strong>加起来，即<strong>四个位里1的个数</strong>。</p><p>​    <code>0x0f0f0f0f</code>将s分为<strong>八个一组</strong>，统计<strong>八个位里1的个数</strong></p><p>​    <code>0x00ff00ff</code>将s分为<strong>十六个一组</strong>，统计<strong>十六位里1的个数</strong></p><p>​    <code>0x0000ffff</code>将整个32位的s看作一组，统计<strong>所有1的个数</strong></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>​    两种方法比较来看，明显是第一种方法简单易懂，也容易想到；但是从运算效率上来看，第二种远远高于第一种。</p><h1 id="遥控数据解析"><a href="#遥控数据解析" class="headerlink" title="遥控数据解析"></a>遥控数据解析</h1><p><img src="https://s2.loli.net/2022/10/29/7vaHiBuG1CXbV9m.png" alt="遥控协议.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RemoteReceive</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint8_t</span> *<span class="type">const</span> ptr_sbus_rx_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr_sbus_rx_buffer == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    RC_Ctl.rc.ch0 = (ptr_sbus_rx_buffer[<span class="number">0</span>] | (ptr_sbus_rx_buffer[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>)) &amp;<span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch1 = (ptr_sbus_rx_buffer[<span class="number">1</span>] &gt;&gt; <span class="number">3</span>) | (ptr_sbus_rx_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">5</span>) &amp; <span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch2 = (ptr_sbus_rx_buffer[<span class="number">2</span>] &gt;&gt; <span class="number">6</span>) | (ptr_sbus_rx_buffer[<span class="number">3</span>] &lt;&lt; <span class="number">2</span>) | (ptr_sbus_rx_buffer[<span class="number">4</span>] &lt;&lt; <span class="number">10</span>) &amp; <span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch3 = (ptr_sbus_rx_buffer[<span class="number">4</span>] &gt;&gt; <span class="number">1</span>) | (ptr_sbus_rx_buffer[<span class="number">5</span>] &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x07ff</span>; </span><br><span class="line">    RC_Ctl.rc.s1 = (ptr_sbus_rx_buffer[<span class="number">5</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x0003</span>;</span><br><span class="line">    RC_Ctl.rc.s2 = (ptr_sbus_rx_buffer[<span class="number">5</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0003</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括来说就是依照<strong>通信协议</strong>利用<strong>位移运算</strong>和<strong>或、与运算</strong>，将数据从<strong>ptr_sbus_rx_buffer</strong>剥离提取至<strong>RC_Ctl.rc.xx</strong>中。</p><ul><li>位移操作后，需要提取的数据在<strong>后11位(或后2位)</strong>，<strong>0x07ff</strong>换成二进制就是<strong>0000011111111111</strong>，过滤掉不需要的位数；<strong>0x0003</strong>同理</li><li><strong>ch0</strong>获取buffer[0]<strong>全部八位</strong>和buffer[1]<strong>低三位</strong></li><li><strong>ch1</strong>获取buffer[1]<strong>高五位</strong>和buffer[2]<strong>低六位</strong></li><li><strong>ch2</strong>获取buffer[2]<strong>高两位</strong>和buffer[3]<strong>全部八位</strong>和buffer[4]<strong>低一位</strong></li><li><strong>ch3</strong>获取buffer[4]<strong>高七位</strong>和buffer[5]<strong>低四位</strong></li><li><strong>s1</strong>获取buffer[5]<strong>高两位</strong></li><li><strong>s2</strong>获取buffer[5]<strong>第五第六位</strong></li></ul><p>不知道是不是搞反了，根据协议来看是<strong>s1</strong>获取buffer[5]<strong>第五第六位</strong>，<strong>s2</strong>获取buffer[5]<strong>高两位</strong></p><h1 id="位运算实现四则运算"><a href="#位运算实现四则运算" class="headerlink" title="位运算实现四则运算"></a>位运算实现四则运算</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    在平时手算的时候我们经常会<strong>列竖式</strong>，先不考虑进位，只看<strong>和</strong>和<strong>相加的两个数</strong>同位的数，把进位数写小一点记在横线上方。<strong>计算下一位的时候再加上上一位的进位。</strong></p><p>​    所以在程序中也是模拟这样一个思路：</p><ul><li>先不看进位，得到一个和；记下进位</li><li>进位在与和相加，不看进位得到一个新的和；同时也得到新的进位</li><li>不断迭代递推，直到不再产生新的进位</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加法函数</span></span><br><span class="line"><span class="comment"> * @param ini_x 加数1</span></span><br><span class="line"><span class="comment"> * @param ini_y 加数2</span></span><br><span class="line"><span class="comment"> * @return 补码形式的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">u32 <span class="title">addition</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不需要转换为补码</span></span><br><span class="line">    u32 x = ini_x, y = ini_y;</span><br><span class="line">    <span class="comment">//和，进位</span></span><br><span class="line">    u32 ans,carry;</span><br><span class="line">    ans = x ^ y;</span><br><span class="line">    carry = (x &amp; y) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//不断获取进位与不考虑进位的和，迭代相加，直至进位为0</span></span><br><span class="line">    <span class="keyword">while</span>(carry != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        u32 i = ans, j = carry;</span><br><span class="line">        ans = i ^ j;</span><br><span class="line">        carry = (i &amp; j) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DEBUG调试</span></span><br><span class="line">    <span class="comment">//printf(&quot;DE<span class="doctag">BUG:</span> %d add %d = %d\r\n&quot;,ini_x,ini_y,ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以发现，</p><ul><li>不看进位得到的和其实就是<strong>两数异或</strong>，即<code>ans = x ^ y;</code>；</li><li>进位即<strong>两数相与再左移一位</strong>，即<code>carry = (x &amp; y) &lt;&lt; 1;</code></li></ul><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>​    <strong>a-b</strong> 即 <strong>a+(-b)</strong></p><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    可以将被乘数不断加<strong>乘数次数</strong>的自己。但是这样效率不高。同样是模拟手算的思想，从<strong>乘数的最低位</strong>到<strong>最高位</strong>，在<strong>第i位</strong>，即给最后乘积贡献的值为</p><p>==被乘数 <em> 乘数[i] </em> (进制数)^(i-1)^==</p><p>​    在这个算法下不再能直接用补码参与计算，所以要换成原码并去除符号位。在开始的时候根据两数记下乘积的正负值，计算完毕之后再赋回去。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 乘法</span></span><br><span class="line"><span class="comment"> * @param ini_x </span></span><br><span class="line"><span class="comment"> * @param ini_y </span></span><br><span class="line"><span class="comment"> * @return u32 积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">u32 <span class="title">multiplication</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> negative_flag=<span class="number">0</span>;</span><br><span class="line">    u32 ans=<span class="number">0</span>, x=ini_x, y=ini_y;</span><br><span class="line">    <span class="comment">//判断积正负</span></span><br><span class="line">    <span class="keyword">if</span>( ( (x&amp;<span class="number">0x80000000</span>) &amp;&amp; !(y&amp;<span class="number">0x80000000</span>) )||( !(x&amp;<span class="number">0x80000000</span>) &amp;&amp; (y&amp;<span class="number">0x80000000</span>) ) ) &#123;negative_flag=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">//要转换为原码并去掉符号位</span></span><br><span class="line">    x = <span class="built_in">back_com</span>(x);</span><br><span class="line">    y = <span class="built_in">back_com</span>(y);</span><br><span class="line">    x &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    y &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="comment">//借鉴竖乘法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">31</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">0x01</span>) &#123;ans = <span class="built_in">addition</span>(ans,x);&#125;</span><br><span class="line">        y = y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        x = x&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span>) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加上正负号</span></span><br><span class="line">    <span class="keyword">if</span> (negative_flag) </span><br><span class="line">    &#123;</span><br><span class="line">        ans |= <span class="number">0x80000000</span>;<span class="comment">//这个时候依然是原码，想直接用%d，要转换为补码</span></span><br><span class="line">        ans = <span class="built_in">get_com</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DEBUG调试</span></span><br><span class="line">    <span class="comment">//printf(&quot;DE<span class="doctag">BUG:</span> %d multiply %d = %d\r\n&quot;,ini_x,ini_y,ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>​    因为除法有<strong>商</strong>和<strong>余数</strong>，所以用了一个结构体方便存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 除法答案结构体</span></span><br><span class="line"><span class="comment"> * @param ans 商</span></span><br><span class="line"><span class="comment"> * @param mod 余数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__ans_division_t</span>&#123;</span><br><span class="line">    u32 ans;</span><br><span class="line">    u32 mod;</span><br><span class="line">&#125;<span class="type">ans_division_t</span>;</span><br></pre></td></tr></table></figure><h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    也是模拟手算流程，在理解了乘法的实现思路后便很容易理解。</p><ul><li>将被除数不断<strong>进位</strong>，即乘上<strong>进制数</strong>，直到恰好比被除数小。</li><li>用被除数除以<strong>进位后的除数</strong>得到<strong>商</strong>（为了区别最终的商把它叫做<em>小商</em>吧），同时<strong>商</strong>加上==小商*进制数^(进位次数)^==</li><li>被除数不断<strong>退位</strong>（除以进制数），同时重复上述操作，直到回到最初大小，即<strong>进位数为0</strong></li></ul><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 除法</span></span><br><span class="line"><span class="comment"> * @param ini_x 被除数</span></span><br><span class="line"><span class="comment"> * @param ini_y 除数</span></span><br><span class="line"><span class="comment"> * @return ans_division_t* 答案指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ans_division_t</span> *<span class="title">division</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> negative_flag=<span class="number">0</span>;</span><br><span class="line">    u32 ans=<span class="number">0</span>, carry=<span class="number">0</span>, x=ini_x, y=ini_y;</span><br><span class="line">    <span class="type">ans_division_t</span> *ans_division;</span><br><span class="line">    ans_division = (<span class="type">ans_division_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">ans_division_t</span>));</span><br><span class="line">    <span class="keyword">if</span>( ( (x&amp;<span class="number">0x80000000</span>) &amp;&amp; !(y&amp;<span class="number">0x80000000</span>) )||( !(x&amp;<span class="number">0x80000000</span>) &amp;&amp; (y&amp;<span class="number">0x80000000</span>) ) ) &#123;negative_flag=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">//要转换为原码并去掉符号位</span></span><br><span class="line">    x = <span class="built_in">back_com</span>(x);</span><br><span class="line">    y = <span class="built_in">back_com</span>(y);</span><br><span class="line">    x &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    y &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="comment">//依然是模拟手除流程</span></span><br><span class="line">    <span class="comment">//除数不断进位直至比被除数大</span></span><br><span class="line">    <span class="keyword">while</span>(y &lt; x) </span><br><span class="line">    &#123;</span><br><span class="line">        y = y&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        carry = <span class="built_in">addition</span>(carry,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果能除，商就加上1&lt;&lt;carry，除数再不断右移直至回到本来大小。</span></span><br><span class="line">    <span class="keyword">while</span>(carry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=y)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">addition</span>(ans,<span class="number">1</span>&lt;&lt;carry);</span><br><span class="line">            x = <span class="built_in">addition</span>(x,-y);</span><br><span class="line">        &#125;</span><br><span class="line">        y = y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        carry = <span class="built_in">addition</span>(carry,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=y) </span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">addition</span>(ans,<span class="number">1</span>);</span><br><span class="line">        x = <span class="built_in">addition</span>(x,-y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    ans_division-&gt;ans = ans;</span><br><span class="line">    ans_division-&gt;mod = x;</span><br><span class="line">    <span class="keyword">return</span> ans_division;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    因为负数的余数比较奇怪，平时也不用，这里没有考虑在内。</p><h2 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h2><p>​    vscode 程序文件不能用中文命名。</p><p>​    在程序运行的时候使用补码记录。即便是<strong>usigned int</strong>，倘若<strong>scanf -9</strong>，对应二进制编码也是<strong>11111111111111111111111111110111</strong>。<strong>int</strong>型同样如此。</p><p>​    所以在运算的时候不需要人为的去转换为补码了，在这方面耽误了不少时间。</p><p>​    而对于同样的一串二进制编码，<strong>printf(“%d”)</strong>和<strong>printf(“%u”)</strong>输出结果是不一样的：%d会自动转换输出原码对应的有符号数；那%u则是会将这个补码当作原码直接换算成十进制输出。</p><p><img src="https://s2.loli.net/2022/10/29/PICY3lTj1Q4OKGS.png" alt="存储形式·1.png"></p><p><img src="https://s2.loli.net/2022/10/29/2SIuUTAJV9tDnqR.png" alt="存储形式2.png"></p><p>​    其余的就是一些逻辑漏洞了，不得不说VScode写代码还是比Keil舒服😁</p><h1 id="有关位运算的一些有意思的题目"><a href="#有关位运算的一些有意思的题目" class="headerlink" title="有关位运算的一些有意思的题目"></a>有关位运算的一些有意思的题目</h1><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗</p><p>示例 1:</p><blockquote><p>输入: [2,2,1]<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: [4,1,2,1,2]<br>输出: 4</p></blockquote></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>需要用到异或运算的性质：</p><p>a \^ a = 0<br>a \^ 0 = a<br>a \^ b \^ a = b \^ (a \^ a) = b（交换律和结合律）<br>所以只要全部异或最后结果就是答案</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num: nums)</span><br><span class="line">        ans ^= num;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h2><blockquote><p>给定一个非负整数 n，求从 0 到 n 的所有数字的二进制表达中，分别有多少个 1。</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题可以利用动态规划和位运算进行快速的求解。定义一个数组 dp，其中 dp [i] 表示数字 i 的二进制含有 1 的个数。对于第 i 个数字，如果它二进制的最后一位为 1，那么它含有 1 的个数 则为 dp [i-1] + 1；如果它二进制的最后一位为 0，那么它含有 1 的个数和其算术右移结果相同，即 dp [i&gt;&gt;1]。</p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(num+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        dp[i] = i &amp; <span class="number">1</span>? dp[i<span class="number">-1</span>] + <span class="number">1</span>: dp[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 等价于dp[i] = dp[i&amp;(i-1)] + 1;</span></span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> leecode </tag>
            
            <tag> 四则运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32仿真器程序烧录</title>
      <link href="/2022/10/22/STM32%E4%BB%BF%E7%9C%9F%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95/"/>
      <url>/2022/10/22/STM32%E4%BB%BF%E7%9C%9F%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>​    这几天捯饬了一下烧录程序的方法。主要还是<strong>SWD</strong>烧录，后续应该会尝试其他方法。我最开始的时候就不太会弄，即便手边有个仿真器也没有去用（后来就丢了😂），一直用的是<strong>ISP</strong>下载，不仅效率低，还不能在线调试。所以就整理了一下烧录方法。</p><span id="more"></span><h1 id="STM32仿真器程序烧录"><a href="#STM32仿真器程序烧录" class="headerlink" title="STM32仿真器程序烧录"></a>STM32仿真器程序烧录</h1><h3 id="SWD烧录"><a href="#SWD烧录" class="headerlink" title="SWD烧录"></a>SWD烧录</h3><p>SWD烧录是一种串行调试接口，出去供电与共地只需要两根线即可烧录调试</p><ul><li><strong>SWDIO：</strong> 串行数据线，用于数据的读出和写入;</li><li><strong>SWDCLK：</strong> 串行时钟线，提供所需要的时钟信号;</li></ul><p>下面是官方手册里烧录接口的引脚到GPIO口的映射关系</p><p><img src="https://s2.loli.net/2022/10/22/yxIoZNYtkJiqcvs.png" alt="映射关系.png"></p><p>这个是标准的接口排列，要注意的是按照插座边上的<strong>缺口向左</strong>的方向来查看。</p><p><img src="https://s2.loli.net/2022/10/22/NxQRpn7YiqlcZ9j.png" alt="swd_jtag插座.png"></p><p>一般情况下大多数单片机的 JTAG 接口和 SWDIO 接口是复用的，下面就是MINI板的原理图</p><p><img src="https://s2.loli.net/2022/10/22/hPSMBDUczKI6gOZ.png" alt="MINIswd插座.png"></p><h4 id="J-link"><a href="#J-link" class="headerlink" title="J-link"></a>J-link</h4><p>这个是比较常见也比较便宜的一款J-link，只有<strong>3.3vVCC、SWDIO、SWCLK、GND</strong>四根线，接线方式也十分的简单 。</p><p><img src="https://s2.loli.net/2022/10/22/jM2wkymvznOZtS9.jpg" alt="廉价j-link.jpg" style="zoom:50%;" /></p><p>像<strong>STM32C8T6、openCRP</strong>等等已经给出这四个接口的板子直接接上就好了</p><p><img src="https://s2.loli.net/2022/10/22/RGTbYQp9D8sUexm.jpg" alt="swd接口.jpg"></p><p>如果是20脚标准接口的话对照上面的图片找到对应的引脚直接接上即可。</p><p><img src="https://s2.loli.net/2022/10/22/EMTGCtwVFrAia9I.jpg" alt="廉价j-link接线.jpg"></p><p>​    如果实在找不到接口呢，直接把<strong>SWDIO、SWCLK</strong>接在<strong>PA13、PA14</strong>，再供电共地也是一样可以正常烧录的。    </p><p>​    经过测试呢，可以正常烧录，但是会<strong>供电不足</strong>。其中<strong>C8T6和openCRP</strong>的<strong>5V</strong>引脚电压不够，不过程序倒是可以正常运行；而<strong>MINI</strong>则是程序无法正常运行。这个具体情况还与各个板子的PCB设计有关。一般保险起见的话，需要<strong>额外供电</strong>。</p><h4 id="ST-link"><a href="#ST-link" class="headerlink" title="ST-link"></a>ST-link</h4><p>这也是很常见的一款ST-link</p><p><img src="https://s2.loli.net/2022/10/22/wQTMaopVhKlZq7g.jpg" alt="ST-link.jpg"></p><p>​    如果能直接用20脚的接口就很方便。不行的话也可以直接对照前面的图片把<strong>SWD</strong>对应的四根线接出来。</p><p>​    和板子的接线方法与之前都是一样的。</p><h4 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h4><p>这里用的是<strong>MDK5</strong>或者叫<strong>Keil</strong></p><ol><li>首先是点开<strong>魔术棒</strong>，选择对应的调试器<img src="https://s2.loli.net/2022/10/22/9botRpUDXFnAEqs.png" alt="config.png"></li><li>然后进入<strong>settings</strong>选择烧录方式和烧录速度<img src="https://s2.loli.net/2022/10/22/mxFHa8b52YNCoiJ.jpg" alt="config2.jpg"></li><li>然后可以检查一下烧录算法和自己的芯片型号是不是对应的。<img src="https://s2.loli.net/2022/10/22/1xEaqv8ANcwoJsX.jpg" alt="config3.jpg"></li><li>最后点击<strong>load</strong>按钮就可以烧录了。</li></ol><h3 id="ISP烧录"><a href="#ISP烧录" class="headerlink" title="ISP烧录"></a>ISP烧录</h3>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS串口通讯</title>
      <link href="/2022/08/29/ROS-USART-STM32/"/>
      <url>/2022/08/29/ROS-USART-STM32/</url>
      
        <content type="html"><![CDATA[<p>​    简单记录了尝试使用ROS与STM32通讯的过程，包括踩的一点坑，其中一些低级问题实在是有点让人哭笑不得😂</p><span id="more"></span><h1 id="ROS串口通讯"><a href="#ROS串口通讯" class="headerlink" title="ROS串口通讯"></a>ROS串口通讯</h1><h2 id="ROS串口通讯配置"><a href="#ROS串口通讯配置" class="headerlink" title="ROS串口通讯配置"></a>ROS串口通讯配置</h2><h3 id="Ubuntu20-04手动获取Serial包"><a href="#Ubuntu20-04手动获取Serial包" class="headerlink" title="Ubuntu20.04手动获取Serial包"></a>Ubuntu20.04手动获取Serial包</h3><h3 id="linux-ros-串口权限获取"><a href="#linux-ros-串口权限获取" class="headerlink" title="linux/ros 串口权限获取"></a>linux/ros 串口权限获取</h3><p>转载自<a href="https://blog.csdn.net/qq_16775293/article/details/82822851?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-0-82822851-blog-55259778.wap_relevant_multi_platform_whitelistv1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1">(9条消息) Linux/ROS——获取串口权限_不懂音乐的欣赏者的博客-CSDN博客</a></p><p>我这里的串口号是<strong>/dev/ttyTHS1</strong>，需要适当变动</p><h4 id="永久解决串口权限问题"><a href="#永久解决串口权限问题" class="headerlink" title="永久解决串口权限问题"></a>永久解决串口权限问题</h4><p>（我试了一下，但是失败了）</p><p>创建ttyUSB权限规则文件etc/udev/rules.d/70-ttyUSB.rules</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim -p /etc/udev/rules.d/70-ttyUSB.rules</span><br></pre></td></tr></table></figure><p>在<strong>70-ttyUSB.rules</strong>文件中写入下列代码</p><p>KERNEL==”ttyUSB*”, OWNER=”root”, GROUP=”root”, MODE=”0666”<br>保存即可,重启或注销用户在登录后生效</p><h4 id="临时获取串口权限"><a href="#临时获取串口权限" class="headerlink" title="临时获取串口权限"></a>临时获取串口权限</h4><p>先查看插入电脑的<strong>串口号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/ | grep ttyUSB</span><br></pre></td></tr></table></figure><p>知道串口号之后对指定串口赋予权限,以<strong>ttyUSB0</strong>为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+rw /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>不用重启即可生效</p><h3 id="代码编写问题"><a href="#代码编写问题" class="headerlink" title="代码编写问题"></a>代码编写问题</h3><h2 id="Jetson-nano与STM32通讯"><a href="#Jetson-nano与STM32通讯" class="headerlink" title="Jetson nano与STM32通讯"></a>Jetson nano与STM32通讯</h2><h3 id="jetson-nano串口"><a href="#jetson-nano串口" class="headerlink" title="jetson nano串口"></a>jetson nano串口</h3><p>引脚图，直接连即可。</p><p><img src="https://s2.loli.net/2022/10/22/x8melhw2bcjAgqV.jpg" alt="nano_usart.jpg"></p><h3 id="ROS与32串口通讯（ROS端）只能接收不能发送"><a href="#ROS与32串口通讯（ROS端）只能接收不能发送" class="headerlink" title="ROS与32串口通讯（ROS端）只能接收不能发送"></a>ROS与32串口通讯（ROS端）只能接收不能发送</h3><p>​    被这个问题卡了很久。根据情况描述，既然都能正常接收了为什么发送会失败呢？</p><h4 id="ROS端"><a href="#ROS端" class="headerlink" title="ROS端"></a>ROS端</h4><p>​    在ROS端串口输出一个字符串所用到的函数是<strong>ser.write（string value）</strong>，在定时器的回调函数里面同时调用。首先就是检查定时器回调函数是否被成功调用，读取数据和发送数据都是在这个回调函数里调用的，那么基本上是没问题的，<strong>ROS_INFO</strong>一下确实没问题。同理<strong>SendMsgs( )</strong>一样成功调用了。那至少能肯定，<strong>write( )</strong>函数肯定被调用了呀。</p><p>​    中间还出了一点岔子，就是代码中不小心打上了一点乱码，结果编译出问题。但是编译日志也没有报错，我虽然看着和原来的不一样，但是没有太在意。但是这就导致了之前改完代码后好几次编译都是不通过的，一直运行的也是那个有问题的节点代码。所以如果编译日志同平时比较为反常，要当心一下。</p><p>​    接下来将<strong>nano</strong>的<strong>TX，RX</strong>短接，判断到底是不是nano端的问题。发现确实能自己接收到自己的消息，那就没问题了</p><p>​    nano端没问题了，估计就是32端的问题了。ros只能接受不能发送，是不是<strong>rx</strong>接对了但<strong>tx</strong>接错了呢？</p><blockquote><p>nano 8：TX——RX：stm32 PA10</p><p>nano 10: RX——TX：stm32 PA9</p></blockquote><p>再检验一遍着实无误。</p><h4 id="32端"><a href="#32端" class="headerlink" title="32端"></a>32端</h4><p>​    32端没有再配置一个串口，使用<strong>oled屏</strong>DEBUG，nano端使用cutecom通讯正常，32能接收到消息，换成ros发消息后32却是一点反应都没有，那这个时候就想到看看<strong>串口中断函数</strong>到底有没有被调用，32到底有没有接收到消息。我在该函数里面加了些语句：如果串口中断函数被调用的话oled就会显示。</p><p>​    那结果是没有反应。</p><p>​    实际上控制oled显示的时候输完内容，要加个<strong>refresh</strong>。同时<strong>while( )</strong>里在不断<strong>Set_Z( )</strong>,里面也会不断更新内容然后refresh，所以其实串口中断是被调用了的，但在这样的情况下看不到反应。最后是使用keil的<strong>在线调试功能</strong>设置<strong>断点</strong>发现的，其实调用了。这个时候再看一下函数关于接收到的消息的过滤，其实正点原子也说过——<strong>发送新行</strong>。cutecom会，但ros不会。最终在要发送的字符串后面加上<strong>\r\n</strong>，DEBUG结束。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul><li>函数调用因oled错误使用检查失败。</li><li>不会使用Jlink在线调试</li><li>忽视了ros和cutecom细节上的输出差异。</li></ul><p>如果这三点有一点不出问题的话，或许都能够早些找到，错误。在此非常感谢师兄的指点！</p><h2 id="LattePanda与其Arduino通讯"><a href="#LattePanda与其Arduino通讯" class="headerlink" title="LattePanda与其Arduino通讯"></a>LattePanda与其Arduino通讯</h2><p>本来打算使用stm32进行下游设备的控制，但是发现LattePanda集成了一块<strong>arduino</strong>，不好好利用一下实在是太可惜了。</p><h3 id="Arduino-IDE安装"><a href="#Arduino-IDE安装" class="headerlink" title="Arduino IDE安装"></a>Arduino IDE安装</h3><p>​    在官网<a href="https://www.arduino.cc/en/software">Software | Arduino</a>下载Linux版本的安装包。可是下载<strong>2.0.0</strong>版本的会显示<em>没有可执行的软件</em>，所以最后选择了<strong>1.8.19</strong>。lattepanda对应的版本是<strong>linux 64 bits</strong></p><p>在安装目录得到了<strong>.tar.xz</strong>文件，运行解压命令</p><p><code>tar -xvf arduino-1.8.19-linux64.tar.xz</code></p><p>进入解压得到的安装目录，运行安装脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd arduino-1.8.19/</span><br><span class="line">sudo ./install.sh</span><br></pre></td></tr></table></figure><p>看到返回 <em>done!</em> 后安装成功</p><h3 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h3><p>​    平时用电脑给arduino烧录程序需要用一根数据线将二者连接起来。那在lattepanda上就相当于把这个数据线在板子上画好了，再把电脑和arduino粘一块儿</p><p>​    这个数据线对应的串口号是<strong>/dev/ttyACM0</strong>；</p><p>​    对应的芯片型号是<strong>ATmega32u4</strong>，这在IDE里面找不到，实际上也叫<strong>Arduino Leonardo</strong></p><p>​    之后就可以烧程序和通讯了。</p><h3 id="移植ROS包时遇到的一点小问题"><a href="#移植ROS包时遇到的一点小问题" class="headerlink" title="移植ROS包时遇到的一点小问题"></a>移植ROS包时遇到的一点小问题</h3>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> USART </tag>
            
            <tag> ROS </tag>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/16/hello-world/"/>
      <url>/2022/08/16/hello-world/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0858d2d5afc6e71fe61fde17e264b0ebd81b693504324bd451d5b9fe60576581">fa8b13601bdfbf35c816c536e1c943768052b894c07bef87cfe638eadf1a44fb1aca374ccee2eb92dae6b7862d437c4511b8689b401f36543ccb6ab66f72bf0286c6c052ef4e8c7a2ec491afed06f89a2c56b4c8675715f28bfe32cab7840fb26ae21f1cfad9201fc4ca976f5aa9b30b29f1d26800d88d671ada94dcd875d8b3edda1090b2911a1d9b0f465c5e9f8328c5cd48549be6f19403414d9688c6d62003ad856535e633eae2402819f2e0fc0bdf8686ed677e35bdac33f324558f92229db3f692da7bbac0d4cc6fe244237d3881e12c8f3413ef4e51a472e769d89c70bc4a1ae26a03a319d5b01811e30f63ee79c12b32110cdd2101b75c6de84c17f3be550357902045bf9f10615e4aa9f55c8e71d966ce60f9fed9ad627e1df8514777352c0054f33ed102972e4ca63e300ef09e350027436e85314696b7144fe22e8d4b9320a5ce45aca7f544bcbc99e60530d266d9835f87a6a0a07336f75ef08cbadda7e5b4d92dddf83aaaa1a2db7037efdfa3794b1b40d607fee759f6446124297bf0b0c1433f8089cf9f6bc53d63df6a398686aa826d1d784a5fe38e2b7abed2152e574dbd2a77b8f9bb28c18d34ee1915d33fd7092d81ef13ff30ae5ae174f042c7e083e83964e19562840a378af0c06d5ad47b8a740819d946e83b76d9e47e3b976708c03d087cb82be880643e23d138db94b4a4e7d64d0c03e5433d0dc7a95ccf86b3d1c11381f28a78d145297c943ae497edf7127d4a67bbaae900cd1f4b7237f62636f0080b07800702fd6023bb364450f4213fcbb06015f72d601d721e0fa5f9c65feefbddc6986cf86149c7018c45458bb7d201e63e3d475e9ee2c9643f0e36d3ba5b280f9d915ad8b88a5461af0a4e3a964d3fa4120340b848e62dd1682f6064e325d4abfef05e5b588920474cf8bf5da166c9d2f26a3177670d695aeba543ff6d4970a1cff53bb98490c6e1d7bf50eeb810306cd1919e2766e26ee66828b12168bc41b6fd3c6adb22cac57352a6b18a6dc68cca53ef0749db2b13480543a929b5e1a1439f22b7fe7b367c7088e3a6b9b3fbed26b1590eb01b493c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">举杯邀明月，对影成三人。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
