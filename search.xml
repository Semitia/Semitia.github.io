<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello,esp32!</title>
      <link href="/2023/01/03/Hello-ESP32/"/>
      <url>/2023/01/03/Hello-ESP32/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello，-esp32！"><a href="#Hello，-esp32！" class="headerlink" title="Hello， esp32！"></a>Hello， esp32！</h1><p>​    今天终于在windows上配置好了esp32的开发环境，感谢这个up主提供的方式。</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://www.bilibili.com/video/BV1QF411u72A/?spm_id_from=333.880.my_history.page.click&amp;vd_source=0f383e93e945bca07eaef9a9ee5d9db3">乐鑫ESP32官方开发环境 Espressif IDE 一键安装教程-无需插件和手动配置_哔哩哔哩_bilibili</a></p></div><p>​    我之前也试过其他的开发方式，platformIO开发呢局限性比较大，VScode上的ESpressif IDF呢一直下载失败，最后也没折腾出来。在这里总结一下这个配置方式，结合自己遇到的一些小问题。</p><h2 id="IDE安装"><a href="#IDE安装" class="headerlink" title="IDE安装"></a>IDE安装</h2><p>可以在乐鑫官方的Github下载，也可以在视频里的百度网盘下载。安装过程非常惬意，但还是有一点注意事项。</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/espressif/idf-installer#espressif-ide-offline-installer">espressif/idf-installer: ESP IDF Windows Installer (github.com)</a></p></div><p><img src="https://s2.loli.net/2023/01/04/8qiAbfNxI27vupz.png" alt="IDE.png"></p><h2 id="连接-amp-烧录"><a href="#连接-amp-烧录" class="headerlink" title="连接 &amp; 烧录"></a>连接 &amp; 烧录</h2><p>​    我这个板子直接用microUSB连接至电脑。但是数据线也要用稍微靠谱的，我一开始用的俩数据线不太行，插上去板子能取电，但是电脑识别不到串口。如果不是驱动的问题，估计就是线的问题。换了个线之后就好了。我这里是 <strong>com9</strong></p><p><img src="https://s2.loli.net/2023/01/04/PzNvTuql8oGcIB6.png" alt="esp串口.png" style="zoom:200%;" /></p><p>​    烧录的时候有一个小问题，就是connect不上板子，这个在之前用PlatformIO的时候也有类似的情况，只要按住 <strong>boot</strong> 键烧录就好了。</p><p><img src="https://s2.loli.net/2023/01/04/Cw9gNGEkP7l3piY.png" alt="connecting.png"></p><h2 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h2><p>​    打开终端，就可以看到板子发送的消息了。串口的波特率没有在代码里看到，但是实测是 <strong>115200</strong>，其他串口助手也可以接收消息。</p><p><img src="https://s2.loli.net/2023/01/04/tc2jYemq1WxQR87.png" alt="esp终端.png"></p><p><img src="https://s2.loli.net/2023/01/04/vSZ7y2fYiwIphgq.png" alt="esp串口2.png"></p><p>这位博主很厉害，在之前学习蓝牙协议栈的时候也是跟着这位博主学的，</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://wlink.blog.csdn.net/article/details/123952643">(15条消息) 一篇文章足够你学习ESP32，提供史上最全的ESP32教程(驱动/蓝牙/Wi-Fi/LVGL/Arduino…)_Wireless_Link的博客-CSDN博客_esp32</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,FreeRTOS!</title>
      <link href="/2023/01/03/Hello_FreeRTOS!/"/>
      <url>/2023/01/03/Hello_FreeRTOS!/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello，FreeRTOS！"><a href="#Hello，FreeRTOS！" class="headerlink" title="Hello，FreeRTOS！"></a>Hello，FreeRTOS！</h1><p><strong>官网链接</strong></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://www.freertos.org/zh-cn-cmn-s/">FreeRTOS - Market leading RTOS (Real Time Operating System) for embedded systems with Internet of Things extensions</a></p></div><p><strong>正点原子教程手册</strong></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://semitia.top/upload_flies/STM32F1_FreeRTOS_V1.1.pdf">https://semitia.top/upload_flies/STM32F1_FreeRTOS_V1.1.pdf</a></p></div><h1 id="DEMO1-Blink-LED移植"><a href="#DEMO1-Blink-LED移植" class="headerlink" title="DEMO1: Blink_LED移植"></a>DEMO1: Blink_LED移植</h1><p>按照教程移植的时候，编译出来会有报错</p><blockquote><p>..\OBJ\LED.axf: Error: L6200E: Symbol PendSV_Handler multiply defined (by port.o and stm32f10x_it.o).</p><p>..\OBJ\LED.axf: Error: L6200E: Symbol SVC_Handler multiply defined (by port.o and stm32f10x_it.o).</p></blockquote><p>报错信息显示 <strong>PendSV_Handler</strong>和<strong>SVC_Handler</strong>在<strong>port</strong>和<strong>stm32f10x_it</strong>里面重复定义了。网上查到了有人说要把配置文件<strong>FreeRTOSConfig.h</strong>里的宏定义注释掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xPortPendSVHandler PendSV_Handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vPortSVCHandler SVC_Handler</span></span><br></pre></td></tr></table></figure><p>但是这两个是与与中断函数有关的配置，直接注释掉肯定不合适。在<strong>stm32法f10x_it.c</strong>里面找到这两个函数是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SVC_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PendSV_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以选择将这两个函数给注释掉（实际上教程看到后面发现这几个函数早晚要注释掉的），这样这两个函数分别会指向<strong>port.c</strong>里面的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">vPortSVCHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* *INDENT-OFF* */</span></span><br><span class="line">    PRESERVE8</span><br><span class="line"></span><br><span class="line">    ldr r3, = pxCurrentTCB   <span class="comment">/* Restore the context. */</span></span><br><span class="line">    ldr r1, [ r3 ] <span class="comment">/* Use pxCurrentTCBConst to get the pxCurrentTCB address. */</span></span><br><span class="line">    ldr r0, [ r1 ]           <span class="comment">/* The first item in pxCurrentTCB is the task top of stack. */</span></span><br><span class="line">    ldmia r0 !, &#123; r4 - r11 &#125; <span class="comment">/* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */</span></span><br><span class="line">    msr psp, r0 <span class="comment">/* Restore the task stack pointer. */</span></span><br><span class="line">    isb</span><br><span class="line">    mov r0, # <span class="number">0</span></span><br><span class="line">    msr basepri, r0</span><br><span class="line">    orr r14, # <span class="number">0xd</span></span><br><span class="line">    bx r14</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__asm <span class="type">void</span> xPortPendSVHandler( <span class="type">void</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> uxCriticalNesting;</span><br><span class="line">    <span class="keyword">extern</span> pxCurrentTCB;</span><br><span class="line">    <span class="keyword">extern</span> vTaskSwitchContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *INDENT-OFF* */</span></span><br><span class="line">    PRESERVE8</span><br><span class="line"></span><br><span class="line">    mrs r0, psp</span><br><span class="line">    isb</span><br><span class="line"></span><br><span class="line">    ldr r3, =pxCurrentTCB <span class="comment">/* Get the location of the current TCB. */</span></span><br><span class="line">    ldr r2, [ r3 ]</span><br><span class="line"></span><br><span class="line">    stmdb r0 !, &#123; r4 - r11 &#125; <span class="comment">/* Save the remaining registers. */</span></span><br><span class="line">    str r0, [ r2 ] <span class="comment">/* Save the new top of stack into the first member of the TCB. */</span></span><br><span class="line"></span><br><span class="line">    stmdb sp !, &#123; r3, r14 &#125;</span><br><span class="line">    mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><span class="line">    msr basepri, r0</span><br><span class="line">    dsb</span><br><span class="line">    isb</span><br><span class="line">    bl vTaskSwitchContext</span><br><span class="line">    mov r0, #<span class="number">0</span></span><br><span class="line">    msr basepri, r0</span><br><span class="line">    ldmia sp !, &#123; r3, r14 &#125;</span><br><span class="line"></span><br><span class="line">    ldr r1, [ r3 ]</span><br><span class="line">    ldr r0, [ r1 ] <span class="comment">/* The first item in pxCurrentTCB is the task top of stack. */</span></span><br><span class="line">    ldmia r0 !, &#123; r4 - r11 &#125; <span class="comment">/* Pop the registers and the critical nesting count. */</span></span><br><span class="line">    msr psp, r0</span><br><span class="line">    isb</span><br><span class="line">    bx r14</span><br><span class="line">    nop</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab logs</title>
      <link href="/2022/12/29/Matlab-logs/"/>
      <url>/2022/12/29/Matlab-logs/</url>
      
        <content type="html"><![CDATA[<p>​    MATLAB各功能使用的简单记录。</p><h2 id="lsqcurvefit参数拟合"><a href="#lsqcurvefit参数拟合" class="headerlink" title="lsqcurvefit参数拟合"></a>lsqcurvefit参数拟合</h2>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PID波形绘制及积分优化</title>
      <link href="/2022/11/26/PID%E6%B3%A2%E5%BD%A2%E7%BB%98%E5%88%B6%E5%8F%8A%E7%A7%AF%E5%88%86%E4%BC%98%E5%8C%96/"/>
      <url>/2022/11/26/PID%E6%B3%A2%E5%BD%A2%E7%BB%98%E5%88%B6%E5%8F%8A%E7%A7%AF%E5%88%86%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="MATLAB串口绘制波形"><a href="#MATLAB串口绘制波形" class="headerlink" title="MATLAB串口绘制波形"></a>MATLAB串口绘制波形</h2><p>​    对于<strong>MATLAB</strong>我也是久仰大名，最近安装了一个，感觉功能很丰富，也比较有意思。当然本人也是刚安装<strong>MABLAB</strong>不久，对其理解还是分浅薄，暂时也只是一些简单的使用。</p><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><h4 id="plot-二维绘图"><a href="#plot-二维绘图" class="headerlink" title="plot( ) 二维绘图"></a>plot( ) 二维绘图</h4><p><a href="https://ww2.mathworks.cn/help/matlab/ref/plot.html">二维线图 - MATLAB plot - MathWorks 中国</a></p><h4 id="axis-显示范围"><a href="#axis-显示范围" class="headerlink" title="axis( ) 显示范围"></a>axis( ) 显示范围</h4><p><a href="https://blog.csdn.net/youshijian99/article/details/80842218">(15条消息) Matlab axis函数_Geek猫的博客-CSDN博客_matlab axis</a></p><h4 id="grid-栅格"><a href="#grid-栅格" class="headerlink" title="grid 栅格"></a>grid 栅格</h4><p><a href="https://www.mathworks.com/help/matlab/ref/grid.html">Display or hide axes grid lines - MATLAB grid (mathworks.com)</a></p></div><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>新建函数文件——<strong>Serial.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Serial</span><span class="params">()</span>   %创建函数</span></span><br><span class="line">delete(instrfindall);   <span class="comment">%先关闭串口，否则可能导致出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> x            <span class="comment">%全局变量，供串口中断函数使用</span></span><br><span class="line"><span class="keyword">global</span> t;<span class="comment">%全局变量，这里根据需要绘制图形的个人需要而设</span></span><br><span class="line"><span class="keyword">global</span> m;</span><br><span class="line"><span class="keyword">global</span> <span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">t = [<span class="number">0</span>];      <span class="comment">%时间轴</span></span><br><span class="line">m = [<span class="number">0</span>];      <span class="comment">%数据轴</span></span><br><span class="line"><span class="built_in">i</span> = <span class="number">0</span>;        <span class="comment">%用于计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%串口参数配置</span></span><br><span class="line">x = serial(<span class="string">&#x27;com3&#x27;</span>);</span><br><span class="line">set(x,<span class="string">&#x27;BaudRate&#x27;</span>,<span class="number">115200</span>);</span><br><span class="line">set(x,<span class="string">&#x27;BytesAvailableFcnMode&#x27;</span>,<span class="string">&#x27;Terminator&#x27;</span>) <span class="comment">%ASCII触发，字符触发</span></span><br><span class="line">set(x,<span class="string">&#x27;Terminator&#x27;</span>,<span class="string">&#x27;CR/LF&#x27;</span>)         <span class="comment">%接收到\r\n后触发中断</span></span><br><span class="line">x.BytesAvailableFcn = @Callback  <span class="comment">%定义中断响应函数对象，类似于中断函数名</span></span><br><span class="line">fopen(x);</span><br><span class="line">pause</span><br><span class="line">fclose(x);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另建回调函数文件<strong>Callback.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Callback</span><span class="params">(obj,event)</span>   %创建中断服务函数，绘制图像</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> t; <span class="comment">%时间</span></span><br><span class="line"><span class="keyword">global</span> m; <span class="comment">%纵坐标</span></span><br><span class="line"><span class="keyword">global</span> <span class="built_in">i</span>; <span class="comment">%时间变化值</span></span><br><span class="line"></span><br><span class="line">    out = fscanf(obj);</span><br><span class="line">    data = str2num(out)<span class="comment">%将接收到的字符转换为数值</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">%%----------------------以下根据需要自行编写-------------------------------</span></span><br><span class="line">    t = [t <span class="built_in">i</span>];</span><br><span class="line">    m = [m data];</span><br><span class="line">    <span class="built_in">plot</span>(t,m)</span><br><span class="line">    xlabel(<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">    axis([<span class="built_in">i</span><span class="number">-50</span> <span class="built_in">i</span>+<span class="number">50</span> <span class="number">0</span> <span class="number">1000</span>]);</span><br><span class="line">    grid on;</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="样式预览"><a href="#样式预览" class="headerlink" title="样式预览"></a>样式预览</h3><p>可以参考下文。</p><h2 id="积分优化"><a href="#积分优化" class="headerlink" title="积分优化"></a>积分优化</h2><h3 id="梯形积分PID"><a href="#梯形积分PID" class="headerlink" title="梯形积分PID"></a>梯形积分PID</h3><p>​    从微积分的角度来说，当微分到无限小时，矩形积分与梯形积分是没有区别的。但是实际上采样时间不可能无穷小，采样周期越大，偏差就越大。而梯形积分则是更加接近实际曲线，所以用梯形积分可以得到更高的精度。</p><script type="math/tex; mode=display">\int _0^t e(t) \mathrm{d} t = \sum_{i=0}^t \frac{e(i) + e(i-1)}{2}</script><h3 id="积分分离PID"><a href="#积分分离PID" class="headerlink" title="积分分离PID"></a>积分分离PID</h3><p>在普通的PID控制算法中，由于积分系数是常数，所以在整个控制过程中，积分增量不变。而系统对积分项的要求是：<emp>系统偏差大时积分减弱甚至全无，偏差小时积 分加强。</emp>积分系数大了会产生超调，小了又不能消除静差。变速积分PID可以根据<strong>系统偏差大小</strong>改变积分的速度。<br>    在普通的PID控制算法中，引入积分环节目的主要是为了消除静差。<emp>但在过程的启动、结束或大幅度增减设定时，短时间内系统输出有很大的偏差，</emp>会造成PID运算的积分积累，使控制量超过可能允许的最大动作范围对应的极限控制量，引起系统较大的超调，甚至引起较大的振荡。积分分离PID可以较好地解决这⼀问题。</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>​    思路是偏差值较大时，取消积分作用，以免超调量增大；而偏差值较小时，引入积分作用，以便消除静差，提⾼控制精度。<br>具体的实现步骤是：根据实际情况，设定⼀个阈值</p><ul><li>当偏差大于阈值时，消除积分仅用PD控制；</li><li>当偏差小于等于阈值时，引⼊积分采⽤PID控制。</li></ul><h4 id="积分项表达式"><a href="#积分项表达式" class="headerlink" title="积分项表达式"></a>积分项表达式</h4><script type="math/tex; mode=display">U_i(k) = \beta K_i\sum_{j=0}^{k-1}e(j)</script><p>其中<em>β</em>称为<strong>积分开关系数</strong></p><script type="math/tex; mode=display">\beta = \begin{cases}1, & |e(k)| \leq \varepsilon \\ 0, & |e(k)| > \varepsilon\end{cases}</script><p>由上述表述及公式我们可以知道，积分分离算法的效果其实与<strong>ε</strong>值的选取有很大的关系，所以ε值的选取是实现的难点</p><ul><li><p>ε值过大则达不到积分分离的效果</p></li><li><p>ε值过小则难以进入积分区。</p></li></ul><h3 id="变速积分PID"><a href="#变速积分PID" class="headerlink" title="变速积分PID"></a>变速积分PID</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>变速积分PID的基本思想是<emp>设法改变积分项的累加速度，使其与偏差大小相对应。</emp></p><ul><li>偏差越大，积分越慢；</li><li>偏差越小则越快。</li></ul><p>为此，设置系数<strong>f(e(k))</strong> ，它是<strong>e(k)</strong>的函数。当<strong>e(k)</strong>增大时， <strong>f</strong>减小，反之增大。</p><h4 id="积分项表达式-1"><a href="#积分项表达式-1" class="headerlink" title="积分项表达式"></a>积分项表达式</h4><script type="math/tex; mode=display">U_i(k) = K_i[\sum_{j=0}^{k-1} + f(e(k))*e(k) ]</script><p><strong>f(e(k))</strong>可根据具体情况设定，比较简单的设置为：</p><script type="math/tex; mode=display">f(e(k)) = \begin{cases}1, & |e(k)| \leq B \\\frac{A - |e(k)| + B}{A}, & B < |e(k)| \leq A + B \\0, & |e(k)| > A + B\end{cases}</script><p>由上述公式可知，<strong>f(e(k))</strong>的值在[0,1]区间变化。</p><ul><li><p>当偏差值<strong>e(k)</strong>大于分离区间<strong>A + B</strong>时，不对当前<strong>e(k)</strong>进行累加；</p></li><li><p>当偏差值<strong>e(k)</strong>小于<strong>B</strong>时，加入当前偏差<strong>e(k)</strong>进行累加；</p></li><li><p>介于<strong>B</strong>和<strong>A + B</strong>之间时，按一定函数关系变化。</p></li></ul><p>这种算法对A，B两个参数的要求不精确，参数整定较容易。 </p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">PID_t</span>&#123;</span></span><br><span class="line">    <span class="type">float</span> target;</span><br><span class="line">    <span class="type">float</span> actual;</span><br><span class="line">    <span class="type">float</span> dead_zone;</span><br><span class="line">    <span class="type">float</span> Kp, Ki, Kd;</span><br><span class="line">    <span class="type">float</span> last_error, pre_error, sum_error;</span><br><span class="line">    <span class="type">float</span> I_MAX;</span><br><span class="line">    <span class="type">float</span> P_out, I_out, D_out, D_last_out;</span><br><span class="line">    <span class="type">float</span> out_MAX, out, out_last;</span><br><span class="line">    <span class="type">float</span> I_up, I_low;</span><br><span class="line">    <span class="type">float</span> RC_DF;</span><br><span class="line">&#125;PID_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ABS(p-&gt;pre_error) &lt; P-&gt;I_low)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;sum_error += (p-&gt;pre_error + p-&gt;last_error)/<span class="number">2</span>;</span><br><span class="line">    p-&gt;sum_error = limit(p-&gt;sum_error, p-&gt;I_MAX, -p-&gt;I_MAX);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ABS(p-&gt;pre_error) &lt; p-&gt;I_up)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;sum_error += ((ABS(p-&gt;pre_error) - p-&gt;I_low)/(p-&gt;I_up - p-&gt;I_low)) * ((p-&gt;last_error + p-&gt;pre_error)/<span class="number">2</span>);</span><br><span class="line">    p-&gt;sum_error = limit(p-&gt;sum_error, p-&gt;I_MAX, -p-&gt;I_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然定义的是<strong>I_up,I_low</strong>, 但是实际上这是与<strong>error</strong>相比较的</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>Kp = 350<img src="https://s2.loli.net/2022/11/27/JFxsQNWeq4nuVEP.png" alt="Kp350.png"></p><p>ki = 120</p><p><img src="https://s2.loli.net/2022/11/27/zjaUvYJpVNBcbif.png" alt="Kp350Ki120.png"></p><p>Kd = 100</p><p><img src="https://s2.loli.net/2022/11/27/rZwV9psKjQ8toIJ.png" alt="Kd80.png"></p><p>Kd = 80, up = 80, low = 50</p><p><img src="https://s2.loli.net/2022/11/27/RsTAucIzvqlJtpk.png" alt="up80low50.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 控制方法 </tag>
            
            <tag> PID </tag>
            
            <tag> MATLAB </tag>
            
            <tag> USART </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D-H参数法与机械臂正逆解</title>
      <link href="/2022/11/20/D-H%E5%8F%82%E6%95%B0%E6%B3%95%E6%9C%BA%E6%A2%B0%E8%87%82%E6%AD%A3%E9%80%86%E8%A7%A3/"/>
      <url>/2022/11/20/D-H%E5%8F%82%E6%95%B0%E6%B3%95%E6%9C%BA%E6%A2%B0%E8%87%82%E6%AD%A3%E9%80%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="D-H参数法"><a href="#D-H参数法" class="headerlink" title="D-H参数法"></a>D-H参数法</h1><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/maple_2014/article/details/105612912">(14条消息) 一文带你完全掌握机器人DH参数建模(详细步骤+实例+代码)_Marc Pony的博客-CSDN博客_dh建模</a></p></div><h2 id="坐标变换矩阵"><a href="#坐标变换矩阵" class="headerlink" title="坐标变换矩阵"></a>坐标变换矩阵</h2><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/weixin_44097528/article/details/122182393">(14条消息) 详解坐标变换矩阵_Akinaze的博客-CSDN博客_坐标变换矩阵</a></p></div><h2 id="D-H参数"><a href="#D-H参数" class="headerlink" title="D-H参数"></a>D-H参数</h2><p>​    一般来说，想要得到两个坐标系之间的变换矩阵，需要知道六个量。但是在使用<strong>D-H</strong>参数法时，需要按照特定方式建立坐标系，依托于这些<em>“前提约束”</em>，我们只需要4个参数便可以得出两坐标系之间的变换矩阵。</p><p>先要理解坐标系的<strong>建立规定</strong></p><blockquote><ul><li><p><strong>z轴</strong>的方向垂直于旋转面，即为<strong>转轴</strong>;</p></li><li><p><strong>x[i]</strong>方向的确定：同时垂直于z[i]与z[i-1];</p></li></ul></blockquote><p>依据这样的规定，可以发现：</p><blockquote><ul><li><p>z[i-1]<strong>同时垂直</strong>于x[i-1]与x[i];</p></li><li><p>x[i]<strong>同时垂直</strong>于z[i-1]与z[i];</p></li></ul></blockquote><p>由此，<strong>z[i-1]和x[i]</strong>便成了连接坐标系[i-1]和坐标系[i]的重要参考。再看四个参数的定义</p><div class="note blue icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><ul><li><strong>d[i]</strong>:坐标轴x[i-1]与坐标轴x[i]沿着<strong>z[i-1]</strong>的有向距离；</li><li><strong>θ[i]</strong>:坐标轴x[i-1]与坐标轴x[i]以<strong>z[i-1]</strong>为转轴的旋转角(逆时针，xi在前为正，或者说从x0转到x1的角度)；</li><li><strong>a[i]</strong>:坐标轴z[i-1]与坐标轴z[i]沿着<strong>x[i]</strong>的有向距离；</li><li><strong>α[i]</strong>:坐标轴z[i-1]与坐标轴z[i]以<strong>x[i]</strong>为转轴的旋转角；</li></ul></div><h2 id="正向求解"><a href="#正向求解" class="headerlink" title="正向求解"></a>正向求解</h2><p>在已知各关节角度的条件下，求出机械臂末端的坐标。</p><p>由<strong>D-H</strong>参数可以得到坐标系变换矩阵（将其记作<strong>$T_i$</strong>）：</p><script type="math/tex; mode=display">\begin{bmatrix}x_{i-1} \\ y_{i-1} \\ z_{i-1} \\ 1\end{bmatrix}= \begin{bmatrix} \cos{θ_i} & -\sin{θ_i} \cos{\alpha_i} & \sin{θ_i}\sin{\alpha_i} & a_i\cos{θ_i} \\\sin{θ_i} & \cos{θ_i} \cos{\alpha_i} & -\cos{θ_i}\sin{\alpha_i} & a_i\sin{θ_i} \\ 0 & \sin{\alpha_i} & \cos{\alpha_i} & d_i \\ 0 & 0 & 0 & 1\end{bmatrix}\begin{bmatrix}x_{i} \\ y_{i} \\z_{i} \\ 1\end{bmatrix}</script><p>​    代入<strong>i</strong>系的点$(x_i,y_i,z_i)$，左乘变换矩阵$T_i$，得到这个点在<strong>i-1</strong>系的坐标。由此，将末端坐标$C_n$不断左乘各变换矩阵，便可以递推出其在第一个坐标系的坐标$C_0$。</p><script type="math/tex; mode=display">C_0 = T_1 T_2 \cdots T_{n-1} T_n C_n</script><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>主要就是两个部分</p><blockquote><ul><li>矩阵<strong>Matrix</strong>的构建及其运算</li><li>机械臂<strong>robotic_arm</strong>的构建及基本功能</li></ul></blockquote><p>​    都是直接模拟手算过程，矩阵相乘的时间复杂度是<strong>O(mnk)</strong>，三次方量级的，好在矩阵规模都比较小。</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">Matrix_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> matrix[Matrix_MX][Matrix_MX];</span><br><span class="line">&#125;Matrix_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">robotic_arm_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;<span class="comment">//number of nodes</span></span><br><span class="line">    <span class="type">float</span> d[arm_MX_nodes],a[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> theta[arm_MX_nodes],alpha[arm_MX_nodes];</span><br><span class="line">    Matrix_t *T[arm_MX_nodes];</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">robotic_arm_t</span>;</span><br></pre></td></tr></table></figure><h4 id="机械臂初始化"><a href="#机械臂初始化" class="headerlink" title="机械臂初始化"></a>机械臂初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param n the number of the nodes</span></span><br><span class="line"><span class="comment"> * @param d D-H parameters</span></span><br><span class="line"><span class="comment"> * @param a D-H parameters</span></span><br><span class="line"><span class="comment"> * @param theta D-H parameters</span></span><br><span class="line"><span class="comment"> * @param alpha D-H parameters</span></span><br><span class="line"><span class="comment"> * @return robotic_arm_t* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">robotic_arm_t</span> *<span class="title function_">robotic_arm_init</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> *d, <span class="type">float</span> *a, <span class="type">double</span> *theta, <span class="type">double</span> *alpha)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">robotic_arm_t</span> *arm;</span><br><span class="line">    arm = (<span class="type">robotic_arm_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">robotic_arm_t</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    arm-&gt;T[i] = (Matrix_t*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Matrix_t));</span><br><span class="line"></span><br><span class="line">    arm-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arm-&gt;d[i] = d[i];</span><br><span class="line">        arm-&gt;a[i] = a[i];</span><br><span class="line">        arm-&gt;alpha[i] = alpha[i];</span><br><span class="line">        arm-&gt;theta[i] = theta[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get_Trans(arm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里构建的模型</p><p><img src="https://s2.loli.net/2022/11/23/FJehTzpxDroZPBg.jpg" alt="robotic_arm.jpg" style="zoom:50%;" /></p><div class="table-container"><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>d</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>θ</td><td>0</td><td>$\omega_0$</td><td>-$\omega_1$</td><td>$\frac{\Pi}{2} - \omega_2$</td></tr><tr><td>α</td><td>0</td><td>$-\frac{\Pi}{2}$</td><td>0</td><td>0</td></tr><tr><td>a</td><td>0</td><td>0</td><td>10</td><td>10</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> test_d[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,test_a[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">double</span> test_theta[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;,test_alpha[<span class="number">4</span>]=&#123;<span class="number">0</span>,-PI/<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">test_arm = robotic_arm_init(<span class="number">3</span>,test_d,test_a,test_theta,test_alpha);</span><br></pre></td></tr></table></figure><p>$\omega$为关节（舵机）角度，以图中状态作为初始值，认为此时关节（舵机）角度为0。所以还有一个由关节角度到DH参数的转换函数，这个函数就是根据机械臂具体情况具体修改了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DH_update</span><span class="params">(<span class="type">robotic_arm_t</span> *arm, <span class="type">double</span> *servo)</span></span><br><span class="line">&#123;</span><br><span class="line">    arm-&gt;theta[<span class="number">1</span>] =  servo[<span class="number">0</span>];</span><br><span class="line">    arm-&gt;theta[<span class="number">2</span>] = -servo[<span class="number">1</span>];</span><br><span class="line">    arm-&gt;theta[<span class="number">3</span>] =  PI/<span class="number">2</span>-servo[<span class="number">2</span>];</span><br><span class="line">    get_Trans(arm);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算转移矩阵T"><a href="#计算转移矩阵T" class="headerlink" title="计算转移矩阵T"></a>计算转移矩阵T</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get the Transparent Matrix relay on the current arm state</span></span><br><span class="line"><span class="comment"> * @param arm </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_Trans</span><span class="params">(<span class="type">robotic_arm_t</span> *arm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=arm-&gt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arm-&gt;T[i]-&gt;m=<span class="number">4</span>, arm-&gt;T[i]-&gt;n=<span class="number">4</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">0</span>] =  <span class="built_in">cos</span>(arm-&gt;theta[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">1</span>] = -<span class="built_in">sin</span>(arm-&gt;theta[i])*<span class="built_in">cos</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">2</span>] =  <span class="built_in">sin</span>(arm-&gt;theta[i])*<span class="built_in">sin</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">3</span>] =  arm-&gt;a[i]*<span class="built_in">cos</span>(arm-&gt;theta[i]);</span><br><span class="line"></span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">0</span>] =  <span class="built_in">sin</span>(arm-&gt;theta[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">1</span>] =  <span class="built_in">cos</span>(arm-&gt;theta[i])*<span class="built_in">cos</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">2</span>] = -<span class="built_in">cos</span>(arm-&gt;theta[i])*<span class="built_in">sin</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">3</span>] =  arm-&gt;a[i]*<span class="built_in">sin</span>(arm-&gt;theta[i]);</span><br><span class="line"></span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">0</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">1</span>] =  <span class="built_in">sin</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">2</span>] =  <span class="built_in">cos</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">3</span>] =  arm-&gt;d[i];</span><br><span class="line"></span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">0</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">1</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">2</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">3</span>] =  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="正向求解-1"><a href="#正向求解-1" class="headerlink" title="正向求解"></a>正向求解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get the coordinates of the point in the end coordinate system in the main coordinate system</span></span><br><span class="line"><span class="comment"> *        Suppose the main coordinate system&#x27;s number is 0</span></span><br><span class="line"><span class="comment"> *        得到末端坐标系中的一个点在主坐标系中的坐标,假设主坐标系编号为0</span></span><br><span class="line"><span class="comment"> * @param arm </span></span><br><span class="line"><span class="comment"> * @param point </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foward_solve</span><span class="params">(<span class="type">robotic_arm_t</span> *arm, Matrix_t *point)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=arm-&gt;n; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">    *point = multiply_matrix2(arm-&gt;T[i],point);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向求解"><a href="#逆向求解" class="headerlink" title="逆向求解"></a>逆向求解</h2><p>​    针对于我手上的机械臂，直接采用几何法分析。可是方程我解不出来😂，于是将其稍微变形，利用<strong>二分法</strong>也能迅速求得符合精度要求的解。</p><p><img src="https://s2.loli.net/2022/11/23/ksmLN1CvphgzIEj.jpg" alt="几何逆解.jpg" style="zoom:50%;" /></p><div class="note blue icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>具体二分的思路就是<strong>alpha</strong>越大，机械臂伸得越短，<strong>alpha</strong>越小，伸得越长。比较伸的长短是否到达</p></div><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Use the dichotomy method to find the angle of each joint according to the target coordinates </span></span><br><span class="line"><span class="comment"> *        用二分法根据目标坐标求出关节角度。（使用了几何法，仅适用于特定机械臂）</span></span><br><span class="line"><span class="comment"> *        根据末端机械手位姿求出最后一个关节的坐标(这一步还没实现)，由此计算其余关节角度。</span></span><br><span class="line"><span class="comment"> * @param arm 自己的机械臂，非通解</span></span><br><span class="line"><span class="comment"> * @param point 最后一个关节的坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_solve_dichonomy</span><span class="params">(<span class="type">robotic_arm_t</span> *arm, Matrix_t point)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> angle0, angle1, angle2, alpha_l=<span class="number">0</span>, alpha_r=PI, alpha_mid, beta, theta, len_xy, x, y, z, l1, l2, d;</span><br><span class="line">    x = point.matrix[<span class="number">0</span>][<span class="number">0</span>], y = point.matrix[<span class="number">1</span>][<span class="number">0</span>], z = point.matrix[<span class="number">2</span>][<span class="number">0</span>] - arm-&gt;d[<span class="number">1</span>];</span><br><span class="line">    d = <span class="built_in">sqrt</span>(x*x + y*y + z*z);</span><br><span class="line">    l1 = arm-&gt;a[<span class="number">2</span>], l2 = arm-&gt;a[<span class="number">3</span>];</span><br><span class="line">    len_xy = <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">    <span class="keyword">if</span>(len_xy == <span class="number">0</span>) &#123;theta = PI/<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;theta = <span class="built_in">atan</span>(z/len_xy);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(alpha_r-alpha_l &gt; <span class="number">0.00175</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        alpha_mid = (alpha_l+alpha_r)/<span class="number">2</span>;</span><br><span class="line">        beta = <span class="built_in">asin</span>(<span class="built_in">sin</span>(alpha_mid)*l1/l2);</span><br><span class="line">        <span class="keyword">if</span>(l1*<span class="built_in">cos</span>(alpha_mid) + l2*<span class="built_in">cos</span>(beta) &gt; d)</span><br><span class="line">        &#123;alpha_l = alpha_mid;&#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;alpha_r = alpha_mid;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) &#123;angle0 = PI/<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;angle0 = <span class="built_in">atan</span>(y/x);&#125;</span><br><span class="line">    angle1 = theta - alpha_mid;</span><br><span class="line">    angle2 = alpha_mid + beta + PI/<span class="number">2</span>;</span><br><span class="line">    arm-&gt;theta[<span class="number">1</span>] =  angle0;</span><br><span class="line">    arm-&gt;theta[<span class="number">2</span>] = -angle1;</span><br><span class="line">    arm-&gt;theta[<span class="number">3</span>] = PI/<span class="number">2</span> - angle2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也尝试了使用MATLAB解方程，得出的结果十分的复杂，我觉得还是直接用二分法比较好。</p><p><img src="https://s2.loli.net/2022/11/24/EtFa9Bnypj4YwlZ.png" alt="MATLAB.png"></p><h1 id="粒子群优化算法"><a href="#粒子群优化算法" class="headerlink" title="粒子群优化算法"></a>粒子群优化算法</h1><p>​    在之前的逆解过程中，只能针对单个机械臂的几何特征单独求解，不具有泛用性。而且以我的数学水平也只能求解结构简单的机械臂🤣，当关节数增加甚至冗余时，无法直接用数学方法求解，或者说是多解。所以尝试采用<strong>粒子群优化算法(Particle Swarm Optimization, PSO)</strong>来实现一种通用的解法。</p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://zhuanlan.zhihu.com/p/346355572">粒子群优化算法(Particle Swarm Optimization, PSO)的详细解读 - 知乎 (zhihu.com)</a></p></div><p>这位大佬写得非常详细，我这里是使用c语言实现的，并将其用在了机械臂逆解上面。</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ul><li>粒子群初始化及各粒子随机初始化</li><li>开始迭代<ul><li>计算适应值</li><li>更新个体及群体最优解与最优适应值</li><li>更新w值，粒子速度，粒子位置</li></ul></li><li>结束迭代</li><li>返回寻得的最优解</li></ul><h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><p>看完上面的博客之后，想必这些定义是很容易理解的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param X current state 目前坐标（解）</span></span><br><span class="line"><span class="comment"> * @param V current velocity 目前速度</span></span><br><span class="line"><span class="comment"> * @param opt_X optimal solution of individual&#x27;s history 个体历史最优解</span></span><br><span class="line"><span class="comment"> * @param opt_A optimal adaptability of individual&#x27;s history 个体历史最优适应值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">bird_t</span>&#123;</span></span><br><span class="line">    <span class="type">double</span> X[arm_MX_nodes], V[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> opt_X[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> opt_A;</span><br><span class="line">&#125;<span class="type">bird_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param N size of the bird population 种群规模</span></span><br><span class="line"><span class="comment"> * @param D 解的维度</span></span><br><span class="line"><span class="comment"> * @param K 迭代次数</span></span><br><span class="line"><span class="comment"> * @param W 惯性权重</span></span><br><span class="line"><span class="comment"> * @param C_ind 个体学习因子</span></span><br><span class="line"><span class="comment"> * @param C_pop 群体学习因子</span></span><br><span class="line"><span class="comment"> * @param opt_X_pop optimal solution of population&#x27;s history 群体历史最优解</span></span><br><span class="line"><span class="comment"> * @param opt_A_pop optimal adapatability of population&#x27;s history 群体历史最优解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">bird_population_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> N, D, K;</span><br><span class="line">    <span class="type">double</span> W, C_ind, C_pop;</span><br><span class="line">    <span class="type">double</span> opt_X_pop[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> opt_A_pop;</span><br><span class="line">    <span class="type">bird_t</span> *bird[N_MX_SIZE];</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">bird_population_t</span>;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​    单个粒子的初始化，至于为什么要用 <em>‘bird’</em> 来命名呢，因为这个算法其实也算是一种仿生的思路，作者是受到鸟群觅食的启发发明了这个算法。我第一眼看到这个算法想到的就是遗传算法，其实感觉都是优化的搜索方法，不过相比于遗传算法此算法在求机械臂逆解的应用中更胜一筹，具体怎么个优势法还有待去研究研究。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 粒子随机初始化</span></span><br><span class="line"><span class="comment"> * 在这里面分配空间一定程度上也可以防止空间浪费</span></span><br><span class="line"><span class="comment"> * @param pop </span></span><br><span class="line"><span class="comment"> * @return bird_t* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bird_t</span> *<span class="title function_">bird_init</span><span class="params">(<span class="type">bird_population_t</span> *pop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">bird_t</span> *bird;</span><br><span class="line">    bird = (<span class="type">bird_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bird_t</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pop-&gt;D; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bird-&gt;X[i] = PI*(rand()%<span class="number">180</span>)/<span class="number">180</span>;</span><br><span class="line">        bird-&gt;V[i] = PI*(rand()%<span class="number">20</span><span class="number">-10</span>)/<span class="number">180</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bird-&gt;opt_A = BADDEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bird;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 粒子群初始化</span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @param d </span></span><br><span class="line"><span class="comment"> * @param k </span></span><br><span class="line"><span class="comment"> * @param w </span></span><br><span class="line"><span class="comment"> * @param c_ind </span></span><br><span class="line"><span class="comment"> * @param c_pop </span></span><br><span class="line"><span class="comment"> * @return bird_population_t* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bird_population_t</span> *<span class="title function_">bird_population_init</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> k, <span class="type">double</span> w, <span class="type">double</span> c_ind, <span class="type">double</span> c_pop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bird_population_t</span> *bird_population;</span><br><span class="line">    bird_population = (<span class="type">bird_population_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bird_population_t</span>));</span><br><span class="line"></span><br><span class="line">    bird_population-&gt;N = n, bird_population-&gt;D = d, bird_population-&gt;K = k;</span><br><span class="line">    bird_population-&gt;W = w, bird_population-&gt;C_ind = c_ind, bird_population-&gt;C_pop = c_pop;</span><br><span class="line"></span><br><span class="line">    srand((<span class="type">unsigned</span>)time( <span class="literal">NULL</span> ) );     </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bird_population-&gt;bird[i] = bird_init(bird_population);</span><br><span class="line">    &#125;</span><br><span class="line">    bird_population-&gt;opt_A_pop = BADDEST;</span><br><span class="line">    <span class="keyword">return</span> bird_population;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;bird_pop-&gt;K; i++)<span class="comment">//K</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;bird_pop-&gt;N;j++)<span class="comment">//N</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算适应值</span></span><br><span class="line">            Matrix_t *judge_point = point_init(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="type">double</span> ada=<span class="number">0</span>;<span class="comment">//适应值</span></span><br><span class="line">            DH_update(arm,bird_pop-&gt;bird[j]-&gt;X);</span><br><span class="line">            foward_solve(arm,judge_point);</span><br><span class="line">            ada += (point.matrix[<span class="number">0</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">0</span>][<span class="number">0</span>])*(point.matrix[<span class="number">0</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            ada += (point.matrix[<span class="number">1</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">1</span>][<span class="number">0</span>])*(point.matrix[<span class="number">1</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            ada += (point.matrix[<span class="number">2</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">2</span>][<span class="number">0</span>])*(point.matrix[<span class="number">2</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新个体与群体最优适应值与最优解</span></span><br><span class="line">            <span class="keyword">if</span>(ada &lt; bird_pop-&gt;bird[j]-&gt;opt_A)</span><br><span class="line">            &#123;</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;opt_A = ada;</span><br><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++)</span><br><span class="line">                &#123;bird_pop-&gt;bird[j]-&gt;opt_X[k] = bird_pop-&gt;bird[j]-&gt;X[k];&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ada &lt; bird_pop-&gt;opt_A_pop)</span><br><span class="line">            &#123;</span><br><span class="line">                bird_pop-&gt;opt_A_pop = ada;</span><br><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++)</span><br><span class="line">                &#123;bird_pop-&gt;opt_X_pop[k] = bird_pop-&gt;bird[j]-&gt;X[k];&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新w值，更新各维度速度与位置</span></span><br><span class="line">            w = W_MAX - (W_MAX - W_MIN)*((<span class="type">double</span>)i/bird_pop-&gt;K);</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;V[k] = (w+(rand()/<span class="number">16384</span><span class="number">-1</span>)*<span class="number">0.15</span>)*(bird_pop-&gt;bird[j]-&gt;V[k]) + (rand()/<span class="number">16384</span>)*<span class="number">1.8</span>*(bird_pop-&gt;opt_X_pop[k] - bird_pop-&gt;bird[j]-&gt;X[k]) + (rand()/<span class="number">16384</span>)*<span class="number">1.6</span>*(bird_pop-&gt;bird[j]-&gt;opt_X[k] - bird_pop-&gt;bird[j]-&gt;X[k]);</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;V[k] = (bird_pop-&gt;bird[j]-&gt;V[k] &gt; V_MAX) ? V_MAX : bird_pop-&gt;bird[j]-&gt;V[k];</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;V[k] = (bird_pop-&gt;bird[j]-&gt;V[k] &lt; V_MIN) ? V_MIN : bird_pop-&gt;bird[j]-&gt;V[k];</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;X[k] += bird_pop-&gt;bird[j]-&gt;V[k]; </span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;X[k] = (bird_pop-&gt;bird[j]-&gt;X[k] &gt; X_MAX) ? X_MAX : bird_pop-&gt;bird[j]-&gt;X[k];</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;X[k] = (bird_pop-&gt;bird[j]-&gt;X[k] &lt; X_MIN) ? X_MIN : bird_pop-&gt;bird[j]-&gt;X[k];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//打印调试</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    bird%d: \r\n        当前位置X: &quot;</span>,j);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;arm-&gt;n; m++) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%.3f|%.1f, &quot;</span>,bird_pop-&gt;bird[j]-&gt;X[m],rad_angle(bird_pop-&gt;bird[j]-&gt;X[m]));&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r\n        当前速度V: &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;arm-&gt;n; m++) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%.3f|%.1f, &quot;</span>,bird_pop-&gt;bird[j]-&gt;V[m],rad_angle(bird_pop-&gt;bird[j]-&gt;V[m]));&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(judge_point);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//打印调试</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 最适值: %.3f 惯性w: %.3f\r\n&quot;</span>,i,bird_pop-&gt;opt_A_pop,w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   角度X: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%.2f|%.1f &quot;</span>,bird_pop-&gt;opt_X_pop[k],rad_angle(bird_pop-&gt;opt_X_pop[k]));&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一些小细节"><a href="#一些小细节" class="headerlink" title="一些小细节"></a>一些小细节</h3><p><img src="https://s2.loli.net/2022/11/23/2PGk5JcVnpuKwIq.png" alt="bug1.png"  /></p><p>​    可以看到，虽然我添加了时间随机数种子，但是生成的粒子仍然是全都一样的。这里要将<code>srand((insigned)time(NULL));</code>提前至初始化函数外。</p><p>​    </p><p><code>w = W_MAX - (W_MAX - W_MIN)*((double)i/bird_pop-&gt;K);</code> 在给<strong>w</strong>加权的时候别忘了<code>double</code>，不然后面算出来一直是0。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>感谢大家耐心看完了本篇博客，如果觉得不错的话欢迎分享给他人。由于本人水平有限，难免有错误的地方，也欢迎在评论区批评指正。完整的代码可以在我的代码仓库找到，后续也会将其移植到STM32上。在这里贴上主要代码方便随时查看，思路与代码相互对照也更容易理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运动学分析 </tag>
            
            <tag> 机械臂 </tag>
            
            <tag> D-H参数法 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 粒子群优化算法 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIY平衡小车</title>
      <link href="/2022/11/12/DIY%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6/"/>
      <url>/2022/11/12/DIY%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="前期基本方案"><a href="#前期基本方案" class="headerlink" title="前期基本方案"></a>前期基本方案</h1><h2 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h2><h3 id="基本目标"><a href="#基本目标" class="headerlink" title="基本目标"></a>基本目标</h3><ul><li>根据指令实现精准的速度控制</li><li>自身坐标和姿态的解算</li><li>与上位机传输数据</li></ul><h3 id="更有意思的目标"><a href="#更有意思的目标" class="headerlink" title="更有意思的目标"></a>更有意思的目标</h3><ul><li>双轮平衡车</li><li>控制雷达平稳</li></ul><h2 id="电机驱动"><a href="#电机驱动" class="headerlink" title="电机驱动"></a>电机驱动</h2><p>​    电机使用<strong>12V</strong>供电，可以直接由电源模块供电。使用<strong>TB6612驱动模块</strong>可以满足两个电机的驱动需求。</p><h2 id="位姿测量"><a href="#位姿测量" class="headerlink" title="位姿测量"></a>位姿测量</h2><p>​    使用<strong>MPU6050</strong>可以获取角速度和加速度值（但是之前试用的时候发现其自带的库位姿解算会有不少时间的初始化延迟）。</p><p>​    MPU6050使用<strong>IIC</strong>通信，在获得了新的测量之后会在<strong>INT</strong>脚输出高电平，为了保证数据的即时性，将一个GPIO配置为外部中断，在中断函数里更新数据。</p><h2 id="轮速获取"><a href="#轮速获取" class="headerlink" title="轮速获取"></a>轮速获取</h2><p>​    将两个定时器配置为<strong>编码器接口模式</strong>，分别接收两个电机对应的编码器数据。我们使用的是AB双相输入的编码器，参考手册：</p><blockquote><p>如果计数器只在TI2的边沿计数，则置TIMx_SMCR寄存器中的SMS=001；如果只在TI1边沿计数，则置SMS=010；如果计数器同时在TI1和TI2边沿计数，则置SMS=011。  </p></blockquote><p>对寄存器的配置已经被封装在库函数<strong>TIM_EncoderInterfaceConfig（ ）</strong>里了，只需要选择配置<strong>模式3</strong>即可，在这个情况下，TI1和TI2分别对应TIMx的<strong>channel1</strong>和<strong>channel2</strong>的引脚，默认情况下TIM2就是<strong>PA0 PA1</strong>,TIM3是<strong>PA6 PA7</strong>。</p><p>也可以与MPU6050传感器数据融合。</p><h2 id="运动控制"><a href="#运动控制" class="headerlink" title="运动控制"></a>运动控制</h2><h3 id="直立环"><a href="#直立环" class="headerlink" title="直立环"></a>直立环</h3><p>直立环使小车保持直立，即保持在<strong>机械中值θ</strong>的位置，理想情况下是保持0°。</p><p> $PWM_{balance} = KP <em> θ + KD </em> \Delta θ$ </p><h3 id="速度环"><a href="#速度环" class="headerlink" title="速度环"></a>速度环</h3><p>​    根据上位机发布的速度指令或者由<strong>位置环</strong>计算出的目标速度计算出输出力矩。</p><script type="math/tex; mode=display">PWM_{speed} = KP_s * Error + KD_s * \Delta Error</script><h3 id="速度环（平衡车）"><a href="#速度环（平衡车）" class="headerlink" title="速度环（平衡车）"></a>速度环（平衡车）</h3><p>​    但是由于安装等外界因素影响，小车以为的<strong>0°</strong>并非真正的平衡态，于是我们引入了<strong>速度环</strong>。当小车速度稳定时，便可以认为小车进入平衡态。速度环的输出可以看作是一个<strong>角度</strong>，作为直立环的输入，直立环便演变成了使小车保持一定角度，在保持角度的时候便会产生速度。</p><script type="math/tex; mode=display">balance \_ IN \_ speed = KP_S * Error + KD_S * \Delta Error</script><script type="math/tex; mode=display">PWM \_ balance \_ speed=KP * (θ + balance \_ IN \_ speed) + KD * \Delta θ</script><p>合并整理后便可得到</p><script type="math/tex; mode=display">PWM \_ balance \_ speed = KP * θ + KD * \Delta θ + KP（ KP_S * Error + KD_S * \Delta Error）</script><p>两者其实是线性相加的，直接将KP <em> KP_S合并为KP_S，KP </em> KD_S合并为KD_S，最终简化为</p><script type="math/tex; mode=display">PWM_{balance} = KP * \theta + KD * \Delta \theta</script><script type="math/tex; mode=display">PWM_{speed} = KP_s *Error + KD_s * \Delta Error</script><script type="math/tex; mode=display">PWM = PWM_{speed} + PWM_{balance}</script><h3 id="转向环"><a href="#转向环" class="headerlink" title="转向环"></a>转向环</h3><p>​    转向环比较简单，直接根据<strong>角度</strong>输出一个速度差，用<strong>PD</strong>控制即可。</p><h2 id="控制雷达平稳"><a href="#控制雷达平稳" class="headerlink" title="控制雷达平稳"></a>控制雷达平稳</h2><p>​    根据车子姿态控制舵机角度以尽可能保证雷达平稳。</p><h2 id="运动模型"><a href="#运动模型" class="headerlink" title="运动模型"></a>运动模型</h2><p>​    设：车子速度为<strong>v</strong> ； 两轮速度分别为<strong>v1，v2</strong> ；两轮间距为<strong>d</strong> ；速度瞬心为点 <strong>P</strong> ； 速度瞬心离两轮距离分别为 <strong>r1 , r2</strong> ；车身角速度为 <strong>w</strong> ； 车子运动轨迹半径为<strong>R</strong> ；<strong>逆时针</strong>转为正方向</p><p>​    可以算得：</p><script type="math/tex; mode=display">v =\frac{1}{2} ( v_1 + v_2 )</script><script type="math/tex; mode=display">\omega = \frac{v_2 - v_1}{d}</script><p>​    </p><script type="math/tex; mode=display">R = d\frac{v_1 + v_2}{2(v_2 - v_1)}</script><p>目前的想法是建立一个<strong>世界坐标系</strong>和一个<strong>车子坐标系</strong>。</p><ul><li>在<strong>车子坐标系</strong>中可以轻松地计算出<strong>下一时刻</strong>车子的位置和姿态 ；</li><li>而通过<strong>这一时刻</strong>车子的位置和姿态又可以得到此时车子坐标系与世界坐标系的<strong>变换矩阵</strong>；</li><li>利用<strong>变换矩阵</strong>可以将<strong>车子坐标系中</strong>下一时刻的位姿转换到<strong>世界坐标系</strong>。</li></ul><p>​    如此便可以完成状态递推。</p><script type="math/tex; mode=display">\Delta \theta_k = \frac{v_{k-1}}{R_{k-1}} \Delta t</script><script type="math/tex; mode=display">\Delta x_k = R_{k-1} (1 - \cos {\Delta \theta_k})</script><script type="math/tex; mode=display">\Delta y_k = R_{k-1} \sin{\Delta \theta_k}</script><script type="math/tex; mode=display">x_k = x_{k-1} + \Delta x_k \sin{\theta_{k-1}} + \Delta y_k \cos{\theta_{k-1}}</script><script type="math/tex; mode=display">y_k = y_{k-1} - \Delta x_k \cos{\theta_{k-1}} + \Delta y_k \sin{\theta_{k-1}}</script><script type="math/tex; mode=display">\theta_k = \theta_{k-1} + \Delta \theta_k</script><h1 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h1><h1 id="STM32代码"><a href="#STM32代码" class="headerlink" title="STM32代码"></a>STM32代码</h1><h2 id="串口调试"><a href="#串口调试" class="headerlink" title="串口调试"></a>串口调试</h2><p>​    DEBUG或者远程控制的时候选择使用串口外设。其中用到了三个串口，可以根据情况选择使用。</p><h3 id="接收中断问题"><a href="#接收中断问题" class="headerlink" title="接收中断问题"></a>接收中断问题</h3><p>​    程序主要由一个核心中断函数构成，在调试的过程中我发现由于这个中断函数的存在，串口通讯会经常出现通讯错误。显然是因为串口中断函数和这个核心中断函数冲突了，不过是中断优先级配置的问题。</p><p>​    可是我发现了这样一个问题，USART_IRQn配置为0x00,0x00，EXTI9_5_IRQn配置为0x00,0x01会严重影响串口数据接收的正确性，但是将后者配置为0x01,0x01就不会。<u>同样是优先级低于串口，为什么改变了后者的**抢断优先级**就会产生这样的区别呢？</u></p><p>​    当中断优先级配置完成后，若多个中断同时发生则先比较抢占优先级谁的值小谁先进行，若抢占优先级相同则比较子优先级谁的值小谁先进行，若两者都相同，就比较硬件中断编号（该编号由硬件自身决定），值得注意的是当一中断正在进行时又一中断发生若后者的抢占优先级的值比前者小则后者可以打断正在发生的中断执行后者的中断进程，需要注意 <emp>若后者的抢占优先级与前者相等但子优先级的值比前者小此时后者不能打断正在发生的中断, 必须等其完成后才能进行，</emp> 至于后者的优先级比正在发生的中断优先级低的情况，那就肯定是等待正在进行的中断完成后再进行。</p><p>​    所以说<em>“抢占”</em>一词，还是比较生动的。</p><p>​    <em>当然，如果直接用DMA的话就没这些问题了。</em></p><h3 id="USART2-DMA"><a href="#USART2-DMA" class="headerlink" title="USART2_DMA"></a>USART2_DMA</h3><p>​    在DMA初始化函数的最后，设置的<strong>TX</strong>与<strong>RX</strong>的开闭状态是不一样的，为什么呢？在理顺了具体的DMA收发过程之后便很容易理解了。</p><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><blockquote><p>判断DMA是否处于发送完毕的空闲状态。flag=1，正在发送</p><p>设置发送数据的地址与大小</p><p>CMD使能开始发送</p><p>（可执行其他操作）</p><p>DMA发送完成中断</p><p>清除标志位（包括flag）</p><p>CMD失能关闭通道</p></blockquote><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><blockquote><p>（DMA事先保持开启）</p><p>串口输入，DMA同时转运数据</p><p>传输完毕，串口空闲中断</p><p>清除标志位</p><p>CMD失能关闭DMA通道</p><p>获取DMA缓存中数据长度与数据</p><p>（切换接收缓冲器）</p><p>更新DMA剩余缓存（CNDTR）</p><p>CMD使能开启通道等待接收  </p></blockquote><h3 id="蓝牙SPP"><a href="#蓝牙SPP" class="headerlink" title="蓝牙SPP"></a>蓝牙SPP</h3><h4 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h4><p>别忘了加回车</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>​    之前UART2，UART3都是没问题的，但是今天调试的时候发现插在UART3上面，连接到蓝牙的时候单片机就会停止运行。</p><p>​    DEBUG发现竟然卡在15_10的中断函数里面，查询手册发现UART3的RX是PB11，而这个代码正好把PB11配置为了超声波模块的中断引脚，中断函数里会等待超声波模块回复的高电平，导致一直在等待。一般这两个功能是没有一起使用的必要的，所以直接关闭其中一个即可。</p><p>​    但是还有一个问题，就是串口接收到的数据解析出现错误。结果是因为USART3_RX_BUF写成了复制的USART_RX_BUF没改过来😂。</p><h2 id="控制代码"><a href="#控制代码" class="headerlink" title="控制代码"></a>控制代码</h2><h1 id="LattePanda"><a href="#LattePanda" class="headerlink" title="LattePanda"></a>LattePanda</h1><h2 id="前言与Ubuntu18-04安装"><a href="#前言与Ubuntu18-04安装" class="headerlink" title="前言与Ubuntu18.04安装"></a>前言与Ubuntu18.04安装</h2><p>​    原本用的是树莓派3B，官方的desktop版本只有22.04版的，装上之后奇卡无比，浏览器都会闪退。但是这样也能用，之后装上了ROS2，惨痛的发现在终端编译都会闪退，所以尝试换成18.04（感觉对性能要求会低一些），正好18.04也与厂家代码更适配，所以尝试装了server版本，因为没有图形化界面，需要自己联网，安装图形化界面，过程比较曲折。可以参考这一篇博客</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://zhuanlan.zhihu.com/p/372861457">树莓派4B安装Ubuntu18.04+ROS Melodic终极教程 - 知乎 (zhihu.com)</a></p></div><p>安装ROS的话我发现了一个神仙博主提供的一键安装命令，非常方便。</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/qq_27865227/article/details/120191557?ops_request_misc=%7B%22request%5Fid%22%3A%22166141462416782391868234%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=166141462416782391868234&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-120191557-null-null.nonecase&amp;utm_term=如何一行代码&amp;spm=1018.2226.3001.4450">(15条消息) 如何一行代码安装ROS|2022最新版|一行代码安装ROS2|一行代码解决rosdep|一行代码配置多ROS环境_鱼香ROS的博客-CSDN博客_ros安装脚本</a></p></div><p>可是安装完了之后我悲惨的发现，就是树莓派性能不够，图形化界面装完了之后直接显示花屏。</p><p>​    所以我干脆一鼓作气买了个<strong>LattePanda2</strong>，性能据说约等于两个树莓派4B，八个树莓派3B。是X86架构的，自带Win10，还附带了一个Leonardo型号的Arduino，真不错。</p><h3 id="安装Ubuntu18-04"><a href="#安装Ubuntu18-04" class="headerlink" title="安装Ubuntu18.04"></a>安装Ubuntu18.04</h3><p>​    Tips：</p><ul><li>供电需要一个手机充电头和一个质量不错的数据线，至少2A。(之前树莓派先是随便找了一根线，结果一直显示供电不足)</li><li>用作启动盘的U盘质量也要好一点，不然会一直刻录失败（一开始用的送的U盘，结果折腾半天）</li></ul><p>可以参考这一篇文章（虽然是英文的，但是也可以看懂，而且说的很详细）</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation/blob/master/README_UBUNTU.md">LattePanda-Ubuntu18.04-Spinnaker-Installation/README_UBUNTU.md at master · imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation (github.com)</a></p></div><p>镜像下载链接</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://releases.ubuntu.com/18.04/">Ubuntu 18.04.6 LTS (Bionic Beaver)</a></p></div><p>​    接下来就是安装系统，具体可以参考上面的博客。有一点需要额外提一嘴，就是安装到后面发现一直是一个橙黄色背景，没有显示任何其他窗口，但是会发现能拖出鼠标，按键盘也有反应。其实是因为LattePanda内置一个屏幕，但是如果直接只用HDMI连显示屏的话这个是看不到的，相当于在左上角有一个看不见主屏幕，系统安装的操作窗口在那边。所以只能尝试用鼠标把那边的窗口拖过来，多试几次总能抓过来的😂。</p><h3 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h3><ul><li>使用软件：No machine</li></ul><p>​    在同一个局域网下，主机上的客户端可以搜索到Ubuntu，双击连接。接下来需要输入用户和密码，就是对应Ubuntu上的用户名和密码。我设置的用户名是<strong>Anya</strong>，计算机名是<strong>Bonder</strong>，所以输入 <strong>anya</strong> 和 <strong>密码</strong>。</p><emp>注意这里的用户名是不用输入大写的，区分了大小写反而会连接不上。</emp><h2 id="ROS"><a href="#ROS" class="headerlink" title="ROS"></a>ROS</h2><h3 id="安装melodic"><a href="#安装melodic" class="headerlink" title="安装melodic"></a>安装melodic</h3><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation/blob/master/README_UBUNTU.md">LattePanda-Ubuntu18.04-Spinnaker-Installation/README_UBUNTU.md at master · imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation (github.com)</a></p></div><h3 id="工作空间配置"><a href="#工作空间配置" class="headerlink" title="工作空间配置"></a>工作空间配置</h3><h4 id="还要先安装一大堆包"><a href="#还要先安装一大堆包" class="headerlink" title="还要先安装一大堆包"></a>还要先安装一大堆包</h4><ul><li>geographic-msgs</li><li>moveit-core</li><li>world-canvas-msgs</li><li>moveit-visual-tools</li><li>moveit-ros-move-group</li><li>moveit-ros-planning-interface</li></ul><h4 id="中间出现了一些问题"><a href="#中间出现了一些问题" class="headerlink" title="中间出现了一些问题"></a>中间出现了一些问题</h4><blockquote><p>E: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用)<br>E: 无法获取 dpkg 前端锁 (/var/lib/dpkg/lock-frontend)，是否有其他进程正占用它？</p></blockquote><p>可以参考这一篇文章</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/zhang33565417/article/details/105164356">(17条消息) 解决 Ubuntu中 ‘E: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用) ’ 问题_程序猿秃头之路的博客-CSDN博客</a></p></div><p>里面的一些命令的解释：</p><blockquote><p>无法定位软件包 ros-melodic-world-canvas-msgs</p></blockquote><p>这样的话干脆直接在<strong>Github</strong>下载，然后粘贴到 <em>/工作空间/src</em> 下面，重命名为 <strong>world_canvas_msgs</strong>。</p><p><a href="https://github.com/corot/world_canvas_msgs">corot/world_canvas_msgs: Messages and services for the semantic maps framework (github.com)</a></p><p>​    但是编译出来报错，不知道是不是包不对，其他地方也找不到这个包了。这个包实际上也不是 <strong>melodic</strong> 版本的，不知道这个商家咋搞的。</p><h3 id="换成eloquent"><a href="#换成eloquent" class="headerlink" title="换成eloquent"></a>换成eloquent</h3><p>​    前面那个问题一直卡着也不是个办法，先尝试使用ros2好了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运动学分析 </tag>
            
            <tag> 平衡小车 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波学习笔记</title>
      <link href="/2022/11/04/Kalman%20filter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/04/Kalman%20filter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    最近在学习卡尔曼滤波算法，这其中用到了一些数学和现代控制理论的知识。由于我在学习之前没有啥知识储备，在网上看了很多博客、花了很多时间之后依然是一种似懂非懂的感觉。终于找到了一些很棒的教程，感觉算是稍微理解了一些，整理了一些学习笔记，梳理思路，也方便日后查阅。</p><p><strong>教程链接</strong></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><a href="https://www.bilibili.com/video/BV1ez4y1X7eR/?spm_id_from=333.788&amp;vd_source=0f383e93e945bca07eaef9a9ee5d9db3">【卡尔曼滤波器】1_递归算法_Recursive Processing_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1Rh41117MT/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0f383e93e945bca07eaef9a9ee5d9db3">从放弃到精通！卡尔曼滤波从理论到实践~_哔哩哔哩_bilibili</a></li><li><a href="https://blog.csdn.net/Yemiekai/article/details/116372288">https://blog.csdn.net/Yemiekai/article/details/116372288</a></li></ul></div><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><h3 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h3><blockquote><p>将<strong>方差、协方差</strong>在一个矩阵中表现出来，体现变量间的<strong>联动关系</strong></p></blockquote><p>假设有<strong>X,Y,Z</strong>三组数据，每组数据有<strong>n</strong>个</p><h4 id="方差："><a href="#方差：" class="headerlink" title="方差："></a>方差：</h4><script type="math/tex; mode=display">\sigma_x^2 = \frac{1}{n}\sum(x_i - \bar{x})^2</script><p>方差越大，数据波动越大</p><h4 id="协方差："><a href="#协方差：" class="headerlink" title="协方差："></a>协方差：</h4><script type="math/tex; mode=display">\sigma_x\sigma_y = \sigma_y\sigma_x = \frac{1}{n}\sum(x_i - \bar{}x)(y_i - \bar{y})</script><p>协方差越小，X,Y相关性越低</p><h4 id="协方差矩阵："><a href="#协方差矩阵：" class="headerlink" title="协方差矩阵："></a>协方差矩阵：</h4><script type="math/tex; mode=display">\begin{bmatrix}\sigma_x^2 & \sigma_x\sigma_y & \sigma_x\sigma_z \\ \sigma_y\sigma_x & \sigma_y^2 & \sigma_y\sigma_z \\ \sigma_z\sigma_x & \sigma_z\sigma_y & \sigma_z^2\\ \end{bmatrix}</script><h4 id="过渡矩阵"><a href="#过渡矩阵" class="headerlink" title="过渡矩阵"></a>过渡矩阵</h4><p>过渡矩阵<strong>a</strong>用以计算协方差矩阵<strong>P</strong>：</p><script type="math/tex; mode=display">P = \frac{1}{n}a^Ta</script><p>结合公式容易理解：(此处为3x3矩阵)</p><script type="math/tex; mode=display">a = \begin{bmatrix}x1 & y1 & z1 \\ x2 & y2 & z2 \\ x3 & y3 & z3 \\ \end{bmatrix} - \frac{1}{3}\begin{bmatrix}1 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \\ \end{bmatrix}\begin{bmatrix}x1 & y1 & z1 \\ x2 & y2 & z2 \\ x3 & y3 & z3 \\ \end{bmatrix}</script><p>被减数即为<strong>原矩阵</strong>，而减数则为<strong>平均值矩阵</strong></p><h3 id="状态空间方程"><a href="#状态空间方程" class="headerlink" title="状态空间方程"></a>状态空间方程</h3><script type="math/tex; mode=display">\hat{X}_k = A\hat{X}_{k-1} + Bu_{k-1} + W_{k-1}</script><script type="math/tex; mode=display">Z_k = HX_k + V_k</script><p><strong>变量说明：</strong></p><ul><li><script type="math/tex">\hat{X}_k</script>：实际状态值</li><li><script type="math/tex">\hat{X}_{k-1}</script>：上一时刻状态值</li><li>$u_k-1$：控制输入量</li><li><em>A、H、B</em>：转换矩阵</li><li>$Z_k$：测量值</li><li>$W_{k-1}$：过程噪声</li><li>$V_k$：测量噪声</li></ul><p><strong>关于传递方程：</strong></p><p>​    如果我们掌握了一个物体的运动规律，那么这个时刻的状态可以通过上一个时刻的状态计算出来。但是也不能保证完全精准，所以添加了<strong>过程噪声——W</strong></p><p>​    举个例子——经典的阻尼弹簧振子模型：</p><p><img src="https://s2.loli.net/2022/11/05/njC8ubrIcYQRiF9.jpg" alt="阻尼弹簧.jpg"></p><p>弹簧恢复力 = kX，阻力 = Bv。将X的导数v记作$\dot{X}$，X的二阶导a记作$\ddot{X}$，便可以得到：</p><script type="math/tex; mode=display">m\ddot{X} + B\dot{X} + kX = F</script><p>取状态变量<strong>X1为位移</strong>，<strong>X2为速度</strong>，F记为控制输入<strong>u</strong>，根据之前公式可得：</p><script type="math/tex; mode=display">\dot{X_1} = X_2</script><script type="math/tex; mode=display">\dot{X_2} = \ddot{X} = \frac{1}{m}u - \frac{B}{m}X_2 - \frac{k}{m}X_1</script><p>写成矩阵的形式就是：</p><script type="math/tex; mode=display">\begin{bmatrix} \dot{X_1} \\ \dot{X_2} \end{bmatrix} = \begin{bmatrix} 0 & 1 \\ -\frac{k}{m} & -\frac{B}{m} \end{bmatrix}\begin{bmatrix} X_1 \\ X_2 \end{bmatrix} + \begin{bmatrix} 0 \\ \frac{1}{m} \end{bmatrix}u</script><p>对应着状态趋势矩阵与状态的关系：</p><script type="math/tex; mode=display">\dot{X_t} = AX_t + Bu_t</script><p>写成离散的形式就是：</p><script type="math/tex; mode=display">X_k = AX_{k-1} + Bu_{k}</script><p>当然最后加上不确定因素W</p><p><strong>关于测量方程：</strong></p><p>​    一般而言我们可能会习惯把<strong>待求量</strong>放在等式左边，已知量放在等式右边。但是在这里$Z_k$才是我们实际获得的数据。</p><p>​    关于转换矩阵H，一般我们无法直接测得需要的待测量，所以会测量其他量计算出待测量。举个例子</p><blockquote><p>激光测距仪测距：发射激光，根据返回用时计算距离。直接获得的物理量是 <strong>时间($Z_n$)</strong>，而我们想获得的 <strong>距离($X_n$)</strong>，于是有了转换矩阵 <strong>H($ \begin{bmatrix}\frac{2}{c}\end{bmatrix}$)</strong></p><script type="math/tex; mode=display">Z_n = \begin{bmatrix}\frac{2}{c}\end{bmatrix}X_n + V_n</script></blockquote><h2 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h2><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p><strong>先验估计方程：</strong></p><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1}</script><p><strong>先验误差协方差矩阵：</strong></p><script type="math/tex; mode=display">P_k^{-} = AP_{k-1}A^T + Q</script><h3 id="矫正"><a href="#矫正" class="headerlink" title="矫正"></a>矫正</h3><p><strong>卡尔曼增益：</strong></p><script type="math/tex; mode=display">K_k = \frac{P_k^- H^T}{HP_k^- H^T + R}</script><p><strong>后验估计：</strong></p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + K_k( Z_k - H\hat{X}_k^-)</script><p><strong>后验误差协方差矩阵：</strong></p><script type="math/tex; mode=display">P_k = ( I - K_kH)P_k^-</script><h3 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h3><ul><li><script type="math/tex">\hat{X}_k^-</script>：k时刻先验估计值——<strong>算出来的</strong></li><li>$\hat{X}_k$：最优估计值</li><li>$\hat{X}_{k-1}$：k-1时刻最优估计值</li><li>$u_k-1$：控制输入量</li><li>$K_k$：卡尔曼增益</li><li>$Z_k$：测量值——<strong>测出来的</strong></li><li>$W_{k-1}$：过程噪声</li><li>$V_k$：测量噪声</li><li>H：由状态量向测量量转换的矩阵</li></ul><p>变量<strong>带个帽子</strong>一般是<strong>估计值</strong>；变量右上角<strong>有个”-“</strong>一般是<strong>先验值</strong>。</p><h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><ol><li>由上一时刻<strong>最优估计值 $\hat{X}_{k-1}$</strong>计算<strong>先验估计值 $\hat{X}_k^-$</strong></li><li>获取<strong>测量值 $Z_k$</strong></li><li>由上一时刻<strong>误差协方差矩阵 $P_{k-1}$</strong>计算<strong>先验误差协方差矩阵 $P_K^-$</strong></li><li>计算<strong>卡尔曼增益$K_k$</strong></li><li>计算<strong>最优估计值<script type="math/tex">\hat{X}_k</script></strong></li><li>更新<strong>后验误差协方差矩阵 $P_k$</strong></li><li>不断更新迭代</li></ol><h2 id="公式说明与推导"><a href="#公式说明与推导" class="headerlink" title="公式说明与推导"></a>公式说明与推导</h2><h3 id="先验估计方程"><a href="#先验估计方程" class="headerlink" title="先验估计方程"></a>先验估计方程</h3><blockquote><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1}</script></blockquote><p>​    由上一时刻的<strong>最优估计值</strong>，根据运动模型推测这一时刻的状态值，即<strong>先验估计值</strong>。和<strong>传递方程</strong>类似。</p><h3 id="后验估计方程"><a href="#后验估计方程" class="headerlink" title="后验估计方程"></a>后验估计方程</h3><blockquote><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + K_k( Z_k - H\hat{X}_k^-)</script></blockquote><p>​    想要得到<strong>最优估计值</strong>，概括来说是根据数据的可靠性将<strong>测量值</strong>和<strong>计算值</strong>加权叠加起来，得到的就是<strong>后验估计值</strong>，也就是滤波过后得到的这一时刻的<strong>最优估计值</strong>。根据<strong>数据融合</strong>原理得到公式：</p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + G( H^-Z_k - \hat{X}_k^-)</script><p>但是我们经常看到的都是令 $G = K_kH$ 变换后的形式，即：</p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_{k}^- + K_k ( Z_k - H\hat{X}_{k}^- )</script><p>其中 $K_k$∈[0, $H^-$]</p><ul><li>当$K_k$ == 0 时，测量误差很大，信任计算出来的值，即 $\hat{X}_{k} == \hat{X}_{k}^-$;</li><li>当$K_k == H^-$时，无测量误差，信任测量值，即$\hat{X}_{k} == H^-Z_k$；</li></ul><h3 id="卡尔曼增益"><a href="#卡尔曼增益" class="headerlink" title="卡尔曼增益"></a>卡尔曼增益</h3><blockquote><script type="math/tex; mode=display">K_k = \frac{P_k^- H^T}{HP_k^- H^T + R}</script></blockquote><p>要计算卡尔曼增益，即求出使误差协方差最小的 $k_k$，在求出其关于$K_k$ 的表达式后再求导得到极值点。</p><h3 id="状态空间方程："><a href="#状态空间方程：" class="headerlink" title="状态空间方程："></a><strong>状态空间方程：</strong></h3><blockquote><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1} + W_{k-1}</script><script type="math/tex; mode=display">Z_k = HX_k + V_k</script></blockquote><p><img src="https://s2.loli.net/2022/11/03/hviNkZWEIeG39sw.jpg" alt="note1.jpg"></p><p><img src="https://s2.loli.net/2022/11/03/iwQRzfS7FlnPmZM.jpg" alt="note2.jpg"></p><h3 id="先后验误差协方差矩阵"><a href="#先后验误差协方差矩阵" class="headerlink" title="先后验误差协方差矩阵"></a>先后验误差协方差矩阵</h3><blockquote><script type="math/tex; mode=display">P_k^{-} = AP_{k-1}A^T + Q</script><script type="math/tex; mode=display">P_k = ( I - K_kH)P_k^-</script></blockquote><p><img src="https://s2.loli.net/2022/11/03/8bS1wKNJ3EoAOy2.jpg" alt="note.jpg"></p><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><h4 id="kalman-filter"><a href="#kalman-filter" class="headerlink" title="kalman_filter"></a>kalman_filter</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">filter</span><span class="params">(Matrix_t Z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    pre_angle1 += Z.matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    pre_angle2 += Z.matrix[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    pre_angle3 = (pre_angle1 + pre_angle2)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    _X = <span class="built_in">mul_matrix</span>(F,X);</span><br><span class="line">    _P = <span class="built_in">add_matrix</span>(<span class="built_in">mul_matrix</span>(<span class="built_in">mul_matrix</span>(F, P), <span class="built_in">tran_matrix</span>(F)), Q);</span><br><span class="line">    K  = <span class="built_in">mul_matrix</span>(<span class="built_in">mul_matrix</span>(_P,<span class="built_in">tran_matrix</span>(H)), <span class="built_in">inv_matrix</span>(<span class="built_in">add_matrix</span>(<span class="built_in">mul_matrix</span>(<span class="built_in">mul_matrix</span>(H,_P),<span class="built_in">tran_matrix</span>(H)),R)));</span><br><span class="line">    X  = <span class="built_in">add_matrix</span>(_X,<span class="built_in">mul_matrix</span>(K,<span class="built_in">sub_matrix</span>(Z,<span class="built_in">mul_matrix</span>(H,_X) ) ) );</span><br><span class="line">    P  = <span class="built_in">mul_matrix</span>(<span class="built_in">sub_matrix</span>(<span class="built_in">get_I</span>(<span class="number">2</span>),<span class="built_in">mul_matrix</span>(K,H)),_P); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\n&quot;</span>,count, pre_angle1, pre_angle2, pre_angle3, X.matrix[<span class="number">0</span>][<span class="number">0</span>], X.matrix[<span class="number">1</span>][<span class="number">0</span>], Z.matrix[<span class="number">0</span>][<span class="number">0</span>], Z.matrix[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行一次<strong>filter( )</strong>就是进行了一次迭代。</p><p>这里使用<strong>fprintf</strong>将数据打印至excel文件，绘出波形。</p><p>当然，这里还用到了一些矩阵运算函数，我写在<strong>Matrix.h</strong>里面，下次想运算矩阵就直接调用啦，非常方便。不过更多的运算函数有待进一步的完善。</p><ul><li>add_matrix：矩阵加法</li><li>sub_matrix：矩阵减法</li><li>mul_matrix：矩阵乘法</li><li>inv_matrix：矩阵求逆</li><li>tran_matrix：矩阵转置</li></ul><h3 id="MPU6050滤波"><a href="#MPU6050滤波" class="headerlink" title="MPU6050滤波"></a>MPU6050滤波</h3><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><script type="math/tex; mode=display">X = \begin{bmatrix}angle \\ bias\end{bmatrix}</script><p>​    选择<strong>angle</strong>和<strong>bias</strong>作为状态变量，其中angle为角度，bias为陀螺仪的零漂。bias就是在传感器静止时也会有的输出的角速度值，这个只是不确定的，而且会变化。但是即使我们随便给它一个初值，最终也会随着迭代次数的增加收敛到真实值附近</p><p><img src="https://s2.loli.net/2022/12/12/i3baZ5zcTdPnUXV.png" alt="零漂收敛.png"></p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><script type="math/tex; mode=display">X^-_k = \begin{bmatrix}angle \\bias\end{bmatrix}=\begin{bmatrix}1 & -dt \\0 & 1 \\\end{bmatrix}X_{k-1}+\begin{bmatrix}gyro*dt \\0\end{bmatrix}</script><h4 id="先验协方差矩阵"><a href="#先验协方差矩阵" class="headerlink" title="先验协方差矩阵"></a>先验协方差矩阵</h4><script type="math/tex; mode=display">P^-_k = \begin{bmatrix}1 & -dt \\ 0 & 1\\\end{bmatrix}P^-_{k-1}\begin{bmatrix}1 & 0 \\-dt & 1 \\\end{bmatrix}+\begin{bmatrix}Q_{angle} & 0 \\0 & Q_{bias} \\\end{bmatrix}</script><h4 id="测量方程"><a href="#测量方程" class="headerlink" title="测量方程"></a>测量方程</h4><p>传入的只有滤波之前的角度值，故有</p><script type="math/tex; mode=display">Z = HX + V \\H = \begin{bmatrix}1 & 0\end{bmatrix}</script><p>这里的原始角度值是由IMU的<strong>三轴加速度值</strong>直接解算而来。</p><p>后面的几个方程就没什么变化了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>​    感谢大家耐心看完了本篇博客，欢迎大家分享；由于我自己也是初学者，对卡尔曼滤波的理解还不算深入，难免会有不完善之处，这篇文章作为一篇笔记由于大家分享，也欢迎大家批评指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kalman Filter </tag>
            
            <tag> 滤波算法 </tag>
            
            <tag> 控制方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC &amp; PCA9685</title>
      <link href="/2022/11/01/%E8%88%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/01/%E8%88%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    有些时候需要同时驱动多个舵机，需要为每一个舵机调制出对应的<strong>PWM</strong>脉冲信号；如果舵机很多的话，会占用主控的很多资源。幸运的是有这样一款模块，只需要<strong>两个GPIO口</strong>，便可以通过<strong>I^2^C通信协议</strong>控制<strong>16</strong>路舵机（事实上可以串联多个模块，控制更多舵机）。在这里记录一下其使用方法和代码实现方法。</p><h1 id="I-2-C通讯协议"><a href="#I-2-C通讯协议" class="headerlink" title="I^2^C通讯协议"></a>I^2^C通讯协议</h1><p>一篇介绍的很详细的文章：<a href="https://zhuanlan.zhihu.com/p/362287272">一文看懂I2C协议 - 知乎 (zhihu.com)</a></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>这里附上较为权威的文件链接</p><ul><li><a href="https://semitia.top/upload_flies/TI_I2C_slva704.pdf">https://semitia.top/upload_flies/TI_I2C_slva704.pdf</a></li><li><a href="https://semitia.top/upload_flies/NXP_I2C_UM10204.pdf">https://semitia.top/upload_flies/NXP_I2C_UM10204.pdf</a></li><li><a href="https://semitia.top/upload_flies/ZLG_I2C.pdf">https://semitia.top/upload_flies/ZLG_I2C.pdf</a></li></ul></div><p>此篇笔记则是结合<strong>《TI_I2C_slva704》</strong>和<strong>代码</strong>简单记录一些基本功能。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    <strong>IIC</strong>使用两个接口<strong>(SCL和SDA)</strong>进行<strong>半双工通信</strong>。分为<strong>主机（Master)</strong>和<strong>从机（Slave device）</strong>，每个设备有自己特定的<strong>地址</strong>，一个设备有一个或多个寄存器储存数据，主机通过IIC总线对设备及其寄存器进行读写和配置。</p><h2 id="主机访问从机的一般流程"><a href="#主机访问从机的一般流程" class="headerlink" title="主机访问从机的一般流程"></a>主机访问从机的一般流程</h2><h3 id="发送数据："><a href="#发送数据：" class="headerlink" title="发送数据："></a>发送数据：</h3><ol><li>主机发送<strong>START</strong>信号和<strong>设备地址</strong>来指定一个设备</li><li>主机发送数据</li><li>主机发送<strong>STOP</strong>信号</li></ol><h3 id="接收数据："><a href="#接收数据：" class="headerlink" title="接收数据："></a>接收数据：</h3><ol><li>主机发送<strong>START</strong>信号和<strong>设备地址</strong>来指定一个设备</li><li>主机指定要读取的<strong>寄存器</strong></li><li>主机读取数据</li><li>主机发送<strong>STOP</strong>信号</li></ol><h2 id="START和STOP信号"><a href="#START和STOP信号" class="headerlink" title="START和STOP信号"></a>START和STOP信号</h2><ul><li><strong>STATRT</strong>：在<strong>SCL</strong>拉高的情况下，<strong>SDA</strong>电平由高变低，即<strong>下降沿</strong></li><li><strong>STOP</strong>：在<strong>SCL</strong>拉高的情况下，<strong>SDA</strong>电平由低变高，即<strong>上升沿</strong></li></ul><p><img src="https://s2.loli.net/2022/11/02/Rkjp2zrVq8NGIy9.png" alt="IIC_1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();     </span><br><span class="line">IIC_SDA=<span class="number">1</span>;    </span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SDA=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><code>SDA_OUT();</code>：将<strong>SDA</strong>端口设置为输出模式；在切换读写状态的时候，也要修改IO口配置</li><li><code>IIC_SCL=0;</code>：IIC总线接上拉电阻，故默认<strong>高电平</strong>状态为<strong>总线空闲</strong>状态；主机接下来要发送指令，所以要拉低电平，主机控制住总线。</li></ul><h4 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();<span class="comment">//sdaÏßÊä³ö</span></span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">IIC_SDA=<span class="number">0</span>;<span class="comment">//STOP:when CLK is high DATA change form low to high</span></span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>; </span><br><span class="line">IIC_SDA=<span class="number">1</span>;<span class="comment">//·¢ËÍI2C×ÜÏß½áÊøÐÅºÅ</span></span><br><span class="line">delay_us(<span class="number">4</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ACK-NACK-有无应答"><a href="#ACK-NACK-有无应答" class="headerlink" title="ACK/NACK 有无应答"></a>ACK/NACK 有无应答</h2><p>​    在完成一个字节的信息传输后，<strong>接收方</strong>可以发送<strong>ACK</strong>以告知发送方数据被成功接收；也可以选择不发送。在接收方发送ACK之前，发送方必须释放SDA线；接收方<strong>拉低SDA</strong>以发送ACK。</p><p>​    倘若在ACK位SDA仍然为高电位，则认为是<strong>NACK——无应答</strong>，无应答的一些情况：</p><ul><li>接收方没有做好接收的准备</li><li>接收方无法理解接收到的数据</li><li>接收方无法再接收更多数据</li><li>主机作为接收方完成了数据接收</li></ul><p>​    在这样的规定下，如果出现了主机数据接收失败的情况的话该如何判定呢？是不是冲突了呢？或许主机可以通过编程判定接受失败，进而选择是否重新请求数据。</p><p><img src="https://s2.loli.net/2022/11/02/4eo2YpZhjNr7V5s.png" alt="IIC_2.png"></p><h2 id="WRITE写操作"><a href="#WRITE写操作" class="headerlink" title="WRITE写操作"></a>WRITE写操作</h2><ul><li><p>数据传输以<strong>一个字(8bits)</strong>节为单位，最先发送<strong>MSB</strong>；</p></li><li><p>在<strong>STOP和START</strong>信号外需保证<strong>SDA</strong>只在<strong>SCL</strong>为<strong>低电平</strong>时发生跳变；<strong>SCL高</strong>时保证<strong>SDA</strong>稳定以读取数据。</p></li></ul><p>注：</p><p><strong>MSB &amp; LSB</strong>：</p><blockquote><p>MSB stands for most significant bit, while LSB is least significant bit. In binary terms, the MSB is the bit that has the greatest effect on the number, and it is the left-most bit. For example, for a binary number 0011 0101, the Most Significant 4 bits would be 0011. The Least Significant 4 bits would be 0101.</p></blockquote><h3 id="协议流程"><a href="#协议流程" class="headerlink" title="协议流程"></a>协议流程</h3><ol><li>主机发送<strong>START</strong>信号</li><li>主机发送<strong>7bits设备地址</strong></li><li><strong>R/W</strong>位置0——写0，读1</li><li>等待应答</li><li>主机发送<strong>从设备寄存器地址</strong></li><li>等待应答</li><li>写入数据</li><li>等待应答</li><li>主机发送<strong>STOP</strong>信号，操作结束。</li></ol><p><img src="https://s2.loli.net/2022/11/02/zMwCgD3Qt1vx5cy.png" alt="IIC_3.png"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>此处仅为发送一个字节的流程，完整流程请参考下方PCA9685实战代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Send_Byte</span><span class="params">(u8 txd)</span></span><br><span class="line">&#123;                        </span><br><span class="line">    u8 t;   </span><br><span class="line">SDA_OUT();     </span><br><span class="line">    IIC_SCL=<span class="number">0</span>;<span class="comment">//À­µÍÊ±ÖÓ¿ªÊ¼Êý¾Ý´«Êä</span></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">    &#123;              </span><br><span class="line">        IIC_SDA=(txd&amp;<span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>;</span><br><span class="line">        txd&lt;&lt;=<span class="number">1</span>;   </span><br><span class="line">delay_us(<span class="number">2</span>); </span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>); </span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="READ读操作"><a href="#READ读操作" class="headerlink" title="READ读操作"></a>READ读操作</h2><h3 id="协议流程-1"><a href="#协议流程-1" class="headerlink" title="协议流程"></a>协议流程</h3><ol><li>前两个字节与写操作相同</li><li>主机重复发送一次<strong>START</strong>信号</li><li>主机发送从设备地址</li><li><strong>R/W置</strong><span class='p red'>1</span>——读操作</li><li>等待应答</li><li>主机读取数据</li><li>主机<strong>不发送</strong>应答信号</li><li>主机发送<strong>STOP</strong>信号</li></ol><p><img src="https://s2.loli.net/2022/11/02/hQueywRLE3xf4v5.png" alt="IIC_4.png"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>同样是只读取一个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">IIC_Read_Byte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i,receive=<span class="number">0</span>;</span><br><span class="line">SDA_IN();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++ )</span><br><span class="line">&#123;</span><br><span class="line">        IIC_SCL=<span class="number">0</span>; </span><br><span class="line">        delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        receive&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(READ_SDA)receive++;   </span><br><span class="line">delay_us(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">        IIC_NAck();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        IIC_Ack();</span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="PCA9685芯片"><a href="#PCA9685芯片" class="headerlink" title="PCA9685芯片"></a>PCA9685芯片</h1><p>芯片手册：<a href="https://semitia.top/upload_flies/PCA9685.pdf">https://semitia.top/upload_flies/PCA9685.pdf</a></p><p>芯片手册的内容比较多，所以在这里只记录一些使用指导性相对更高的一些内容（主要参考第七小节）。</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><h3 id="设备地址"><a href="#设备地址" class="headerlink" title="设备地址"></a>设备地址</h3><p><img src="https://s2.loli.net/2022/11/02/zYo4QDi6RUrBw1L.png" alt="IIC_5.png"></p><p>在默认情况下设备地址是<strong>0x40</strong>，如果算上最后<strong>R/W</strong>位的话就是<strong>0x80</strong>。</p><p>在模块上能够看到六个留空的焊点，可以选择把部分焊点焊上，设备的地址对应位就会被<strong>置一</strong>。比如把<strong>第0位</strong>焊上，地址就变为了<strong>1000001</strong>。</p><h3 id="寄存器地址"><a href="#寄存器地址" class="headerlink" title="寄存器地址"></a>寄存器地址</h3><p>这是部分寄存器总览表，一共有16个led。各个寄存器的地址也都很清楚地列了出来</p><p><img src="https://s2.loli.net/2022/11/02/mXtORuGvFCWUkNr.png" alt="IIC_6.png"></p><h2 id="部分寄存器介绍"><a href="#部分寄存器介绍" class="headerlink" title="部分寄存器介绍"></a>部分寄存器介绍</h2><h3 id="MODE1寄存器"><a href="#MODE1寄存器" class="headerlink" title="MODE1寄存器"></a>MODE1寄存器</h3><p><img src="https://s2.loli.net/2022/11/02/oJsCdm8rMcOBLFj.png" alt="IIC_7.png"></p><p>比较常用的是<strong>第四位</strong>，即<strong>SLEEP</strong>位，因为在读写其他寄存器的时候会需要将芯片休眠，待会在原码介绍中也会见到。</p><p><img src="https://s2.loli.net/2022/11/02/KA7VLulbwsmYzqn.png" alt="IIC_8.png"></p><h3 id="LED-ON-OFF-H-L"><a href="#LED-ON-OFF-H-L" class="headerlink" title="LED_ON_OFF_H_L"></a>LED_ON_OFF_H_L</h3><p>每个PWM(led)输出端口的配置对应四个寄存器</p><ul><li>LEDn_ON_H</li><li>LEDn_ON_L</li><li>LEDn_OFF_H</li><li>LED_OFF_L</li></ul><p>每个寄存器是<strong>8位</strong>寄存器，但是<strong>ON</strong>或<strong>OFF</strong>只会分别储存<strong>十二位</strong>的数据，也就是<em>L</em>存8位，<em>H</em>存4位</p><p><img src="https://s2.loli.net/2022/11/02/lFafpNvyibHqVjo.png" alt="IIC_9.png"></p><p>具体的寄存器数据和PWM波形的关系如下</p><blockquote><p>​    <strong>ON</strong>和<strong>OFF</strong>分别存储着范围<strong>0~4096</strong>的值(确实是4096而非4095)，我们把两个值记作<strong>cnt_on, cnt_off</strong>吧。有一个计数器从0计数到<strong>4095</strong>，我们把计数器的值记作<strong>CNT</strong>。</p><p>一般情况下，都是<code>cnt_on &lt; cnt_off</code>：</p><ul><li>当<code>CNT == cnt_on</code>时，PWM波<strong>由低变高</strong>；</li><li>当<code>CNT == cnt_off</code>时，PWM波<strong>由高变低</strong>；</li></ul><p>当<code>cnt_off &lt; cnt_on</code>时，在第一个周期内<code>CNT == cnt_off</code>不做变化。</p><p>可以看出，控制精度是<strong>1/4096</strong>周期。</p></blockquote><p>具体的PWM调制方法我们结合官方手册里面给出的两个例子就很容易理解了：</p><p><img src="https://s2.loli.net/2022/11/02/e9yZhwCiX5AImpc.png" alt="IIC_10.png"></p><p>（这里我感觉 <em>Fig 7</em> 图里的<strong>819</strong>是不是应该是<strong>410</strong>）</p><p><img src="https://s2.loli.net/2022/11/02/82lKZfsdSYL9EnW.png" alt="IIC_11.png"></p><h3 id="PRE-SCALE"><a href="#PRE-SCALE" class="headerlink" title="PRE_SCALE"></a>PRE_SCALE</h3><p><img src="https://s2.loli.net/2022/11/02/Y9Ch54OApUxLM8e.png" alt="IIC_12.png"></p><p>​    <strong>PRE_SCALE</strong>寄存器用以调制PWM频率。驱动舵机的话我们需要<strong>20ms</strong>的脉冲，频率为<strong>50Hz</strong>。</p><p>​    如果学习过STM32用定时器输出PWM的话应该很容易理解，只不过这里的<strong>自动重装载值</strong>固定为4096。</p><p>​    时钟给出的是<strong>25MHz</strong>的频率，如果我们设置<strong>n分频</strong>，那么<strong>计数器</strong>就会每过<strong>$\frac{n}{25000000}$</strong>秒计数一次，那么$T_n = \frac{4096n}{25000000}$秒就是一个周期。假如我们要<strong>50Hz</strong>的脉冲，那么周期应该是<strong>20ms</strong>，令$T_n == 0.02s$，解得n，那么分频系数设置为<strong>n-1</strong>即可。</p><p>​    为什么要减去一呢？因为不分频其实也就是<strong>一分频</strong>，但是默认<code>prescale value == 0</code>时是不分频。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Write写数据"><a href="#Write写数据" class="headerlink" title="Write写数据"></a>Write写数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_write1</span><span class="params">(u8 adr,u8 data)</span></span><br><span class="line">&#123; </span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(adr);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(data);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/02/zMwCgD3Qt1vx5cy.png" alt="IIC_3.png"></p><p>这里贴上之前的流程图方便比对。</p><h3 id="Read读数据"><a href="#Read读数据" class="headerlink" title="Read读数据"></a>Read读数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">pca_read1</span><span class="params">(u8 adr)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 data;</span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(adr);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1|<span class="number">0x01</span>);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">data=IIC_Read_Byte(<span class="number">0</span>);</span><br><span class="line">IIC_Stop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/02/hQueywRLE3xf4v5.png" alt="IIC_4.png"></p><h3 id="设置分频系数"><a href="#设置分频系数" class="headerlink" title="设置分频系数"></a>设置分频系数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_setfreq1</span><span class="params">(<span class="type">float</span> freq)</span> </span><br><span class="line">&#123;</span><br><span class="line">u8 prescale,oldmode,newmode;</span><br><span class="line"><span class="type">double</span> prescaleval;</span><br><span class="line">freq *= <span class="number">0.92</span>; </span><br><span class="line">prescaleval = <span class="number">25000000</span>;</span><br><span class="line">prescaleval /= <span class="number">4096</span>;</span><br><span class="line">prescaleval /= freq;</span><br><span class="line">prescaleval -= <span class="number">1</span>;</span><br><span class="line">prescale =<span class="built_in">floor</span>(prescaleval + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">oldmode = pca_read1(pca_mode1); <span class="comment">//获取之前mode寄存器配置状态</span></span><br><span class="line"></span><br><span class="line">newmode = (oldmode&amp;<span class="number">0x7F</span>) | <span class="number">0x10</span>; <span class="comment">// 睡眠模式</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, newmode); <span class="comment">// 进入睡眠</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_pre, prescale); <span class="comment">// 设置分频系数</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, oldmode); <span class="comment">//写回原来</span></span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, oldmode | <span class="number">0xa1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意手册里也多次强调，<span class='p red'>只有在设备进入睡眠模式之后才能修改分频系数</span></p><p>这里需要了解一下<strong>MODE1</strong>寄存器里的<emp>RESTART</emp>位</p><div class="note info modern"><p>在<strong>不停止PWM通道输出</strong>的情况下将设备设置为sleep模式，<strong>RESTART</strong>位会在一个PWM周期后被置1，<strong>LED</strong>寄存器里面的数据会被保存。想要重启，向<strong>RESTART</strong>位写1即可，此时该位会被自动<strong>置0</strong>。</p></div><p>​    当然，在这段代码中还设置了<strong>ALLCALL、AL</strong>位。</p><h3 id="调制PWM占空比"><a href="#调制PWM占空比" class="headerlink" title="调制PWM占空比"></a>调制PWM占空比</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_setpwm1</span><span class="params">(u8 num, u32 on, u32 off)</span> </span><br><span class="line">&#123;</span><br><span class="line">pca_write1(LED0_ON_L+<span class="number">4</span>*num,on);</span><br><span class="line">pca_write1(LED0_ON_H+<span class="number">4</span>*num,on&gt;&gt;<span class="number">8</span>);</span><br><span class="line">pca_write1(LED0_OFF_L+<span class="number">4</span>*num,off);</span><br><span class="line">pca_write1(LED0_OFF_H+<span class="number">4</span>*num,off&gt;&gt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个“LED”有四个寄存器，所以<strong>第n个</strong>led地址为<strong>LED0</strong>地址加<strong>4n</strong>。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>感谢大家耐心看完了本篇博客，欢迎大家分享；完整的工程可以在我的<strong>GiHub</strong>仓库找到。由于本人水平有限，可能有不完善之处，欢迎大家批评指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> IIC </tag>
            
            <tag> 舵机 </tag>
            
            <tag> PCA9685 </tag>
            
            <tag> 通讯协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的位运算</title>
      <link href="/2022/10/29/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/10/29/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="有意思的操作"><a href="#有意思的操作" class="headerlink" title="有意思的操作"></a>有意思的操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>位运算是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。常用的位运算符号包括：“∧” 按位异或（取不同）、“&amp;” 按位与（取交）、“|” 按位或（取并）、“~” 取反、“&lt;&lt;” 算术左移和 “&gt;&gt;” 算术右移。</p><ul><li>n &amp; (n - 1) 可以去除 n 的位级表示中最低的那一位，例如对于二进制表示 11110100 ，减去 1 得到 11110011，这两个数按位与得到 11110000。</li><li>n &amp; (-n) 可以得到 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100。</li></ul><h2 id="获取二进制数中1的个数"><a href="#获取二进制数中1的个数" class="headerlink" title="获取二进制数中1的个数"></a>获取二进制数中1的个数</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_contains</span><span class="params">(u32 s,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(((s&gt;&gt;i) &amp; <span class="number">0x01</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_size0</span><span class="params">(u32 s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n += <span class="built_in">bitset_contains</span>(s,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>int bitset_contains(u32 s,int i)</code>就是判断s的<strong>第i位</strong>（从<strong>第0位</strong>开始计起）是否为1。</p><p><code>int bitset_size0(u32 s)</code>就是一位位看是不是1，是就<strong>计数加一</strong>。</p><p>最后效果就是<strong>统计s为1的位数</strong></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_size</span><span class="params">(u32 s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = (s &amp; <span class="number">0x55555555</span>) + ((s&gt;&gt;<span class="number">1</span>) &amp; <span class="number">0x55555555</span>); <span class="comment">//01010101010101010101010101010101</span></span><br><span class="line">    s = (s &amp; <span class="number">0x33333333</span>) + ((s&gt;&gt;<span class="number">2</span>) &amp; <span class="number">0x33333333</span>); <span class="comment">//00110011001100110011001100110011</span></span><br><span class="line">    s = (s &amp; <span class="number">0x0f0f0f0f</span>) + ((s&gt;&gt;<span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>); <span class="comment">//00001111000011110000111100001111</span></span><br><span class="line">    s = (s &amp; <span class="number">0x00ff00ff</span>) + ((s&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>); <span class="comment">//00000000111111110000000011111111</span></span><br><span class="line">    s = (s &amp; <span class="number">0x0000ffff</span>) + ((s&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);<span class="comment">//00000000000000001111111111111111</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    一般来说，看到这样的<strong>十六进制</strong>数就会不由自主地想把它们转换为<strong>二进制</strong>看看。转换之后呢就能稍微看出一些端倪了。😁</p><p>​    <code>0x55555555</code>将s分为<strong>两个一组</strong>，每一组两位数。其实就是==分别判断一组里的两位数是不是1==。</p><ul><li>都是1，则变为<strong>1+1=10</strong>；</li><li>只有一个，就变为<strong>01</strong>；</li><li>没有则为<strong>0</strong></li></ul><p>​    变换完了之后呢，储存的就是这一组里 <em>“1”</em> 的个数。</p><p>​    <code>0x33333333</code>则是将s分为<strong>四个一组</strong>，一组里同样是<strong>两个数</strong>，只不过一个数是<strong>两位</strong>。操作的结果呢就是<strong>将两个数各自两个位里1的个数</strong>加起来，即<strong>四个位里1的个数</strong>。</p><p>​    <code>0x0f0f0f0f</code>将s分为<strong>八个一组</strong>，统计<strong>八个位里1的个数</strong></p><p>​    <code>0x00ff00ff</code>将s分为<strong>十六个一组</strong>，统计<strong>十六位里1的个数</strong></p><p>​    <code>0x0000ffff</code>将整个32位的s看作一组，统计<strong>所有1的个数</strong></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>​    两种方法比较来看，明显是第一种方法简单易懂，也容易想到；但是从运算效率上来看，第二种远远高于第一种。</p><h1 id="遥控数据解析"><a href="#遥控数据解析" class="headerlink" title="遥控数据解析"></a>遥控数据解析</h1><p><img src="https://s2.loli.net/2022/10/29/7vaHiBuG1CXbV9m.png" alt="遥控协议.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RemoteReceive</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint8_t</span> *<span class="type">const</span> ptr_sbus_rx_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr_sbus_rx_buffer == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    RC_Ctl.rc.ch0 = (ptr_sbus_rx_buffer[<span class="number">0</span>] | (ptr_sbus_rx_buffer[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>)) &amp;<span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch1 = (ptr_sbus_rx_buffer[<span class="number">1</span>] &gt;&gt; <span class="number">3</span>) | (ptr_sbus_rx_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">5</span>) &amp; <span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch2 = (ptr_sbus_rx_buffer[<span class="number">2</span>] &gt;&gt; <span class="number">6</span>) | (ptr_sbus_rx_buffer[<span class="number">3</span>] &lt;&lt; <span class="number">2</span>) | (ptr_sbus_rx_buffer[<span class="number">4</span>] &lt;&lt; <span class="number">10</span>) &amp; <span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch3 = (ptr_sbus_rx_buffer[<span class="number">4</span>] &gt;&gt; <span class="number">1</span>) | (ptr_sbus_rx_buffer[<span class="number">5</span>] &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x07ff</span>; </span><br><span class="line">    RC_Ctl.rc.s1 = (ptr_sbus_rx_buffer[<span class="number">5</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x0003</span>;</span><br><span class="line">    RC_Ctl.rc.s2 = (ptr_sbus_rx_buffer[<span class="number">5</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0003</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括来说就是依照<strong>通信协议</strong>利用<strong>位移运算</strong>和<strong>或、与运算</strong>，将数据从<strong>ptr_sbus_rx_buffer</strong>剥离提取至<strong>RC_Ctl.rc.xx</strong>中。</p><ul><li>位移操作后，需要提取的数据在<strong>后11位(或后2位)</strong>，<strong>0x07ff</strong>换成二进制就是<strong>0000011111111111</strong>，过滤掉不需要的位数；<strong>0x0003</strong>同理</li><li><strong>ch0</strong>获取buffer[0]<strong>全部八位</strong>和buffer[1]<strong>低三位</strong></li><li><strong>ch1</strong>获取buffer[1]<strong>高五位</strong>和buffer[2]<strong>低六位</strong></li><li><strong>ch2</strong>获取buffer[2]<strong>高两位</strong>和buffer[3]<strong>全部八位</strong>和buffer[4]<strong>低一位</strong></li><li><strong>ch3</strong>获取buffer[4]<strong>高七位</strong>和buffer[5]<strong>低四位</strong></li><li><strong>s1</strong>获取buffer[5]<strong>高两位</strong></li><li><strong>s2</strong>获取buffer[5]<strong>第五第六位</strong></li></ul><p>不知道是不是搞反了，根据协议来看是<strong>s1</strong>获取buffer[5]<strong>第五第六位</strong>，<strong>s2</strong>获取buffer[5]<strong>高两位</strong></p><h1 id="位运算实现四则运算"><a href="#位运算实现四则运算" class="headerlink" title="位运算实现四则运算"></a>位运算实现四则运算</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    在平时手算的时候我们经常会<strong>列竖式</strong>，先不考虑进位，只看<strong>和</strong>和<strong>相加的两个数</strong>同位的数，把进位数写小一点记在横线上方。<strong>计算下一位的时候再加上上一位的进位。</strong></p><p>​    所以在程序中也是模拟这样一个思路：</p><ul><li>先不看进位，得到一个和；记下进位</li><li>进位在与和相加，不看进位得到一个新的和；同时也得到新的进位</li><li>不断迭代递推，直到不再产生新的进位</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加法函数</span></span><br><span class="line"><span class="comment"> * @param ini_x 加数1</span></span><br><span class="line"><span class="comment"> * @param ini_y 加数2</span></span><br><span class="line"><span class="comment"> * @return 补码形式的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">u32 <span class="title">addition</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不需要转换为补码</span></span><br><span class="line">    u32 x = ini_x, y = ini_y;</span><br><span class="line">    <span class="comment">//和，进位</span></span><br><span class="line">    u32 ans,carry;</span><br><span class="line">    ans = x ^ y;</span><br><span class="line">    carry = (x &amp; y) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//不断获取进位与不考虑进位的和，迭代相加，直至进位为0</span></span><br><span class="line">    <span class="keyword">while</span>(carry != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        u32 i = ans, j = carry;</span><br><span class="line">        ans = i ^ j;</span><br><span class="line">        carry = (i &amp; j) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DEBUG调试</span></span><br><span class="line">    <span class="comment">//printf(&quot;DE<span class="doctag">BUG:</span> %d add %d = %d\r\n&quot;,ini_x,ini_y,ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以发现，</p><ul><li>不看进位得到的和其实就是<strong>两数异或</strong>，即<code>ans = x ^ y;</code>；</li><li>进位即<strong>两数相与再左移一位</strong>，即<code>carry = (x &amp; y) &lt;&lt; 1;</code></li></ul><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>​    <strong>a-b</strong> 即 <strong>a+(-b)</strong></p><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    可以将被乘数不断加<strong>乘数次数</strong>的自己。但是这样效率不高。同样是模拟手算的思想，从<strong>乘数的最低位</strong>到<strong>最高位</strong>，在<strong>第i位</strong>，即给最后乘积贡献的值为</p><p>==被乘数 <em> 乘数[i] </em> (进制数)^(i-1)^==</p><p>​    在这个算法下不再能直接用补码参与计算，所以要换成原码并去除符号位。在开始的时候根据两数记下乘积的正负值，计算完毕之后再赋回去。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 乘法</span></span><br><span class="line"><span class="comment"> * @param ini_x </span></span><br><span class="line"><span class="comment"> * @param ini_y </span></span><br><span class="line"><span class="comment"> * @return u32 积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">u32 <span class="title">multiplication</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> negative_flag=<span class="number">0</span>;</span><br><span class="line">    u32 ans=<span class="number">0</span>, x=ini_x, y=ini_y;</span><br><span class="line">    <span class="comment">//判断积正负</span></span><br><span class="line">    <span class="keyword">if</span>( ( (x&amp;<span class="number">0x80000000</span>) &amp;&amp; !(y&amp;<span class="number">0x80000000</span>) )||( !(x&amp;<span class="number">0x80000000</span>) &amp;&amp; (y&amp;<span class="number">0x80000000</span>) ) ) &#123;negative_flag=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">//要转换为原码并去掉符号位</span></span><br><span class="line">    x = <span class="built_in">back_com</span>(x);</span><br><span class="line">    y = <span class="built_in">back_com</span>(y);</span><br><span class="line">    x &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    y &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="comment">//借鉴竖乘法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">31</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">0x01</span>) &#123;ans = <span class="built_in">addition</span>(ans,x);&#125;</span><br><span class="line">        y = y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        x = x&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span>) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加上正负号</span></span><br><span class="line">    <span class="keyword">if</span> (negative_flag) </span><br><span class="line">    &#123;</span><br><span class="line">        ans |= <span class="number">0x80000000</span>;<span class="comment">//这个时候依然是原码，想直接用%d，要转换为补码</span></span><br><span class="line">        ans = <span class="built_in">get_com</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DEBUG调试</span></span><br><span class="line">    <span class="comment">//printf(&quot;DE<span class="doctag">BUG:</span> %d multiply %d = %d\r\n&quot;,ini_x,ini_y,ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>​    因为除法有<strong>商</strong>和<strong>余数</strong>，所以用了一个结构体方便存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 除法答案结构体</span></span><br><span class="line"><span class="comment"> * @param ans 商</span></span><br><span class="line"><span class="comment"> * @param mod 余数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__ans_division_t</span>&#123;</span><br><span class="line">    u32 ans;</span><br><span class="line">    u32 mod;</span><br><span class="line">&#125;<span class="type">ans_division_t</span>;</span><br></pre></td></tr></table></figure><h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    也是模拟手算流程，在理解了乘法的实现思路后便很容易理解。</p><ul><li>将被除数不断<strong>进位</strong>，即乘上<strong>进制数</strong>，直到恰好比被除数小。</li><li>用被除数除以<strong>进位后的除数</strong>得到<strong>商</strong>（为了区别最终的商把它叫做<em>小商</em>吧），同时<strong>商</strong>加上==小商*进制数^(进位次数)^==</li><li>被除数不断<strong>退位</strong>（除以进制数），同时重复上述操作，直到回到最初大小，即<strong>进位数为0</strong></li></ul><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 除法</span></span><br><span class="line"><span class="comment"> * @param ini_x 被除数</span></span><br><span class="line"><span class="comment"> * @param ini_y 除数</span></span><br><span class="line"><span class="comment"> * @return ans_division_t* 答案指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ans_division_t</span> *<span class="title">division</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> negative_flag=<span class="number">0</span>;</span><br><span class="line">    u32 ans=<span class="number">0</span>, carry=<span class="number">0</span>, x=ini_x, y=ini_y;</span><br><span class="line">    <span class="type">ans_division_t</span> *ans_division;</span><br><span class="line">    ans_division = (<span class="type">ans_division_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">ans_division_t</span>));</span><br><span class="line">    <span class="keyword">if</span>( ( (x&amp;<span class="number">0x80000000</span>) &amp;&amp; !(y&amp;<span class="number">0x80000000</span>) )||( !(x&amp;<span class="number">0x80000000</span>) &amp;&amp; (y&amp;<span class="number">0x80000000</span>) ) ) &#123;negative_flag=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">//要转换为原码并去掉符号位</span></span><br><span class="line">    x = <span class="built_in">back_com</span>(x);</span><br><span class="line">    y = <span class="built_in">back_com</span>(y);</span><br><span class="line">    x &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    y &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="comment">//依然是模拟手除流程</span></span><br><span class="line">    <span class="comment">//除数不断进位直至比被除数大</span></span><br><span class="line">    <span class="keyword">while</span>(y &lt; x) </span><br><span class="line">    &#123;</span><br><span class="line">        y = y&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        carry = <span class="built_in">addition</span>(carry,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果能除，商就加上1&lt;&lt;carry，除数再不断右移直至回到本来大小。</span></span><br><span class="line">    <span class="keyword">while</span>(carry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=y)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">addition</span>(ans,<span class="number">1</span>&lt;&lt;carry);</span><br><span class="line">            x = <span class="built_in">addition</span>(x,-y);</span><br><span class="line">        &#125;</span><br><span class="line">        y = y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        carry = <span class="built_in">addition</span>(carry,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=y) </span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">addition</span>(ans,<span class="number">1</span>);</span><br><span class="line">        x = <span class="built_in">addition</span>(x,-y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    ans_division-&gt;ans = ans;</span><br><span class="line">    ans_division-&gt;mod = x;</span><br><span class="line">    <span class="keyword">return</span> ans_division;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    因为负数的余数比较奇怪，平时也不用，这里没有考虑在内。</p><h2 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h2><p>​    vscode 程序文件不能用中文命名。</p><p>​    在程序运行的时候使用补码记录。即便是<strong>usigned int</strong>，倘若<strong>scanf -9</strong>，对应二进制编码也是<strong>11111111111111111111111111110111</strong>。<strong>int</strong>型同样如此。</p><p>​    所以在运算的时候不需要人为的去转换为补码了，在这方面耽误了不少时间。</p><p>​    而对于同样的一串二进制编码，<strong>printf(“%d”)</strong>和<strong>printf(“%u”)</strong>输出结果是不一样的：%d会自动转换输出原码对应的有符号数；那%u则是会将这个补码当作原码直接换算成十进制输出。</p><p><img src="https://s2.loli.net/2022/10/29/PICY3lTj1Q4OKGS.png" alt="存储形式·1.png"></p><p><img src="https://s2.loli.net/2022/10/29/2SIuUTAJV9tDnqR.png" alt="存储形式2.png"></p><p>​    其余的就是一些逻辑漏洞了，不得不说VScode写代码还是比Keil舒服😁</p><h1 id="有关位运算的一些有意思的题目"><a href="#有关位运算的一些有意思的题目" class="headerlink" title="有关位运算的一些有意思的题目"></a>有关位运算的一些有意思的题目</h1><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗</p><p>示例 1:</p><blockquote><p>输入: [2,2,1]<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: [4,1,2,1,2]<br>输出: 4</p></blockquote></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>需要用到异或运算的性质：</p><p>a \^ a = 0<br>a \^ 0 = a<br>a \^ b \^ a = b \^ (a \^ a) = b（交换律和结合律）<br>所以只要全部异或最后结果就是答案</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num: nums)</span><br><span class="line">        ans ^= num;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h2><blockquote><p>给定一个非负整数 n，求从 0 到 n 的所有数字的二进制表达中，分别有多少个 1。</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题可以利用动态规划和位运算进行快速的求解。定义一个数组 dp，其中 dp [i] 表示数字 i 的二进制含有 1 的个数。对于第 i 个数字，如果它二进制的最后一位为 1，那么它含有 1 的个数 则为 dp [i-1] + 1；如果它二进制的最后一位为 0，那么它含有 1 的个数和其算术右移结果相同，即 dp [i&gt;&gt;1]。</p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(num+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        dp[i] = i &amp; <span class="number">1</span>? dp[i<span class="number">-1</span>] + <span class="number">1</span>: dp[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 等价于dp[i] = dp[i&amp;(i-1)] + 1;</span></span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> leecode </tag>
            
            <tag> 四则运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32仿真器程序烧录</title>
      <link href="/2022/10/22/STM32%E4%BB%BF%E7%9C%9F%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95/"/>
      <url>/2022/10/22/STM32%E4%BB%BF%E7%9C%9F%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>​    这几天捯饬了一下烧录程序的方法。主要还是<strong>SWD</strong>烧录，后续应该会尝试其他方法。我最开始的时候就不太会弄，即便手边有个仿真器也没有去用（后来就丢了😂），一直用的是<strong>ISP</strong>下载，不仅效率低，还不能在线调试。所以就整理了一下烧录方法。</p><span id="more"></span><h1 id="STM32仿真器程序烧录"><a href="#STM32仿真器程序烧录" class="headerlink" title="STM32仿真器程序烧录"></a>STM32仿真器程序烧录</h1><h3 id="SWD烧录"><a href="#SWD烧录" class="headerlink" title="SWD烧录"></a>SWD烧录</h3><p>SWD烧录是一种串行调试接口，出去供电与共地只需要两根线即可烧录调试</p><ul><li><strong>SWDIO：</strong> 串行数据线，用于数据的读出和写入;</li><li><strong>SWDCLK：</strong> 串行时钟线，提供所需要的时钟信号;</li></ul><p>下面是官方手册里烧录接口的引脚到GPIO口的映射关系</p><p><img src="https://s2.loli.net/2022/10/22/yxIoZNYtkJiqcvs.png" alt="映射关系.png"></p><p>这个是标准的接口排列，要注意的是按照插座边上的<strong>缺口向左</strong>的方向来查看。</p><p><img src="https://s2.loli.net/2022/10/22/NxQRpn7YiqlcZ9j.png" alt="swd_jtag插座.png"></p><p>一般情况下大多数单片机的 JTAG 接口和 SWDIO 接口是复用的，下面就是MINI板的原理图</p><p><img src="https://s2.loli.net/2022/10/22/hPSMBDUczKI6gOZ.png" alt="MINIswd插座.png"></p><h4 id="J-link"><a href="#J-link" class="headerlink" title="J-link"></a>J-link</h4><p>这个是比较常见也比较便宜的一款J-link，只有<strong>3.3vVCC、SWDIO、SWCLK、GND</strong>四根线，接线方式也十分的简单 。</p><p><img src="https://s2.loli.net/2022/10/22/jM2wkymvznOZtS9.jpg" alt="廉价j-link.jpg" style="zoom:50%;" /></p><p>像<strong>STM32C8T6、openCRP</strong>等等已经给出这四个接口的板子直接接上就好了</p><p><img src="https://s2.loli.net/2022/10/22/RGTbYQp9D8sUexm.jpg" alt="swd接口.jpg"></p><p>如果是20脚标准接口的话对照上面的图片找到对应的引脚直接接上即可。</p><p><img src="https://s2.loli.net/2022/10/22/EMTGCtwVFrAia9I.jpg" alt="廉价j-link接线.jpg"></p><p>​    如果实在找不到接口呢，直接把<strong>SWDIO、SWCLK</strong>接在<strong>PA13、PA14</strong>，再供电共地也是一样可以正常烧录的。    </p><p>​    经过测试呢，可以正常烧录，但是会<strong>供电不足</strong>。其中<strong>C8T6和openCRP</strong>的<strong>5V</strong>引脚电压不够，不过程序倒是可以正常运行；而<strong>MINI</strong>则是程序无法正常运行。这个具体情况还与各个板子的PCB设计有关。一般保险起见的话，需要<strong>额外供电</strong>。</p><h4 id="ST-link"><a href="#ST-link" class="headerlink" title="ST-link"></a>ST-link</h4><p>这也是很常见的一款ST-link</p><p><img src="https://s2.loli.net/2022/10/22/wQTMaopVhKlZq7g.jpg" alt="ST-link.jpg"></p><p>​    如果能直接用20脚的接口就很方便。不行的话也可以直接对照前面的图片把<strong>SWD</strong>对应的四根线接出来。</p><p>​    和板子的接线方法与之前都是一样的。</p><h4 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h4><p>这里用的是<strong>MDK5</strong>或者叫<strong>Keil</strong></p><ol><li>首先是点开<strong>魔术棒</strong>，选择对应的调试器<img src="https://s2.loli.net/2022/10/22/9botRpUDXFnAEqs.png" alt="config.png"></li><li>然后进入<strong>settings</strong>选择烧录方式和烧录速度<img src="https://s2.loli.net/2022/10/22/mxFHa8b52YNCoiJ.jpg" alt="config2.jpg"></li><li>然后可以检查一下烧录算法和自己的芯片型号是不是对应的。<img src="https://s2.loli.net/2022/10/22/1xEaqv8ANcwoJsX.jpg" alt="config3.jpg"></li><li>最后点击<strong>load</strong>按钮就可以烧录了。</li></ol><h3 id="ISP烧录"><a href="#ISP烧录" class="headerlink" title="ISP烧录"></a>ISP烧录</h3>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS串口通讯</title>
      <link href="/2022/08/29/ROS-USART-STM32/"/>
      <url>/2022/08/29/ROS-USART-STM32/</url>
      
        <content type="html"><![CDATA[<p>​    简单记录了尝试使用ROS与STM32通讯的过程，包括踩的一点坑，其中一些低级问题实在是有点让人哭笑不得😂</p><span id="more"></span><h1 id="ROS串口通讯"><a href="#ROS串口通讯" class="headerlink" title="ROS串口通讯"></a>ROS串口通讯</h1><h2 id="ROS串口通讯配置"><a href="#ROS串口通讯配置" class="headerlink" title="ROS串口通讯配置"></a>ROS串口通讯配置</h2><h3 id="Ubuntu20-04手动获取Serial包"><a href="#Ubuntu20-04手动获取Serial包" class="headerlink" title="Ubuntu20.04手动获取Serial包"></a>Ubuntu20.04手动获取Serial包</h3><h3 id="linux-ros-串口权限获取"><a href="#linux-ros-串口权限获取" class="headerlink" title="linux/ros 串口权限获取"></a>linux/ros 串口权限获取</h3><p>转载自<a href="https://blog.csdn.net/qq_16775293/article/details/82822851?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-0-82822851-blog-55259778.wap_relevant_multi_platform_whitelistv1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1">(9条消息) Linux/ROS——获取串口权限_不懂音乐的欣赏者的博客-CSDN博客</a></p><p>我这里的串口号是<strong>/dev/ttyTHS1</strong>，需要适当变动</p><h4 id="永久解决串口权限问题"><a href="#永久解决串口权限问题" class="headerlink" title="永久解决串口权限问题"></a>永久解决串口权限问题</h4><p>（我试了一下，但是失败了）</p><p>创建ttyUSB权限规则文件etc/udev/rules.d/70-ttyUSB.rules</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim -p /etc/udev/rules.d/70-ttyUSB.rules</span><br></pre></td></tr></table></figure><p>在<strong>70-ttyUSB.rules</strong>文件中写入下列代码</p><p>KERNEL==”ttyUSB*”, OWNER=”root”, GROUP=”root”, MODE=”0666”<br>保存即可,重启或注销用户在登录后生效</p><h4 id="临时获取串口权限"><a href="#临时获取串口权限" class="headerlink" title="临时获取串口权限"></a>临时获取串口权限</h4><p>先查看插入电脑的<strong>串口号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/ | grep ttyUSB</span><br></pre></td></tr></table></figure><p>知道串口号之后对指定串口赋予权限,以<strong>ttyUSB0</strong>为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+rw /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>不用重启即可生效</p><h3 id="代码编写问题"><a href="#代码编写问题" class="headerlink" title="代码编写问题"></a>代码编写问题</h3><h2 id="Jetson-nano与STM32通讯"><a href="#Jetson-nano与STM32通讯" class="headerlink" title="Jetson nano与STM32通讯"></a>Jetson nano与STM32通讯</h2><h3 id="jetson-nano串口"><a href="#jetson-nano串口" class="headerlink" title="jetson nano串口"></a>jetson nano串口</h3><p>引脚图，直接连即可。</p><p><img src="https://s2.loli.net/2022/10/22/x8melhw2bcjAgqV.jpg" alt="nano_usart.jpg"></p><h3 id="ROS与32串口通讯（ROS端）只能接收不能发送"><a href="#ROS与32串口通讯（ROS端）只能接收不能发送" class="headerlink" title="ROS与32串口通讯（ROS端）只能接收不能发送"></a>ROS与32串口通讯（ROS端）只能接收不能发送</h3><p>​    被这个问题卡了很久。根据情况描述，既然都能正常接收了为什么发送会失败呢？</p><h4 id="ROS端"><a href="#ROS端" class="headerlink" title="ROS端"></a>ROS端</h4><p>​    在ROS端串口输出一个字符串所用到的函数是<strong>ser.write（string value）</strong>，在定时器的回调函数里面同时调用。首先就是检查定时器回调函数是否被成功调用，读取数据和发送数据都是在这个回调函数里调用的，那么基本上是没问题的，<strong>ROS_INFO</strong>一下确实没问题。同理<strong>SendMsgs( )</strong>一样成功调用了。那至少能肯定，<strong>write( )</strong>函数肯定被调用了呀。</p><p>​    中间还出了一点岔子，就是代码中不小心打上了一点乱码，结果编译出问题。但是编译日志也没有报错，我虽然看着和原来的不一样，但是没有太在意。但是这就导致了之前改完代码后好几次编译都是不通过的，一直运行的也是那个有问题的节点代码。所以如果编译日志同平时比较为反常，要当心一下。</p><p>​    接下来将<strong>nano</strong>的<strong>TX，RX</strong>短接，判断到底是不是nano端的问题。发现确实能自己接收到自己的消息，那就没问题了</p><p>​    nano端没问题了，估计就是32端的问题了。ros只能接受不能发送，是不是<strong>rx</strong>接对了但<strong>tx</strong>接错了呢？</p><blockquote><p>nano 8：TX——RX：stm32 PA10</p><p>nano 10: RX——TX：stm32 PA9</p></blockquote><p>再检验一遍着实无误。</p><h4 id="32端"><a href="#32端" class="headerlink" title="32端"></a>32端</h4><p>​    32端没有再配置一个串口，使用<strong>oled屏</strong>DEBUG，nano端使用cutecom通讯正常，32能接收到消息，换成ros发消息后32却是一点反应都没有，那这个时候就想到看看<strong>串口中断函数</strong>到底有没有被调用，32到底有没有接收到消息。我在该函数里面加了些语句：如果串口中断函数被调用的话oled就会显示。</p><p>​    那结果是没有反应。</p><p>​    实际上控制oled显示的时候输完内容，要加个<strong>refresh</strong>。同时<strong>while( )</strong>里在不断<strong>Set_Z( )</strong>,里面也会不断更新内容然后refresh，所以其实串口中断是被调用了的，但在这样的情况下看不到反应。最后是使用keil的<strong>在线调试功能</strong>设置<strong>断点</strong>发现的，其实调用了。这个时候再看一下函数关于接收到的消息的过滤，其实正点原子也说过——<strong>发送新行</strong>。cutecom会，但ros不会。最终在要发送的字符串后面加上<strong>\r\n</strong>，DEBUG结束。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul><li>函数调用因oled错误使用检查失败。</li><li>不会使用Jlink在线调试</li><li>忽视了ros和cutecom细节上的输出差异。</li></ul><p>如果这三点有一点不出问题的话，或许都能够早些找到，错误。在此非常感谢师兄的指点！</p><h2 id="LattePanda与其Arduino通讯"><a href="#LattePanda与其Arduino通讯" class="headerlink" title="LattePanda与其Arduino通讯"></a>LattePanda与其Arduino通讯</h2><p>本来打算使用stm32进行下游设备的控制，但是发现LattePanda集成了一块<strong>arduino</strong>，不好好利用一下实在是太可惜了。</p><h3 id="Arduino-IDE安装"><a href="#Arduino-IDE安装" class="headerlink" title="Arduino IDE安装"></a>Arduino IDE安装</h3><p>​    在官网<a href="https://www.arduino.cc/en/software">Software | Arduino</a>下载Linux版本的安装包。可是下载<strong>2.0.0</strong>版本的会显示<em>没有可执行的软件</em>，所以最后选择了<strong>1.8.19</strong>。lattepanda对应的版本是<strong>linux 64 bits</strong></p><p>在安装目录得到了<strong>.tar.xz</strong>文件，运行解压命令</p><p><code>tar -xvf arduino-1.8.19-linux64.tar.xz</code></p><p>进入解压得到的安装目录，运行安装脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd arduino-1.8.19/</span><br><span class="line">sudo ./install.sh</span><br></pre></td></tr></table></figure><p>看到返回 <em>done!</em> 后安装成功</p><h3 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h3><p>​    平时用电脑给arduino烧录程序需要用一根数据线将二者连接起来。那在lattepanda上就相当于把这个数据线在板子上画好了，再把电脑和arduino粘一块儿</p><p>​    这个数据线对应的串口号是<strong>/dev/ttyACM0</strong>；</p><p>​    对应的芯片型号是<strong>ATmega32u4</strong>，这在IDE里面找不到，实际上也叫<strong>Arduino Leonardo</strong></p><p>​    之后就可以烧程序和通讯了。</p><h3 id="移植ROS包时遇到的一点小问题"><a href="#移植ROS包时遇到的一点小问题" class="headerlink" title="移植ROS包时遇到的一点小问题"></a>移植ROS包时遇到的一点小问题</h3>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> USART </tag>
            
            <tag> ROS </tag>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/16/hello-world/"/>
      <url>/2022/08/16/hello-world/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0858d2d5afc6e71fe61fde17e264b0ebd81b693504324bd451d5b9fe60576581">fa8b13601bdfbf35c816c536e1c943768052b894c07bef87cfe638eadf1a44fb1aca374ccee2eb92dae6b7862d437c4511b8689b401f36543ccb6ab66f72bf0286c6c052ef4e8c7a2ec491afed06f89a2c56b4c8675715f28bfe32cab7840fb26ae21f1cfad9201fc4ca976f5aa9b30b29f1d26800d88d671ada94dcd875d8b3edda1090b2911a1d9b0f465c5e9f8328c5cd48549be6f19403414d9688c6d62003ad856535e633eae2402819f2e0fc0bdf8686ed677e35bdac33f324558f92229db3f692da7bbac0d4cc6fe244237d3881e12c8f3413ef4e51a472e769d89c70bc4a1ae26a03a319d5b01811e30f63ee79c12b32110cdd2101b75c6de84c17f3be550357902045bf9f10615e4aa9f55c8e71d966ce60f9fed9ad627e1df8514777352c0054f33ed102972e4ca63e300ef09e350027436e85314696b7144fe22e8d4b9320a5ce45aca7f544bcbc99e60530d266d9835f87a6a0a07336f75ef08cbadda7e5b4d92dddf83aaaa1a2db7037efdfa3794b1b40d607fee759f6446124297bf0b0c1433f8089cf9f6bc53d63df6a398686aa826d1d784a5fe38e2b7abed2152e574dbd2a77b8f9bb28c18d34ee1915d33fd7092d81ef13ff30ae5ae174f042c7e083e83964e19562840a378af0c06d5ad47b8a740819d946e83b76d9e47e3b976708c03d087cb82be880643e23d138db94b4a4e7d64d0c03e5433d0dc7a95ccf86b3d1c11381f28a78d145297c943ae497edf7127d4a67bbaae900cd1f4b7237f62636f0080b07800702fd6023bb364450f4213fcbb06015f72d601d721e0fa5f9c65feefbddc6986cf86149c7018c45458bb7d201e63e3d475e9ee2c9643f0e36d3ba5b280f9d915ad8b88a5461af0a4e3a964d3fa4120340b848e62dd1682f6064e325d4abfef05e5b588920474cf8bf5da166c9d2f26a3177670d695aeba543ff6d4970a1cff53bb98490c6e1d7bf50eeb810306cd1919e2766e26ee66828b12168bc41b6fd3c6adb22cac57352a6b18a6dc68cca53ef0749db2b13480543a929b5e1a1439f22b7fe7b367c7088e3a6b9b3fbed26b1590eb01b493c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">举杯邀明月，对影成三人。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
