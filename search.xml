<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>卡尔曼滤波学习笔记</title>
      <link href="/2022/11/04/Kalman%20filter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/04/Kalman%20filter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    最近在学习卡尔曼滤波算法，这其中用到了一些数学和现代控制理论的知识。由于我在学习之前没有啥知识储备，在网上看了很多博客、花了很多时间之后依然是一种似懂非懂的感觉。终于找到了一些很棒的教程，感觉算是稍微理解了一些，整理了一些学习笔记，梳理思路，也方便日后查阅。</p><p><strong>教程链接</strong></p><ul><li><a href="https://www.bilibili.com/video/BV1ez4y1X7eR/?spm_id_from=333.788&amp;vd_source=0f383e93e945bca07eaef9a9ee5d9db3">【卡尔曼滤波器】1_递归算法_Recursive Processing_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1Rh41117MT/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0f383e93e945bca07eaef9a9ee5d9db3">从放弃到精通！卡尔曼滤波从理论到实践~_哔哩哔哩_bilibili</a></li><li><a href="https://blog.csdn.net/Yemiekai/article/details/116372288">https://blog.csdn.net/Yemiekai/article/details/116372288</a></li></ul><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><h3 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h3><blockquote><p>将<strong>方差、协方差</strong>在一个矩阵中表现出来，体现变量间的<strong>联动关系</strong></p></blockquote><p>假设有<strong>X,Y,Z</strong>三组数据，每组数据有<strong>n</strong>个</p><h4 id="方差："><a href="#方差：" class="headerlink" title="方差："></a>方差：</h4><script type="math/tex; mode=display">\sigma_x^2 = \frac{1}{n}\sum(x_i - \bar{x})^2</script><p>方差越大，数据波动越大</p><h4 id="协方差："><a href="#协方差：" class="headerlink" title="协方差："></a>协方差：</h4><script type="math/tex; mode=display">\sigma_x\sigma_y = \sigma_y\sigma_x = \frac{1}{n}\sum(x_i - \bar{}x)(y_i - \bar{y})</script><p>协方差越小，X,Y相关性越低</p><h4 id="协方差矩阵："><a href="#协方差矩阵：" class="headerlink" title="协方差矩阵："></a>协方差矩阵：</h4><script type="math/tex; mode=display">\begin{bmatrix}\sigma_x^2 & \sigma_x\sigma_y & \sigma_x\sigma_z \\ \sigma_y\sigma_x & \sigma_y^2 & \sigma_y\sigma_z \\ \sigma_z\sigma_x & \sigma_z\sigma_y & \sigma_z^2\\ \end{bmatrix}</script><h4 id="过渡矩阵"><a href="#过渡矩阵" class="headerlink" title="过渡矩阵"></a>过渡矩阵</h4><p>过渡矩阵<strong>a</strong>用以计算协方差矩阵<strong>P</strong>：</p><script type="math/tex; mode=display">P = \frac{1}{n}a^Ta</script><p>结合公式容易理解：(此处为3x3矩阵)</p><script type="math/tex; mode=display">a = \begin{bmatrix}x1 & y1 & z1 \\ x2 & y2 & z2 \\ x3 & y3 & z3 \\ \end{bmatrix} - \frac{1}{3}\begin{bmatrix}1 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \\ \end{bmatrix}\begin{bmatrix}x1 & y1 & z1 \\ x2 & y2 & z2 \\ x3 & y3 & z3 \\ \end{bmatrix}</script><p>被减数即为<strong>原矩阵</strong>，而减数则为<strong>平均值矩阵</strong></p><h3 id="状态空间方程"><a href="#状态空间方程" class="headerlink" title="状态空间方程"></a>状态空间方程</h3><script type="math/tex; mode=display">\hat{X}_k = A\hat{X}_{k-1} + Bu_{k-1} + W_{k-1}</script><script type="math/tex; mode=display">Z_k = HX_k + V_k</script><p><strong>变量说明：</strong></p><ul><li><script type="math/tex">\hat{X}_k</script>：实际状态值</li><li><script type="math/tex">\hat{X}_{k-1}</script>：上一时刻状态值</li><li>$u_k-1$：控制输入量</li><li><em>A、H、B</em>：转换矩阵</li><li>$Z_k$：测量值</li><li>$W_{k-1}$：过程噪声</li><li>$V_k$：测量噪声</li></ul><p><strong>关于传递方程：</strong></p><p>​    如果我们掌握了一个物体的运动规律，那么这个时刻的状态可以通过上一个时刻的状态计算出来。但是也不能保证完全精准，所以添加了<strong>过程噪声——W</strong></p><p>​    举个例子——经典的阻尼弹簧振子模型：</p><p><img src="https://s2.loli.net/2022/11/05/njC8ubrIcYQRiF9.jpg" alt="阻尼弹簧.jpg"></p><p>弹簧恢复力 = kX，阻力 = Bv。将X的导数v记作$\dot{X}$，X的二阶导a记作$\ddot{X}$，便可以得到：</p><script type="math/tex; mode=display">m\ddot{X} + B\dot{X} + kX = F</script><p>取状态变量<strong>X1为位移</strong>，<strong>X2为速度</strong>，F记为控制输入<strong>u</strong>，根据之前公式可得：</p><script type="math/tex; mode=display">\dot{X_1} = X_2</script><script type="math/tex; mode=display">\dot{X_2} = \ddot{X} = \frac{1}{m}u - \frac{B}{m}X_2 - \frac{k}{m}X_1</script><p>写成矩阵的形式就是：</p><script type="math/tex; mode=display">\begin{bmatrix} \dot{X_1} \\ \dot{X_2} \end{bmatrix} = \begin{bmatrix} 0 & 1 \\ -\frac{k}{m} & -\frac{B}{m} \end{bmatrix}\begin{bmatrix} X_1 \\ X_2 \end{bmatrix} + \begin{bmatrix} 0 \\ \frac{1}{m} \end{bmatrix}u</script><p>对应着状态趋势矩阵与状态的关系：</p><script type="math/tex; mode=display">\dot{X_t} = AX_t + Bu_t</script><p>写成离散的形式就是：</p><script type="math/tex; mode=display">X_k = AX_{k-1} + Bu_{k}</script><p>当然最后加上不确定因素W</p><p><strong>关于测量方程：</strong></p><p>​    一般而言我们可能会习惯把<strong>待求量</strong>放在等式左边，已知量放在等式右边。但是在这里$Z_k$才是我们实际获得的数据。</p><p>​    关于转换矩阵H，一般我们无法直接测得需要的待测量，所以会测量其他量计算出待测量。举个例子</p><blockquote><p>激光测距仪测距：发射激光，根据返回用时计算距离。直接获得的物理量是 <strong>时间($Z_n$)</strong>，而我们想获得的 <strong>距离($X_n$)</strong>，于是有了转换矩阵 <strong>H($ \begin{bmatrix}\frac{2}{c}\end{bmatrix}$)</strong></p><script type="math/tex; mode=display">Z_n = \begin{bmatrix}\frac{2}{c}\end{bmatrix}X_n + V_n</script></blockquote><h2 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h2><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p><strong>先验估计方程：</strong></p><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1}</script><p><strong>先验误差协方差矩阵：</strong></p><script type="math/tex; mode=display">P_k^{-} = AP_{k-1}A^T + Q</script><h3 id="矫正"><a href="#矫正" class="headerlink" title="矫正"></a>矫正</h3><p><strong>卡尔曼增益：</strong></p><script type="math/tex; mode=display">K_k = \frac{P_k^- H^T}{HP_k^- H^T + R}</script><p><strong>后验估计：</strong></p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + K_k( Z_k - H\hat{X}_k^-)</script><p><strong>后验误差协方差矩阵：</strong></p><script type="math/tex; mode=display">P_k = ( I - K_kH)P_k^-</script><h3 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h3><ul><li><script type="math/tex">\hat{X}_k^-</script>：k时刻先验估计值——<strong>算出来的</strong></li><li>$\hat{X}_k$：最优估计值</li><li>$\hat{X}_{k-1}$：k-1时刻最优估计值</li><li>$u_k-1$：控制输入量</li><li>$K_k$：卡尔曼增益</li><li>$Z_k$：测量值——<strong>测出来的</strong></li><li>$W_{k-1}$：过程噪声</li><li>$V_k$：测量噪声</li><li>H：由状态量向测量量转换的矩阵</li></ul><p>变量<strong>带个帽子</strong>一般是<strong>估计值</strong>；变量右上角<strong>有个”-“</strong>一般是<strong>先验值</strong>。</p><h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><ol><li>由上一时刻<strong>最优估计值 $\hat{X}_{k-1}$</strong>计算<strong>先验估计值 $\hat{X}_k^-$</strong></li><li>获取<strong>测量值 $Z_k$</strong></li><li>由上一时刻<strong>误差协方差矩阵 $P_{k-1}$</strong>计算<strong>先验误差协方差矩阵 $P_K^-$</strong></li><li>计算<strong>卡尔曼增益$K_k$</strong></li><li>计算<strong>最优估计值<script type="math/tex">\hat{X}_k</script></strong></li><li>更新<strong>后验误差协方差矩阵 $P_k$</strong></li><li>不断更新迭代</li></ol><h2 id="公式说明与推导"><a href="#公式说明与推导" class="headerlink" title="公式说明与推导"></a>公式说明与推导</h2><h3 id="先验估计方程"><a href="#先验估计方程" class="headerlink" title="先验估计方程"></a>先验估计方程</h3><blockquote><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1}</script></blockquote><p>​    由上一时刻的<strong>最优估计值</strong>，根据运动模型推测这一时刻的状态值，即<strong>先验估计值</strong>。和<strong>传递方程</strong>类似。</p><h3 id="后验估计方程"><a href="#后验估计方程" class="headerlink" title="后验估计方程"></a>后验估计方程</h3><blockquote><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + K_k( Z_k - H\hat{X}_k^-)</script></blockquote><p>​    想要得到<strong>最优估计值</strong>，概括来说是根据数据的可靠性将<strong>测量值</strong>和<strong>计算值</strong>加权叠加起来，得到的就是<strong>后验估计值</strong>，也就是滤波过后得到的这一时刻的<strong>最优估计值</strong>。根据<strong>数据融合</strong>原理得到公式：</p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + G( H^-Z_k - \hat{X}_k^-)</script><p>但是我们经常看到的都是令 $G = K_kH$ 变换后的形式，即：</p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_{k}^- + K_k ( Z_k - H\hat{X}_{k}^- )</script><p>其中 $K_k$∈[0, $H^-$]</p><ul><li>当$K_k$ == 0 时，测量误差很大，信任计算出来的值，即 $\hat{X}_{k} == \hat{X}_{k}^-$;</li><li>当$K_k == H^-$时，无测量误差，信任测量值，即$\hat{X}_{k} == H^-Z_k$；</li></ul><h3 id="卡尔曼增益"><a href="#卡尔曼增益" class="headerlink" title="卡尔曼增益"></a>卡尔曼增益</h3><blockquote><script type="math/tex; mode=display">K_k = \frac{P_k^- H^T}{HP_k^- H^T + R}</script></blockquote><p>要计算卡尔曼增益，即求出使误差协方差最小的 $k_k$，在求出其关于$K_k$ 的表达式后再求导得到极值点。</p><h3 id="状态空间方程："><a href="#状态空间方程：" class="headerlink" title="状态空间方程："></a><strong>状态空间方程：</strong></h3><blockquote><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1} + W_{k-1}</script><script type="math/tex; mode=display">Z_k = HX_k + V_k</script></blockquote><p><img src="https://s2.loli.net/2022/11/03/hviNkZWEIeG39sw.jpg" alt="note1.jpg"></p><p><img src="https://s2.loli.net/2022/11/03/iwQRzfS7FlnPmZM.jpg" alt="note2.jpg"></p><h3 id="先后验误差协方差矩阵"><a href="#先后验误差协方差矩阵" class="headerlink" title="先后验误差协方差矩阵"></a>先后验误差协方差矩阵</h3><blockquote><script type="math/tex; mode=display">P_k^{-} = AP_{k-1}A^T + Q</script><script type="math/tex; mode=display">P_k = ( I - K_kH)P_k^-</script></blockquote><p><img src="https://s2.loli.net/2022/11/03/8bS1wKNJ3EoAOy2.jpg" alt="note.jpg"></p><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><p>（待补充）</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>​    感谢大家耐心看完了本篇博客，欢迎大家分享；由于我自己也是初学者，对卡尔曼滤波的理解还不算深入，难免会有不完善之处，这篇文章作为一篇笔记由于大家分享，也欢迎大家批评指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kalman Filter </tag>
            
            <tag> 滤波算法 </tag>
            
            <tag> 控制方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC &amp; PCA9685</title>
      <link href="/2022/11/01/%E8%88%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/01/%E8%88%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    有些时候需要同时驱动多个舵机，需要为每一个舵机调制出对应的<strong>PWM</strong>脉冲信号；如果舵机很多的话，会占用主控的很多资源。幸运的是有这样一款模块，只需要<strong>两个GPIO口</strong>，便可以通过<strong>I^2^C通信协议</strong>控制<strong>16</strong>路舵机（事实上可以串联多个模块，控制更多舵机）。在这里记录一下其使用方法和代码实现方法。</p><h1 id="I-2-C通讯协议"><a href="#I-2-C通讯协议" class="headerlink" title="I^2^C通讯协议"></a>I^2^C通讯协议</h1><p>一篇介绍的很详细的文章：<a href="https://zhuanlan.zhihu.com/p/362287272">一文看懂I2C协议 - 知乎 (zhihu.com)</a></p><p>这里附上较为权威的文件链接</p><ul><li><a href="https://semitia.top/upload_flies/TI_I2C_slva704.pdf">https://semitia.top/upload_flies/TI_I2C_slva704.pdf</a></li><li><a href="https://semitia.top/upload_flies/NXP_I2C_UM10204.pdf">https://semitia.top/upload_flies/NXP_I2C_UM10204.pdf</a></li><li><a href="https://semitia.top/upload_flies/ZLG_I2C.pdf">https://semitia.top/upload_flies/ZLG_I2C.pdf</a></li></ul><p>此篇笔记则是结合<strong>《TI_I2C_slva704》</strong>和<strong>代码</strong>简单记录一些基本功能。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    <strong>IIC</strong>使用两个接口<strong>(SCL和SDA)</strong>进行<strong>半双工通信</strong>。分为<strong>主机（Master)</strong>和<strong>从机（Slave device）</strong>，每个设备有自己特定的<strong>地址</strong>，一个设备有一个或多个寄存器储存数据，主机通过IIC总线对设备及其寄存器进行读写和配置。</p><h2 id="主机访问从机的一般流程"><a href="#主机访问从机的一般流程" class="headerlink" title="主机访问从机的一般流程"></a>主机访问从机的一般流程</h2><h3 id="发送数据："><a href="#发送数据：" class="headerlink" title="发送数据："></a>发送数据：</h3><ol><li>主机发送<strong>START</strong>信号和<strong>设备地址</strong>来指定一个设备</li><li>主机发送数据</li><li>主机发送<strong>STOP</strong>信号</li></ol><h3 id="接收数据："><a href="#接收数据：" class="headerlink" title="接收数据："></a>接收数据：</h3><ol><li>主机发送<strong>START</strong>信号和<strong>设备地址</strong>来指定一个设备</li><li>主机指定要读取的<strong>寄存器</strong></li><li>主机读取数据</li><li>主机发送<strong>STOP</strong>信号</li></ol><h2 id="START和STOP信号"><a href="#START和STOP信号" class="headerlink" title="START和STOP信号"></a>START和STOP信号</h2><ul><li><strong>STATRT</strong>：在<strong>SCL</strong>拉高的情况下，<strong>SDA</strong>电平由高变低，即<strong>下降沿</strong></li><li><strong>STOP</strong>：在<strong>SCL</strong>拉高的情况下，<strong>SDA</strong>电平由低变高，即<strong>上升沿</strong></li></ul><p><img src="https://s2.loli.net/2022/11/02/Rkjp2zrVq8NGIy9.png" alt="IIC_1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();     </span><br><span class="line">IIC_SDA=<span class="number">1</span>;    </span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SDA=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><code>SDA_OUT();</code>：将<strong>SDA</strong>端口设置为输出模式；在切换读写状态的时候，也要修改IO口配置</li><li><code>IIC_SCL=0;</code>：IIC总线接上拉电阻，故默认<strong>高电平</strong>状态为<strong>总线空闲</strong>状态；主机接下来要发送指令，所以要拉低电平，主机控制住总线。</li></ul><h4 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();<span class="comment">//sdaÏßÊä³ö</span></span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">IIC_SDA=<span class="number">0</span>;<span class="comment">//STOP:when CLK is high DATA change form low to high</span></span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>; </span><br><span class="line">IIC_SDA=<span class="number">1</span>;<span class="comment">//·¢ËÍI2C×ÜÏß½áÊøÐÅºÅ</span></span><br><span class="line">delay_us(<span class="number">4</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ACK-NACK-有无应答"><a href="#ACK-NACK-有无应答" class="headerlink" title="ACK/NACK 有无应答"></a>ACK/NACK 有无应答</h2><p>​    在完成一个字节的信息传输后，<strong>接收方</strong>可以发送<strong>ACK</strong>以告知发送方数据被成功接收；也可以选择不发送。在接收方发送ACK之前，发送方必须释放SDA线；接收方<strong>拉低SDA</strong>以发送ACK。</p><p>​    倘若在ACK位SDA仍然为高电位，则认为是<strong>NACK——无应答</strong>，无应答的一些情况：</p><ul><li>接收方没有做好接收的准备</li><li>接收方无法理解接收到的数据</li><li>接收方无法再接收更多数据</li><li>主机作为接收方完成了数据接收</li></ul><p>​    在这样的规定下，如果出现了主机数据接收失败的情况的话该如何判定呢？是不是冲突了呢？或许主机可以通过编程判定接受失败，进而选择是否重新请求数据。</p><p><img src="https://s2.loli.net/2022/11/02/4eo2YpZhjNr7V5s.png" alt="IIC_2.png"></p><h2 id="WRITE写操作"><a href="#WRITE写操作" class="headerlink" title="WRITE写操作"></a>WRITE写操作</h2><ul><li><p>数据传输以<strong>一个字(8bits)</strong>节为单位，最先发送<strong>MSB</strong>；</p></li><li><p>在<strong>STOP和START</strong>信号外需保证<strong>SDA</strong>只在<strong>SCL</strong>为<strong>低电平</strong>时发生跳变；<strong>SCL高</strong>时保证<strong>SDA</strong>稳定以读取数据。</p></li></ul><p>注：</p><p><strong>MSB &amp; LSB</strong>：</p><blockquote><p>MSB stands for most significant bit, while LSB is least significant bit. In binary terms, the MSB is the bit that has the greatest effect on the number, and it is the left-most bit. For example, for a binary number 0011 0101, the Most Significant 4 bits would be 0011. The Least Significant 4 bits would be 0101.</p></blockquote><h3 id="协议流程"><a href="#协议流程" class="headerlink" title="协议流程"></a>协议流程</h3><ol><li>主机发送<strong>START</strong>信号</li><li>主机发送<strong>7bits设备地址</strong></li><li><strong>R/W</strong>位置0——写0，读1</li><li>等待应答</li><li>主机发送<strong>从设备寄存器地址</strong></li><li>等待应答</li><li>写入数据</li><li>等待应答</li><li>主机发送<strong>STOP</strong>信号，操作结束。</li></ol><p><img src="https://s2.loli.net/2022/11/02/zMwCgD3Qt1vx5cy.png" alt="IIC_3.png"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>此处仅为发送一个字节的流程，完整流程请参考下方PCA9685实战代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Send_Byte</span><span class="params">(u8 txd)</span></span><br><span class="line">&#123;                        </span><br><span class="line">    u8 t;   </span><br><span class="line">SDA_OUT();     </span><br><span class="line">    IIC_SCL=<span class="number">0</span>;<span class="comment">//À­µÍÊ±ÖÓ¿ªÊ¼Êý¾Ý´«Êä</span></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">    &#123;              </span><br><span class="line">        IIC_SDA=(txd&amp;<span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>;</span><br><span class="line">        txd&lt;&lt;=<span class="number">1</span>;   </span><br><span class="line">delay_us(<span class="number">2</span>); </span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>); </span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="READ读操作"><a href="#READ读操作" class="headerlink" title="READ读操作"></a>READ读操作</h2><h3 id="协议流程-1"><a href="#协议流程-1" class="headerlink" title="协议流程"></a>协议流程</h3><ol><li>前两个字节与写操作相同</li><li>主机重复发送一次<strong>START</strong>信号</li><li>主机发送从设备地址</li><li><strong>R/W置</strong><span class='p red'>1</span>——读操作</li><li>等待应答</li><li>主机读取数据</li><li>主机<strong>不发送</strong>应答信号</li><li>主机发送<strong>STOP</strong>信号</li></ol><p><img src="https://s2.loli.net/2022/11/02/hQueywRLE3xf4v5.png" alt="IIC_4.png"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>同样是只读取一个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">IIC_Read_Byte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i,receive=<span class="number">0</span>;</span><br><span class="line">SDA_IN();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++ )</span><br><span class="line">&#123;</span><br><span class="line">        IIC_SCL=<span class="number">0</span>; </span><br><span class="line">        delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        receive&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(READ_SDA)receive++;   </span><br><span class="line">delay_us(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">        IIC_NAck();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        IIC_Ack();</span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="PCA9685芯片"><a href="#PCA9685芯片" class="headerlink" title="PCA9685芯片"></a>PCA9685芯片</h1><p>芯片手册：<a href="https://semitia.top/upload_flies/PCA9685.pdf">https://semitia.top/upload_flies/PCA9685.pdf</a></p><p>芯片手册的内容比较多，所以在这里只记录一些使用指导性相对更高的一些内容（主要参考第七小节）。</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><h3 id="设备地址"><a href="#设备地址" class="headerlink" title="设备地址"></a>设备地址</h3><p><img src="https://s2.loli.net/2022/11/02/zYo4QDi6RUrBw1L.png" alt="IIC_5.png"></p><p>在默认情况下设备地址是<strong>0x40</strong>，如果算上最后<strong>R/W</strong>位的话就是<strong>0x80</strong>。</p><p>在模块上能够看到六个留空的焊点，可以选择把部分焊点焊上，设备的地址对应位就会被<strong>置一</strong>。比如把<strong>第0位</strong>焊上，地址就变为了<strong>1000001</strong>。</p><h3 id="寄存器地址"><a href="#寄存器地址" class="headerlink" title="寄存器地址"></a>寄存器地址</h3><p>这是部分寄存器总览表，一共有16个led。各个寄存器的地址也都很清楚地列了出来</p><p><img src="https://s2.loli.net/2022/11/02/mXtORuGvFCWUkNr.png" alt="IIC_6.png"></p><h2 id="部分寄存器介绍"><a href="#部分寄存器介绍" class="headerlink" title="部分寄存器介绍"></a>部分寄存器介绍</h2><h3 id="MODE1寄存器"><a href="#MODE1寄存器" class="headerlink" title="MODE1寄存器"></a>MODE1寄存器</h3><p><img src="https://s2.loli.net/2022/11/02/oJsCdm8rMcOBLFj.png" alt="IIC_7.png"></p><p>比较常用的是<strong>第四位</strong>，即<strong>SLEEP</strong>位，因为在读写其他寄存器的时候会需要将芯片休眠，待会在原码介绍中也会见到。</p><p><img src="https://s2.loli.net/2022/11/02/KA7VLulbwsmYzqn.png" alt="IIC_8.png"></p><h3 id="LED-ON-OFF-H-L"><a href="#LED-ON-OFF-H-L" class="headerlink" title="LED_ON_OFF_H_L"></a>LED_ON_OFF_H_L</h3><p>每个PWM(led)输出端口的配置对应四个寄存器</p><ul><li>LEDn_ON_H</li><li>LEDn_ON_L</li><li>LEDn_OFF_H</li><li>LED_OFF_L</li></ul><p>每个寄存器是<strong>8位</strong>寄存器，但是<strong>ON</strong>或<strong>OFF</strong>只会分别储存<strong>十二位</strong>的数据，也就是<em>L</em>存8位，<em>H</em>存4位</p><p><img src="https://s2.loli.net/2022/11/02/lFafpNvyibHqVjo.png" alt="IIC_9.png"></p><p>具体的寄存器数据和PWM波形的关系如下</p><blockquote><p>​    <strong>ON</strong>和<strong>OFF</strong>分别存储着范围<strong>0~4096</strong>的值(确实是4096而非4095)，我们把两个值记作<strong>cnt_on, cnt_off</strong>吧。有一个计数器从0计数到<strong>4095</strong>，我们把计数器的值记作<strong>CNT</strong>。</p><p>一般情况下，都是<code>cnt_on &lt; cnt_off</code>：</p><ul><li>当<code>CNT == cnt_on</code>时，PWM波<strong>由低变高</strong>；</li><li>当<code>CNT == cnt_off</code>时，PWM波<strong>由高变低</strong>；</li></ul><p>当<code>cnt_off &lt; cnt_on</code>时，在第一个周期内<code>CNT == cnt_off</code>不做变化。</p><p>可以看出，控制精度是<strong>1/4096</strong>周期。</p></blockquote><p>具体的PWM调制方法我们结合官方手册里面给出的两个例子就很容易理解了：</p><p><img src="https://s2.loli.net/2022/11/02/e9yZhwCiX5AImpc.png" alt="IIC_10.png"></p><p>（这里我感觉 <em>Fig 7</em> 图里的<strong>819</strong>是不是应该是<strong>410</strong>）</p><p><img src="https://s2.loli.net/2022/11/02/82lKZfsdSYL9EnW.png" alt="IIC_11.png"></p><h3 id="PRE-SCALE"><a href="#PRE-SCALE" class="headerlink" title="PRE_SCALE"></a>PRE_SCALE</h3><p><img src="https://s2.loli.net/2022/11/02/Y9Ch54OApUxLM8e.png" alt="IIC_12.png"></p><p>​    <strong>PRE_SCALE</strong>寄存器用以调制PWM频率。驱动舵机的话我们需要<strong>20ms</strong>的脉冲，频率为<strong>50Hz</strong>。</p><p>​    如果学习过STM32用定时器输出PWM的话应该很容易理解，只不过这里的<strong>自动重装载值</strong>固定为4096。</p><p>​    时钟给出的是<strong>25MHz</strong>的频率，如果我们设置<strong>n分频</strong>，那么<strong>计数器</strong>就会每过<strong>$\frac{n}{25000000}$</strong>秒计数一次，那么$T_n = \frac{4096n}{25000000}$秒就是一个周期。假如我们要<strong>50Hz</strong>的脉冲，那么周期应该是<strong>20ms</strong>，令$T_n == 0.02s$，解得n，那么分频系数设置为<strong>n-1</strong>即可。</p><p>​    为什么要减去一呢？因为不分频其实也就是<strong>一分频</strong>，但是默认<code>prescale value == 0</code>时是不分频。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Write写数据"><a href="#Write写数据" class="headerlink" title="Write写数据"></a>Write写数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_write1</span><span class="params">(u8 adr,u8 data)</span></span><br><span class="line">&#123; </span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(adr);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(data);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/02/zMwCgD3Qt1vx5cy.png" alt="IIC_3.png"></p><p>这里贴上之前的流程图方便比对。</p><h3 id="Read读数据"><a href="#Read读数据" class="headerlink" title="Read读数据"></a>Read读数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">pca_read1</span><span class="params">(u8 adr)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 data;</span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(adr);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1|<span class="number">0x01</span>);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">data=IIC_Read_Byte(<span class="number">0</span>);</span><br><span class="line">IIC_Stop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/02/hQueywRLE3xf4v5.png" alt="IIC_4.png"></p><h3 id="设置分频系数"><a href="#设置分频系数" class="headerlink" title="设置分频系数"></a>设置分频系数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_setfreq1</span><span class="params">(<span class="type">float</span> freq)</span> </span><br><span class="line">&#123;</span><br><span class="line">u8 prescale,oldmode,newmode;</span><br><span class="line"><span class="type">double</span> prescaleval;</span><br><span class="line">freq *= <span class="number">0.92</span>; </span><br><span class="line">prescaleval = <span class="number">25000000</span>;</span><br><span class="line">prescaleval /= <span class="number">4096</span>;</span><br><span class="line">prescaleval /= freq;</span><br><span class="line">prescaleval -= <span class="number">1</span>;</span><br><span class="line">prescale =<span class="built_in">floor</span>(prescaleval + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">oldmode = pca_read1(pca_mode1); <span class="comment">//获取之前mode寄存器配置状态</span></span><br><span class="line"></span><br><span class="line">newmode = (oldmode&amp;<span class="number">0x7F</span>) | <span class="number">0x10</span>; <span class="comment">// 睡眠模式</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, newmode); <span class="comment">// 进入睡眠</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_pre, prescale); <span class="comment">// 设置分频系数</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, oldmode); <span class="comment">//写回原来</span></span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, oldmode | <span class="number">0xa1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意手册里也多次强调，<span class='p red'>只有在设备进入睡眠模式之后才能修改分频系数</span></p><p>这里需要了解一下<strong>MODE1</strong>寄存器里的<emp>RESTART</emp>位</p><div class="note info modern"><p>在<strong>不停止PWM通道输出</strong>的情况下将设备设置为sleep模式，<strong>RESTART</strong>位会在一个PWM周期后被置1，<strong>LED</strong>寄存器里面的数据会被保存。想要重启，向<strong>RESTART</strong>位写1即可，此时该位会被自动<strong>置0</strong>。</p></div><p>​    当然，在这段代码中还设置了<strong>ALLCALL、AL</strong>位。</p><h3 id="调制PWM占空比"><a href="#调制PWM占空比" class="headerlink" title="调制PWM占空比"></a>调制PWM占空比</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_setpwm1</span><span class="params">(u8 num, u32 on, u32 off)</span> </span><br><span class="line">&#123;</span><br><span class="line">pca_write1(LED0_ON_L+<span class="number">4</span>*num,on);</span><br><span class="line">pca_write1(LED0_ON_H+<span class="number">4</span>*num,on&gt;&gt;<span class="number">8</span>);</span><br><span class="line">pca_write1(LED0_OFF_L+<span class="number">4</span>*num,off);</span><br><span class="line">pca_write1(LED0_OFF_H+<span class="number">4</span>*num,off&gt;&gt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个“LED”有四个寄存器，所以<strong>第n个</strong>led地址为<strong>LED0</strong>地址加<strong>4n</strong>。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>感谢大家耐心看完了本篇博客，欢迎大家分享；完整的工程可以在我的<strong>GiHub</strong>仓库找到。由于本人水平有限，可能有不完善之处，欢迎大家批评指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> IIC </tag>
            
            <tag> 舵机 </tag>
            
            <tag> PCA9685 </tag>
            
            <tag> 通讯协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的位运算</title>
      <link href="/2022/10/29/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/10/29/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="有意思的操作"><a href="#有意思的操作" class="headerlink" title="有意思的操作"></a>有意思的操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>位运算是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。常用的位运算符号包括：“∧” 按位异或（取不同）、“&amp;” 按位与（取交）、“|” 按位或（取并）、“~” 取反、“&lt;&lt;” 算术左移和 “&gt;&gt;” 算术右移。</p><ul><li>n &amp; (n - 1) 可以去除 n 的位级表示中最低的那一位，例如对于二进制表示 11110100 ，减去 1 得到 11110011，这两个数按位与得到 11110000。</li><li>n &amp; (-n) 可以得到 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100。</li></ul><h2 id="获取二进制数中1的个数"><a href="#获取二进制数中1的个数" class="headerlink" title="获取二进制数中1的个数"></a>获取二进制数中1的个数</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_contains</span><span class="params">(u32 s,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(((s&gt;&gt;i) &amp; <span class="number">0x01</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_size0</span><span class="params">(u32 s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n += <span class="built_in">bitset_contains</span>(s,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>int bitset_contains(u32 s,int i)</code>就是判断s的<strong>第i位</strong>（从<strong>第0位</strong>开始计起）是否为1。</p><p><code>int bitset_size0(u32 s)</code>就是一位位看是不是1，是就<strong>计数加一</strong>。</p><p>最后效果就是<strong>统计s为1的位数</strong></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_size</span><span class="params">(u32 s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = (s &amp; <span class="number">0x55555555</span>) + ((s&gt;&gt;<span class="number">1</span>) &amp; <span class="number">0x55555555</span>); <span class="comment">//01010101010101010101010101010101</span></span><br><span class="line">    s = (s &amp; <span class="number">0x33333333</span>) + ((s&gt;&gt;<span class="number">2</span>) &amp; <span class="number">0x33333333</span>); <span class="comment">//00110011001100110011001100110011</span></span><br><span class="line">    s = (s &amp; <span class="number">0x0f0f0f0f</span>) + ((s&gt;&gt;<span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>); <span class="comment">//00001111000011110000111100001111</span></span><br><span class="line">    s = (s &amp; <span class="number">0x00ff00ff</span>) + ((s&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>); <span class="comment">//00000000111111110000000011111111</span></span><br><span class="line">    s = (s &amp; <span class="number">0x0000ffff</span>) + ((s&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);<span class="comment">//00000000000000001111111111111111</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    一般来说，看到这样的<strong>十六进制</strong>数就会不由自主地想把它们转换为<strong>二进制</strong>看看。转换之后呢就能稍微看出一些端倪了。😁</p><p>​    <code>0x55555555</code>将s分为<strong>两个一组</strong>，每一组两位数。其实就是==分别判断一组里的两位数是不是1==。</p><ul><li>都是1，则变为<strong>1+1=10</strong>；</li><li>只有一个，就变为<strong>01</strong>；</li><li>没有则为<strong>0</strong></li></ul><p>​    变换完了之后呢，储存的就是这一组里 <em>“1”</em> 的个数。</p><p>​    <code>0x33333333</code>则是将s分为<strong>四个一组</strong>，一组里同样是<strong>两个数</strong>，只不过一个数是<strong>两位</strong>。操作的结果呢就是<strong>将两个数各自两个位里1的个数</strong>加起来，即<strong>四个位里1的个数</strong>。</p><p>​    <code>0x0f0f0f0f</code>将s分为<strong>八个一组</strong>，统计<strong>八个位里1的个数</strong></p><p>​    <code>0x00ff00ff</code>将s分为<strong>十六个一组</strong>，统计<strong>十六位里1的个数</strong></p><p>​    <code>0x0000ffff</code>将整个32位的s看作一组，统计<strong>所有1的个数</strong></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>​    两种方法比较来看，明显是第一种方法简单易懂，也容易想到；但是从运算效率上来看，第二种远远高于第一种。</p><h1 id="遥控数据解析"><a href="#遥控数据解析" class="headerlink" title="遥控数据解析"></a>遥控数据解析</h1><p><img src="https://s2.loli.net/2022/10/29/7vaHiBuG1CXbV9m.png" alt="遥控协议.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RemoteReceive</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint8_t</span> *<span class="type">const</span> ptr_sbus_rx_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr_sbus_rx_buffer == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    RC_Ctl.rc.ch0 = (ptr_sbus_rx_buffer[<span class="number">0</span>] | (ptr_sbus_rx_buffer[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>)) &amp;<span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch1 = (ptr_sbus_rx_buffer[<span class="number">1</span>] &gt;&gt; <span class="number">3</span>) | (ptr_sbus_rx_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">5</span>) &amp; <span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch2 = (ptr_sbus_rx_buffer[<span class="number">2</span>] &gt;&gt; <span class="number">6</span>) | (ptr_sbus_rx_buffer[<span class="number">3</span>] &lt;&lt; <span class="number">2</span>) | (ptr_sbus_rx_buffer[<span class="number">4</span>] &lt;&lt; <span class="number">10</span>) &amp; <span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch3 = (ptr_sbus_rx_buffer[<span class="number">4</span>] &gt;&gt; <span class="number">1</span>) | (ptr_sbus_rx_buffer[<span class="number">5</span>] &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x07ff</span>; </span><br><span class="line">    RC_Ctl.rc.s1 = (ptr_sbus_rx_buffer[<span class="number">5</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x0003</span>;</span><br><span class="line">    RC_Ctl.rc.s2 = (ptr_sbus_rx_buffer[<span class="number">5</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0003</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括来说就是依照<strong>通信协议</strong>利用<strong>位移运算</strong>和<strong>或、与运算</strong>，将数据从<strong>ptr_sbus_rx_buffer</strong>剥离提取至<strong>RC_Ctl.rc.xx</strong>中。</p><ul><li>位移操作后，需要提取的数据在<strong>后11位(或后2位)</strong>，<strong>0x07ff</strong>换成二进制就是<strong>0000011111111111</strong>，过滤掉不需要的位数；<strong>0x0003</strong>同理</li><li><strong>ch0</strong>获取buffer[0]<strong>全部八位</strong>和buffer[1]<strong>低三位</strong></li><li><strong>ch1</strong>获取buffer[1]<strong>高五位</strong>和buffer[2]<strong>低六位</strong></li><li><strong>ch2</strong>获取buffer[2]<strong>高两位</strong>和buffer[3]<strong>全部八位</strong>和buffer[4]<strong>低一位</strong></li><li><strong>ch3</strong>获取buffer[4]<strong>高七位</strong>和buffer[5]<strong>低四位</strong></li><li><strong>s1</strong>获取buffer[5]<strong>高两位</strong></li><li><strong>s2</strong>获取buffer[5]<strong>第五第六位</strong></li></ul><p>不知道是不是搞反了，根据协议来看是<strong>s1</strong>获取buffer[5]<strong>第五第六位</strong>，<strong>s2</strong>获取buffer[5]<strong>高两位</strong></p><h1 id="位运算实现四则运算"><a href="#位运算实现四则运算" class="headerlink" title="位运算实现四则运算"></a>位运算实现四则运算</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    在平时手算的时候我们经常会<strong>列竖式</strong>，先不考虑进位，只看<strong>和</strong>和<strong>相加的两个数</strong>同位的数，把进位数写小一点记在横线上方。<strong>计算下一位的时候再加上上一位的进位。</strong></p><p>​    所以在程序中也是模拟这样一个思路：</p><ul><li>先不看进位，得到一个和；记下进位</li><li>进位在与和相加，不看进位得到一个新的和；同时也得到新的进位</li><li>不断迭代递推，直到不再产生新的进位</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加法函数</span></span><br><span class="line"><span class="comment"> * @param ini_x 加数1</span></span><br><span class="line"><span class="comment"> * @param ini_y 加数2</span></span><br><span class="line"><span class="comment"> * @return 补码形式的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">u32 <span class="title">addition</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不需要转换为补码</span></span><br><span class="line">    u32 x = ini_x, y = ini_y;</span><br><span class="line">    <span class="comment">//和，进位</span></span><br><span class="line">    u32 ans,carry;</span><br><span class="line">    ans = x ^ y;</span><br><span class="line">    carry = (x &amp; y) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//不断获取进位与不考虑进位的和，迭代相加，直至进位为0</span></span><br><span class="line">    <span class="keyword">while</span>(carry != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        u32 i = ans, j = carry;</span><br><span class="line">        ans = i ^ j;</span><br><span class="line">        carry = (i &amp; j) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DEBUG调试</span></span><br><span class="line">    <span class="comment">//printf(&quot;DE<span class="doctag">BUG:</span> %d add %d = %d\r\n&quot;,ini_x,ini_y,ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以发现，</p><ul><li>不看进位得到的和其实就是<strong>两数异或</strong>，即<code>ans = x ^ y;</code>；</li><li>进位即<strong>两数相与再左移一位</strong>，即<code>carry = (x &amp; y) &lt;&lt; 1;</code></li></ul><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>​    <strong>a-b</strong> 即 <strong>a+(-b)</strong></p><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    可以将被乘数不断加<strong>乘数次数</strong>的自己。但是这样效率不高。同样是模拟手算的思想，从<strong>乘数的最低位</strong>到<strong>最高位</strong>，在<strong>第i位</strong>，即给最后乘积贡献的值为</p><p>==被乘数 <em> 乘数[i] </em> (进制数)^(i-1)^==</p><p>​    在这个算法下不再能直接用补码参与计算，所以要换成原码并去除符号位。在开始的时候根据两数记下乘积的正负值，计算完毕之后再赋回去。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 乘法</span></span><br><span class="line"><span class="comment"> * @param ini_x </span></span><br><span class="line"><span class="comment"> * @param ini_y </span></span><br><span class="line"><span class="comment"> * @return u32 积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">u32 <span class="title">multiplication</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> negative_flag=<span class="number">0</span>;</span><br><span class="line">    u32 ans=<span class="number">0</span>, x=ini_x, y=ini_y;</span><br><span class="line">    <span class="comment">//判断积正负</span></span><br><span class="line">    <span class="keyword">if</span>( ( (x&amp;<span class="number">0x80000000</span>) &amp;&amp; !(y&amp;<span class="number">0x80000000</span>) )||( !(x&amp;<span class="number">0x80000000</span>) &amp;&amp; (y&amp;<span class="number">0x80000000</span>) ) ) &#123;negative_flag=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">//要转换为原码并去掉符号位</span></span><br><span class="line">    x = <span class="built_in">back_com</span>(x);</span><br><span class="line">    y = <span class="built_in">back_com</span>(y);</span><br><span class="line">    x &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    y &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="comment">//借鉴竖乘法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">31</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">0x01</span>) &#123;ans = <span class="built_in">addition</span>(ans,x);&#125;</span><br><span class="line">        y = y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        x = x&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span>) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加上正负号</span></span><br><span class="line">    <span class="keyword">if</span> (negative_flag) </span><br><span class="line">    &#123;</span><br><span class="line">        ans |= <span class="number">0x80000000</span>;<span class="comment">//这个时候依然是原码，想直接用%d，要转换为补码</span></span><br><span class="line">        ans = <span class="built_in">get_com</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DEBUG调试</span></span><br><span class="line">    <span class="comment">//printf(&quot;DE<span class="doctag">BUG:</span> %d multiply %d = %d\r\n&quot;,ini_x,ini_y,ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>​    因为除法有<strong>商</strong>和<strong>余数</strong>，所以用了一个结构体方便存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 除法答案结构体</span></span><br><span class="line"><span class="comment"> * @param ans 商</span></span><br><span class="line"><span class="comment"> * @param mod 余数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__ans_division_t</span>&#123;</span><br><span class="line">    u32 ans;</span><br><span class="line">    u32 mod;</span><br><span class="line">&#125;<span class="type">ans_division_t</span>;</span><br></pre></td></tr></table></figure><h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    也是模拟手算流程，在理解了乘法的实现思路后便很容易理解。</p><ul><li>将被除数不断<strong>进位</strong>，即乘上<strong>进制数</strong>，直到恰好比被除数小。</li><li>用被除数除以<strong>进位后的除数</strong>得到<strong>商</strong>（为了区别最终的商把它叫做<em>小商</em>吧），同时<strong>商</strong>加上==小商*进制数^(进位次数)^==</li><li>被除数不断<strong>退位</strong>（除以进制数），同时重复上述操作，直到回到最初大小，即<strong>进位数为0</strong></li></ul><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 除法</span></span><br><span class="line"><span class="comment"> * @param ini_x 被除数</span></span><br><span class="line"><span class="comment"> * @param ini_y 除数</span></span><br><span class="line"><span class="comment"> * @return ans_division_t* 答案指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ans_division_t</span> *<span class="title">division</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> negative_flag=<span class="number">0</span>;</span><br><span class="line">    u32 ans=<span class="number">0</span>, carry=<span class="number">0</span>, x=ini_x, y=ini_y;</span><br><span class="line">    <span class="type">ans_division_t</span> *ans_division;</span><br><span class="line">    ans_division = (<span class="type">ans_division_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">ans_division_t</span>));</span><br><span class="line">    <span class="keyword">if</span>( ( (x&amp;<span class="number">0x80000000</span>) &amp;&amp; !(y&amp;<span class="number">0x80000000</span>) )||( !(x&amp;<span class="number">0x80000000</span>) &amp;&amp; (y&amp;<span class="number">0x80000000</span>) ) ) &#123;negative_flag=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">//要转换为原码并去掉符号位</span></span><br><span class="line">    x = <span class="built_in">back_com</span>(x);</span><br><span class="line">    y = <span class="built_in">back_com</span>(y);</span><br><span class="line">    x &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    y &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="comment">//依然是模拟手除流程</span></span><br><span class="line">    <span class="comment">//除数不断进位直至比被除数大</span></span><br><span class="line">    <span class="keyword">while</span>(y &lt; x) </span><br><span class="line">    &#123;</span><br><span class="line">        y = y&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        carry = <span class="built_in">addition</span>(carry,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果能除，商就加上1&lt;&lt;carry，除数再不断右移直至回到本来大小。</span></span><br><span class="line">    <span class="keyword">while</span>(carry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=y)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">addition</span>(ans,<span class="number">1</span>&lt;&lt;carry);</span><br><span class="line">            x = <span class="built_in">addition</span>(x,-y);</span><br><span class="line">        &#125;</span><br><span class="line">        y = y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        carry = <span class="built_in">addition</span>(carry,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=y) </span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">addition</span>(ans,<span class="number">1</span>);</span><br><span class="line">        x = <span class="built_in">addition</span>(x,-y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    ans_division-&gt;ans = ans;</span><br><span class="line">    ans_division-&gt;mod = x;</span><br><span class="line">    <span class="keyword">return</span> ans_division;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    因为负数的余数比较奇怪，平时也不用，这里没有考虑在内。</p><h2 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h2><p>​    vscode 程序文件不能用中文命名。</p><p>​    在程序运行的时候使用补码记录。即便是<strong>usigned int</strong>，倘若<strong>scanf -9</strong>，对应二进制编码也是<strong>11111111111111111111111111110111</strong>。<strong>int</strong>型同样如此。</p><p>​    所以在运算的时候不需要人为的去转换为补码了，在这方面耽误了不少时间。</p><p>​    而对于同样的一串二进制编码，<strong>printf(“%d”)</strong>和<strong>printf(“%u”)</strong>输出结果是不一样的：%d会自动转换输出原码对应的有符号数；那%u则是会将这个补码当作原码直接换算成十进制输出。</p><p><img src="https://s2.loli.net/2022/10/29/PICY3lTj1Q4OKGS.png" alt="存储形式·1.png"></p><p><img src="https://s2.loli.net/2022/10/29/2SIuUTAJV9tDnqR.png" alt="存储形式2.png"></p><p>​    其余的就是一些逻辑漏洞了，不得不说VScode写代码还是比Keil舒服😁</p><h1 id="有关位运算的一些有意思的题目"><a href="#有关位运算的一些有意思的题目" class="headerlink" title="有关位运算的一些有意思的题目"></a>有关位运算的一些有意思的题目</h1><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗</p><p>示例 1:</p><blockquote><p>输入: [2,2,1]<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: [4,1,2,1,2]<br>输出: 4</p></blockquote></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>需要用到异或运算的性质：</p><p>a \^ a = 0<br>a \^ 0 = a<br>a \^ b \^ a = b \^ (a \^ a) = b（交换律和结合律）<br>所以只要全部异或最后结果就是答案</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num: nums)</span><br><span class="line">        ans ^= num;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h2><blockquote><p>给定一个非负整数 n，求从 0 到 n 的所有数字的二进制表达中，分别有多少个 1。</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题可以利用动态规划和位运算进行快速的求解。定义一个数组 dp，其中 dp [i] 表示数字 i 的二进制含有 1 的个数。对于第 i 个数字，如果它二进制的最后一位为 1，那么它含有 1 的个数 则为 dp [i-1] + 1；如果它二进制的最后一位为 0，那么它含有 1 的个数和其算术右移结果相同，即 dp [i&gt;&gt;1]。</p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(num+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        dp[i] = i &amp; <span class="number">1</span>? dp[i<span class="number">-1</span>] + <span class="number">1</span>: dp[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 等价于dp[i] = dp[i&amp;(i-1)] + 1;</span></span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
            <tag> 算法 </tag>
            
            <tag> leecode </tag>
            
            <tag> 四则运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32仿真器程序烧录</title>
      <link href="/2022/10/22/STM32%E4%BB%BF%E7%9C%9F%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95/"/>
      <url>/2022/10/22/STM32%E4%BB%BF%E7%9C%9F%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>​    这几天捯饬了一下烧录程序的方法。主要还是<strong>SWD</strong>烧录，后续应该会尝试其他方法。我最开始的时候就不太会弄，即便手边有个仿真器也没有去用（后来就丢了😂），一直用的是<strong>ISP</strong>下载，不仅效率低，还不能在线调试。所以就整理了一下烧录方法。</p><span id="more"></span><h1 id="STM32仿真器程序烧录"><a href="#STM32仿真器程序烧录" class="headerlink" title="STM32仿真器程序烧录"></a>STM32仿真器程序烧录</h1><h3 id="SWD烧录"><a href="#SWD烧录" class="headerlink" title="SWD烧录"></a>SWD烧录</h3><p>SWD烧录是一种串行调试接口，出去供电与共地只需要两根线即可烧录调试</p><ul><li><strong>SWDIO：</strong> 串行数据线，用于数据的读出和写入;</li><li><strong>SWDCLK：</strong> 串行时钟线，提供所需要的时钟信号;</li></ul><p>下面是官方手册里烧录接口的引脚到GPIO口的映射关系</p><p><img src="https://s2.loli.net/2022/10/22/yxIoZNYtkJiqcvs.png" alt="映射关系.png"></p><p>这个是标准的接口排列，要注意的是按照插座边上的<strong>缺口向左</strong>的方向来查看。</p><p><img src="https://s2.loli.net/2022/10/22/NxQRpn7YiqlcZ9j.png" alt="swd_jtag插座.png"></p><p>一般情况下大多数单片机的 JTAG 接口和 SWDIO 接口是复用的，下面就是MINI板的原理图</p><p><img src="https://s2.loli.net/2022/10/22/hPSMBDUczKI6gOZ.png" alt="MINIswd插座.png"></p><h4 id="J-link"><a href="#J-link" class="headerlink" title="J-link"></a>J-link</h4><p>这个是比较常见也比较便宜的一款J-link，只有<strong>3.3vVCC、SWDIO、SWCLK、GND</strong>四根线，接线方式也十分的简单 。</p><p><img src="https://s2.loli.net/2022/10/22/jM2wkymvznOZtS9.jpg" alt="廉价j-link.jpg" style="zoom:50%;" /></p><p>像<strong>STM32C8T6、openCRP</strong>等等已经给出这四个接口的板子直接接上就好了</p><p><img src="https://s2.loli.net/2022/10/22/RGTbYQp9D8sUexm.jpg" alt="swd接口.jpg"></p><p>如果是20脚标准接口的话对照上面的图片找到对应的引脚直接接上即可。</p><p><img src="https://s2.loli.net/2022/10/22/EMTGCtwVFrAia9I.jpg" alt="廉价j-link接线.jpg"></p><p>​    如果实在找不到接口呢，直接把<strong>SWDIO、SWCLK</strong>接在<strong>PA13、PA14</strong>，再供电共地也是一样可以正常烧录的。    </p><p>​    经过测试呢，可以正常烧录，但是会<strong>供电不足</strong>。其中<strong>C8T6和openCRP</strong>的<strong>5V</strong>引脚电压不够，不过程序倒是可以正常运行；而<strong>MINI</strong>则是程序无法正常运行。这个具体情况还与各个板子的PCB设计有关。一般保险起见的话，需要<strong>额外供电</strong>。</p><h4 id="ST-link"><a href="#ST-link" class="headerlink" title="ST-link"></a>ST-link</h4><p>这也是很常见的一款ST-link</p><p><img src="https://s2.loli.net/2022/10/22/wQTMaopVhKlZq7g.jpg" alt="ST-link.jpg"></p><p>​    如果能直接用20脚的接口就很方便。不行的话也可以直接对照前面的图片把<strong>SWD</strong>对应的四根线接出来。</p><p>​    和板子的接线方法与之前都是一样的。</p><h4 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h4><p>这里用的是<strong>MDK5</strong>或者叫<strong>Keil</strong></p><ol><li>首先是点开<strong>魔术棒</strong>，选择对应的调试器<img src="https://s2.loli.net/2022/10/22/9botRpUDXFnAEqs.png" alt="config.png"></li><li>然后进入<strong>settings</strong>选择烧录方式和烧录速度<img src="https://s2.loli.net/2022/10/22/mxFHa8b52YNCoiJ.jpg" alt="config2.jpg"></li><li>然后可以检查一下烧录算法和自己的芯片型号是不是对应的。<img src="https://s2.loli.net/2022/10/22/1xEaqv8ANcwoJsX.jpg" alt="config3.jpg"></li><li>最后点击<strong>load</strong>按钮就可以烧录了。</li></ol><h3 id="ISP烧录"><a href="#ISP烧录" class="headerlink" title="ISP烧录"></a>ISP烧录</h3>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS串口通讯</title>
      <link href="/2022/08/29/ROS-USART-STM32/"/>
      <url>/2022/08/29/ROS-USART-STM32/</url>
      
        <content type="html"><![CDATA[<p>​    简单记录了尝试使用ROS与STM32通讯的过程，包括踩的一点坑，其中一些低级问题实在是有点让人哭笑不得😂</p><span id="more"></span><h1 id="ROS串口通讯"><a href="#ROS串口通讯" class="headerlink" title="ROS串口通讯"></a>ROS串口通讯</h1><h2 id="ROS串口通讯配置"><a href="#ROS串口通讯配置" class="headerlink" title="ROS串口通讯配置"></a>ROS串口通讯配置</h2><h3 id="Ubuntu20-04手动获取Serial包"><a href="#Ubuntu20-04手动获取Serial包" class="headerlink" title="Ubuntu20.04手动获取Serial包"></a>Ubuntu20.04手动获取Serial包</h3><h3 id="linux-ros-串口权限获取"><a href="#linux-ros-串口权限获取" class="headerlink" title="linux/ros 串口权限获取"></a>linux/ros 串口权限获取</h3><p>转载自<a href="https://blog.csdn.net/qq_16775293/article/details/82822851?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-0-82822851-blog-55259778.wap_relevant_multi_platform_whitelistv1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1">(9条消息) Linux/ROS——获取串口权限_不懂音乐的欣赏者的博客-CSDN博客</a></p><p>我这里的串口号是<strong>/dev/ttyTHS1</strong>，需要适当变动</p><h4 id="永久解决串口权限问题"><a href="#永久解决串口权限问题" class="headerlink" title="永久解决串口权限问题"></a>永久解决串口权限问题</h4><p>（我试了一下，但是失败了）</p><p>创建ttyUSB权限规则文件etc/udev/rules.d/70-ttyUSB.rules</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim -p /etc/udev/rules.d/70-ttyUSB.rules</span><br></pre></td></tr></table></figure><p>在<strong>70-ttyUSB.rules</strong>文件中写入下列代码</p><p>KERNEL==”ttyUSB*”, OWNER=”root”, GROUP=”root”, MODE=”0666”<br>保存即可,重启或注销用户在登录后生效</p><h4 id="临时获取串口权限"><a href="#临时获取串口权限" class="headerlink" title="临时获取串口权限"></a>临时获取串口权限</h4><p>先查看插入电脑的<strong>串口号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/ | grep ttyUSB</span><br></pre></td></tr></table></figure><p>知道串口号之后对指定串口赋予权限,以<strong>ttyUSB0</strong>为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+rw /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>不用重启即可生效</p><h3 id="代码编写问题"><a href="#代码编写问题" class="headerlink" title="代码编写问题"></a>代码编写问题</h3><h2 id="Jetson-nano与STM32通讯"><a href="#Jetson-nano与STM32通讯" class="headerlink" title="Jetson nano与STM32通讯"></a>Jetson nano与STM32通讯</h2><h3 id="jetson-nano串口"><a href="#jetson-nano串口" class="headerlink" title="jetson nano串口"></a>jetson nano串口</h3><p>引脚图，直接连即可。</p><p><img src="https://s2.loli.net/2022/10/22/x8melhw2bcjAgqV.jpg" alt="nano_usart.jpg"></p><h3 id="ROS与32串口通讯（ROS端）只能接收不能发送"><a href="#ROS与32串口通讯（ROS端）只能接收不能发送" class="headerlink" title="ROS与32串口通讯（ROS端）只能接收不能发送"></a>ROS与32串口通讯（ROS端）只能接收不能发送</h3><p>​    被这个问题卡了很久。根据情况描述，既然都能正常接收了为什么发送会失败呢？</p><h4 id="ROS端"><a href="#ROS端" class="headerlink" title="ROS端"></a>ROS端</h4><p>​    在ROS端串口输出一个字符串所用到的函数是<strong>ser.write（string value）</strong>，在定时器的回调函数里面同时调用。首先就是检查定时器回调函数是否被成功调用，读取数据和发送数据都是在这个回调函数里调用的，那么基本上是没问题的，<strong>ROS_INFO</strong>一下确实没问题。同理<strong>SendMsgs( )</strong>一样成功调用了。那至少能肯定，<strong>write( )</strong>函数肯定被调用了呀。</p><p>​    中间还出了一点岔子，就是代码中不小心打上了一点乱码，结果编译出问题。但是编译日志也没有报错，我虽然看着和原来的不一样，但是没有太在意。但是这就导致了之前改完代码后好几次编译都是不通过的，一直运行的也是那个有问题的节点代码。所以如果编译日志同平时比较为反常，要当心一下。</p><p>​    接下来将<strong>nano</strong>的<strong>TX，RX</strong>短接，判断到底是不是nano端的问题。发现确实能自己接收到自己的消息，那就没问题了</p><p>​    nano端没问题了，估计就是32端的问题了。ros只能接受不能发送，是不是<strong>rx</strong>接对了但<strong>tx</strong>接错了呢？</p><blockquote><p>nano 8：TX——RX：stm32 PA10</p><p>nano 10: RX——TX：stm32 PA9</p></blockquote><p>再检验一遍着实无误。</p><h4 id="32端"><a href="#32端" class="headerlink" title="32端"></a>32端</h4><p>​    32端没有再配置一个串口，使用<strong>oled屏</strong>DEBUG，nano端使用cutecom通讯正常，32能接收到消息，换成ros发消息后32却是一点反应都没有，那这个时候就想到看看<strong>串口中断函数</strong>到底有没有被调用，32到底有没有接收到消息。我在该函数里面加了些语句：如果串口中断函数被调用的话oled就会显示。</p><p>​    那结果是没有反应。</p><p>​    实际上控制oled显示的时候输完内容，要加个<strong>refresh</strong>。同时<strong>while( )</strong>里在不断<strong>Set_Z( )</strong>,里面也会不断更新内容然后refresh，所以其实串口中断是被调用了的，但在这样的情况下看不到反应。最后是使用keil的<strong>在线调试功能</strong>设置<strong>断点</strong>发现的，其实调用了。这个时候再看一下函数关于接收到的消息的过滤，其实正点原子也说过——<strong>发送新行</strong>。cutecom会，但ros不会。最终在要发送的字符串后面加上<strong>\r\n</strong>，DEBUG结束。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul><li>函数调用因oled错误使用检查失败。</li><li>不会使用Jlink在线调试</li><li>忽视了ros和cutecom细节上的输出差异。</li></ul><p>如果这三点有一点不出问题的话，或许都能够早些找到，错误。在此非常感谢师兄的指点！</p><h2 id="LattePanda与其Arduino通讯"><a href="#LattePanda与其Arduino通讯" class="headerlink" title="LattePanda与其Arduino通讯"></a>LattePanda与其Arduino通讯</h2><p>本来打算使用stm32进行下游设备的控制，但是发现LattePanda集成了一块<strong>arduino</strong>，不好好利用一下实在是太可惜了。</p><h3 id="Arduino-IDE安装"><a href="#Arduino-IDE安装" class="headerlink" title="Arduino IDE安装"></a>Arduino IDE安装</h3><p>​    在官网<a href="https://www.arduino.cc/en/software">Software | Arduino</a>下载Linux版本的安装包。可是下载<strong>2.0.0</strong>版本的会显示<em>没有可执行的软件</em>，所以最后选择了<strong>1.8.19</strong>。lattepanda对应的版本是<strong>linux 64 bits</strong></p><p>在安装目录得到了<strong>.tar.xz</strong>文件，运行解压命令</p><p><code>tar -xvf arduino-1.8.19-linux64.tar.xz</code></p><p>进入解压得到的安装目录，运行安装脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd arduino-1.8.19/</span><br><span class="line">sudo ./install.sh</span><br></pre></td></tr></table></figure><p>看到返回 <em>done!</em> 后安装成功</p><h3 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h3><p>​    平时用电脑给arduino烧录程序需要用一根数据线将二者连接起来。那在lattepanda上就相当于把这个数据线在板子上画好了，再把电脑和arduino粘一块儿</p><p>​    这个数据线对应的串口号是<strong>/dev/ttyACM0</strong>；</p><p>​    对应的芯片型号是<strong>ATmega32u4</strong>，这在IDE里面找不到，实际上也叫<strong>Arduino Leonardo</strong></p><p>​    之后就可以烧程序和通讯了。</p><h3 id="移植ROS包时遇到的一点小问题"><a href="#移植ROS包时遇到的一点小问题" class="headerlink" title="移植ROS包时遇到的一点小问题"></a>移植ROS包时遇到的一点小问题</h3>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> ROS </tag>
            
            <tag> USART </tag>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/16/hello-world/"/>
      <url>/2022/08/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
