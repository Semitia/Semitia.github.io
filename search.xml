<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WeChat App Development Notes</title>
      <link href="/2023/05/19/WeChat-App-Notes/"/>
      <url>/2023/05/19/WeChat-App-Notes/</url>
      
        <content type="html"><![CDATA[<h1 id="微信小程序开发日记"><a href="#微信小程序开发日记" class="headerlink" title="微信小程序开发日记"></a>微信小程序开发日记</h1><p><a href="https://zhuanlan.zhihu.com/p/183551698">https://zhuanlan.zhihu.com/p/183551698</a></p><h1 id="WeUI"><a href="#WeUI" class="headerlink" title="WeUI"></a>WeUI</h1><p>index.wxml</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">page-meta</span> <span class="attr">root-font-size</span>=<span class="string">&quot;system&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">page-meta</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 设置页面根字体大小为系统默认值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;page&quot;</span> <span class="attr">data-weui-theme</span>=<span class="string">&quot;&#123;&#123;theme&#125;&#125;&quot;</span> <span class="attr">data-weui-mode</span>=<span class="string">&quot;&#123;&#123;mode&#125;&#125;&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 设置页面的类名为page，并绑定主题和模式数据 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;page__hd&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 设置页面头部的类名为page__hd --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">aria-role</span>=<span class="string">&quot;heading&quot;</span> <span class="attr">aria-level</span>=<span class="string">&quot;1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;page__title&quot;</span>&gt;</span>WeUI<span class="tag">&lt;/<span class="name">view</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 设置页面标题为WeUI，并设置其语义角色为heading --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;page__desc&quot;</span>&gt;</span>WeUI 是一套同微信原生视觉体验一致的基础样式库。<span class="tag">&lt;/<span class="name">view</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 设置页面描述为WeUI是一套同微信原生视觉体验一致的基础样式库，并设置其类名为page__desc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;page__bd page__bd_spacing&quot;</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 设置页面主体的类名为page__bd，并添加间距样式 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;kind-list&quot;</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!-- 设置列表的类名为kind-list --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;id&quot;</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 使用block标签进行列表渲染，遍历list数组，并使用id作为唯一标识符 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;kind-list__item&quot;</span>&gt;</span> </span><br><span class="line">                <span class="comment">&lt;!-- 设置列表项的类名为kind-list__item --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">view</span> <span class="attr">id</span>=<span class="string">&quot;&#123;&#123;item.id&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;weui-flex kind-list__item-hd &#123;&#123;item.open ? &#x27;kind-list__item-hd_show&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;kindToggle&quot;</span>&gt;</span> </span><br><span class="line">                    <span class="comment">&lt;!-- 设置列表项头部的类名为weui-flex kind-list__item-hd，并根据item.open的值动态添加或移除kind-list__item-hd_show类名，绑定点击事件为kindToggle函数，并设置id属性为item.id --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-flex__item&quot;</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span> </span><br><span class="line">                        <span class="comment">&lt;!-- 设置列表项名称为item.name，并设置其类名为weui-flex__item --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">image</span> <span class="attr">aria-role</span>=<span class="string">&quot;button&quot;</span> <span class="attr">aria-label</span>=<span class="string">&quot;&#123;&#123;item.open ? &#x27; 收起&#x27; : &#x27; 展开&#x27;&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;kind-list__img&quot;</span> <span class="attr">src</span>=<span class="string">&quot;images/icon_nav_&#123;&#123;item.id&#125;&#125;.png&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span> </span><br><span class="line">                        <span class="comment">&lt;!-- 设置列表项图标为images/icon_nav_&#123;&#123;item.id&#125;&#125;.png，并设置其类名为kind-list__img，设置其语义角色为button，并根据item.open的值动态设置其aria-label属性 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">view</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;&#123;&#123;item.open ? &#x27;false&#x27; : &#x27;true&#x27;&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;kind-list__item-bd &#123;&#123;item.open ? &#x27;kind-list__item-bd_show&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span> </span><br><span class="line">                    <span class="comment">&lt;!-- 设置列表项主体的类名为kind-list__item-bd，并根据item.open的值动态添加或移除kind-list__item-bd_show类名，同时设置其aria-hidden属性 --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cells &#123;&#123;item.open ? &#x27;weui-cells_show&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span> </span><br><span class="line">                        <span class="comment">&lt;!-- 设置列表项内容的类名为weui-cells，并根据item.open的值动态添加或移除weui-cells_show类名 --&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">block</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123;item.pages&#125;&#125;&quot;</span> <span class="attr">wx:for-item</span>=<span class="string">&quot;page&quot;</span> <span class="attr">wx:key</span>=<span class="string">&quot;*this&quot;</span>&gt;</span> </span><br><span class="line">                            <span class="comment">&lt;!-- 使用block标签进行列表渲染，遍历item.pages数组，并使用当前项作为唯一标识符 --&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">navigator</span> <span class="attr">aria-role</span>=<span class="string">&quot;menuitem&quot;</span> <span class="attr">url</span>=<span class="string">&quot;&#123;&#123;page&#125;&#125;/&#123;&#123;page&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell weui-cell_access&quot;</span> <span class="attr">hover-class</span>=<span class="string">&quot;weui-cell_active&quot;</span>&gt;</span></span><br><span class="line">                                <span class="comment">&lt;!-- 使用navigator标签进行页面跳转，设置跳转地址为&#123;&#123;page&#125;&#125;/&#123;&#123;page&#125;&#125;，并设置其类名为weui-cell weui-cell_access，设置其悬停样式为weui-cell_active，设置其语义角色为menuitem --&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__bd&quot;</span>&gt;</span>&#123;&#123;page&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span> </span><br><span class="line">                                    <span class="comment">&lt;!-- 设置导航项名称为&#123;&#123;page&#125;&#125;，并设置其类名为weui-cell__bd --&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;weui-cell__ft weui-cell__ft_in-access&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">view</span>&gt;</span> </span><br><span class="line">                                    <span class="comment">&lt;!-- 设置导航项右侧箭头图标，并设置其类名为weui-cell__ft weui-cell__ft_in-access --&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">navigator</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">block</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;page__ft&quot;</span> <span class="attr">bindtap</span>=<span class="string">&quot;changeTheme&quot;</span>&gt;</span> <span class="comment">&lt;!-- 设置页面底部的类名为page__ft，并绑定点击事件为changeTheme函数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">aria-label</span>=<span class="string">&quot;weui logo&quot;</span> <span class="attr">src</span>=<span class="string">&quot;images/icon_footer.png&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 84px; height: 19px;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span> <span class="comment">&lt;!-- 设置页面底部logo图片，并设置其aria-label属性和样式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="遍历list"><a href="#遍历list" class="headerlink" title="遍历list"></a>遍历list</h3><p>在这个代码中，用到了在<strong>index.js</strong>中定义的一些数据，比如双括号<code>&#123;&#123;list&#125;&#125;</code>就是调用<code>data</code>中的<code>list</code></p><p>在绘制5个可以点击的列表的时候，用了类似于<strong>for循环</strong>？<code>&lt;block wx:for=&quot;&#123;&#123;list&#125;&#125;&quot; wx:key=&quot;id&quot;&gt;</code></p><p>这个就是遍历<code>list</code> 中的5个元素。在循环体内部有多次用到<code>**ietem**</code>这个变量，这是默认的变量名，表示在list中遍历到的<strong>当前元素</strong>，并不需要声明。同样的还有<code>**index</code><strong> 表示</strong>元素下标。**当然也可以自己用别的名字来命名</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;block <span class="attr">wx</span>:<span class="keyword">for</span>=<span class="string">&quot;&#123;&#123;list&#125;&#125;&quot;</span> <span class="attr">wx</span>:<span class="keyword">for</span>-item=<span class="string">&quot;obj&quot;</span> <span class="attr">wx</span>:<span class="keyword">for</span>-index=<span class="string">&quot;idx&quot;</span>&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123;idx&#125;&#125;: &#123;&#123;[obj.name](http://obj.name/)&#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span></span><br><span class="line">&lt;/block&gt;</span><br></pre></td></tr></table></figure><h3 id="展示列表组件"><a href="#展示列表组件" class="headerlink" title="展示列表组件"></a>展示列表组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;&#123;&#123;item.open ? &#x27;false&#x27; : &#x27;true&#x27;&#125;&#125;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;kind-list__item-bd &#123;&#123;item.open ? &#x27;kind-list__item-bd_show&#x27; : &#x27;&#x27;&#125;&#125;&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><p><code>aria-hidden</code>是一个用来提高无障碍访问性的属性，表示当前组件<strong>是否可见</strong>。在<code>open</code>等于0或1的时候，aria-hidden分别等于<strong>true</strong>和<strong>false</strong>，表示组件是否隐藏。<code>class</code>分别等于<strong>kind-list__item-bd</strong>和<strong>kind-list<strong>item-bd kind-list</strong>item-bd_show</strong>，表示组件是否有显示的样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;true&quot;</span> <span class="attr">class</span>=<span class="string">&quot;kind-list__item-bd&quot;</span>&gt;</span>Hidden<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">aria-hidden</span>=<span class="string">&quot;false&quot;</span> <span class="attr">class</span>=<span class="string">&quot;kind-list__item-bd kind-list__item-bd_show&quot;</span>&gt;</span>Shown<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="链接转跳"><a href="#链接转跳" class="headerlink" title="链接转跳"></a>链接转跳</h3><p><code>aria-role</code>表示组件的角色，比如button, img等等，当读屏模式下聚焦到该组件时，系统会朗读出相应的角色。（我不是根理解这句话）</p><p><code>url=&quot;&#123;&#123;page&#125;&#125;/&#123;&#123;page&#125;&#125;&quot;</code> 这里就是转跳到同级目录下page文件夹下的page.wxml对应界面</p><p><code>hover-class</code>属性表示按下去的样式类，可以用来实现点击态效果</p><p>index.js</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line"><span class="attr">mixins</span>: [<span class="built_in">require</span>(<span class="string">&#x27;../mixin/common&#x27;</span>)], <span class="comment">// 引入common.js文件作为页面的混入，可以复用common.js文件中定义的数据、方法等</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">list</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;form&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;表单&#x27;</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">pages</span>: [<span class="string">&#x27;button&#x27;</span>, <span class="string">&#x27;input&#x27;</span>, <span class="string">&#x27;form&#x27;</span>, <span class="string">&#x27;list&#x27;</span>, <span class="string">&#x27;slideview&#x27;</span>, <span class="string">&#x27;slider&#x27;</span>, <span class="string">&#x27;uploader&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;layout&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;基础组件&#x27;</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">pages</span>: [<span class="string">&#x27;article&#x27;</span>, <span class="string">&#x27;badge&#x27;</span>, <span class="string">&#x27;flex&#x27;</span>, <span class="string">&#x27;footer&#x27;</span>, <span class="string">&#x27;gallery&#x27;</span>, <span class="string">&#x27;grid&#x27;</span>, <span class="string">&#x27;icons&#x27;</span>, <span class="string">&#x27;loading&#x27;</span>, <span class="string">&#x27;loadmore&#x27;</span>, <span class="string">&#x27;panel&#x27;</span>, <span class="string">&#x27;preview&#x27;</span>, <span class="string">&#x27;progress&#x27;</span>, <span class="string">&#x27;steps&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;feedback&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;操作反馈&#x27;</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">pages</span>: [<span class="string">&#x27;actionsheet&#x27;</span>, <span class="string">&#x27;dialog&#x27;</span>, <span class="string">&#x27;half-screen-dialog&#x27;</span>, <span class="string">&#x27;msg&#x27;</span>, <span class="string">&#x27;picker&#x27;</span>, <span class="string">&#x27;toast&#x27;</span>, <span class="string">&#x27;top-tips&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;nav&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;导航相关&#x27;</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">pages</span>: [<span class="string">&#x27;navigation-bar&#x27;</span>, <span class="string">&#x27;tabbar&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;search&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;搜索相关&#x27;</span>,</span><br><span class="line">        <span class="attr">open</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">pages</span>: [<span class="string">&#x27;searchbar&#x27;</span>],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">changeTheme</span>(<span class="params"></span>) &#123; <span class="comment">// 定义一个事件处理函数，用于点击页面底部时切换主题</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">data</span>); <span class="comment">// 打印当前页面数据到控制台，方便调试</span></span><br><span class="line">    <span class="title function_">getApp</span>().<span class="title function_">themeChanged</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">theme</span> === <span class="string">&#x27;light&#x27;</span> ? <span class="string">&#x27;dark&#x27;</span> : <span class="string">&#x27;light&#x27;</span>); <span class="comment">// 调用全局函数themeChanged，传入一个参数，根据当前页面数据中的theme属性的值判断是切换为dark还是light主题</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>事件回调函数（我这样称呼它）</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">kindToggle</span>(<span class="params">e</span>) &#123; <span class="comment">// 定义一个事件处理函数，用于点击列表项时切换其展开或收起状态</span></span><br><span class="line">    <span class="keyword">const</span> &#123; id &#125; = e.<span class="property">currentTarget</span>; <span class="comment">// 获取当前点击的列表项的id</span></span><br><span class="line">    <span class="keyword">const</span> &#123; list &#125; = <span class="variable language_">this</span>.<span class="property">data</span>; <span class="comment">// 获取页面数据中的list数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = list.<span class="property">length</span>; i &lt; len; ++i) &#123; <span class="comment">// 遍历list数组</span></span><br><span class="line">      <span class="keyword">if</span> (list[i].<span class="property">id</span> == id) &#123; <span class="comment">// 如果当前元素的id和点击的id相同</span></span><br><span class="line">        list[i].<span class="property">open</span> = !list[i].<span class="property">open</span>; <span class="comment">// 则切换其open属性的值，实现展开或收起效果</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则</span></span><br><span class="line">        list[i].<span class="property">open</span> = <span class="literal">false</span>; <span class="comment">// 将其open属性设为false，实现收起效果</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123; <span class="comment">// 调用setData方法更新页面数据</span></span><br><span class="line">      list, <span class="comment">// 将修改后的list数组传入</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>在之前的代码中可以得知这个是在点击之后触发的事件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;view <span class="keyword">class</span>=<span class="string">&quot;item&quot;</span> bindtap=<span class="string">&quot;kindToggle&quot;</span> data-id=<span class="string">&quot;&#123;&#123;[item.id](http://item.id/)&#125;&#125;&quot;</span>&gt;&#123;&#123;[item.<span class="property">name</span>](<span class="attr">http</span>:<span class="comment">//item.name/)&#125;&#125;&lt;/view&gt;</span></span><br></pre></td></tr></table></figure><p>函数形参<code>e</code>是一个事件对象，它包含了事件的相关信息，比如触发事件的源组件、事件类型、时间戳等。e是一个形参，可以用任何合法的变量名来代替它，只要在函数体内保持一致即可。e是由wxml文件中的bindtap属性传递给kindToggle函数的，当点击某个组件时，就会触发bindtap绑定的函数，并将事件对象作为参数传入。</p><p>这里面的<code>this</code> 指向包含该函数的Page对象，它可以访问Page对象中定义的数据和方法。例如：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;Hello World&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">test</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">content</span>); <span class="comment">// Hello World</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 物联网开发 </tag>
            
            <tag> 微信小程序 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scattered Python scripts</title>
      <link href="/2023/05/18/scattered-Python-scripts/"/>
      <url>/2023/05/18/scattered-Python-scripts/</url>
      
        <content type="html"><![CDATA[<p>在处理数据，绘图，批量处理文件时，python能大大提高工作的效率，这篇文章就记录一下在各种场景下常用的一些功能实现。</p><h2 id="批量复制"><a href="#批量复制" class="headerlink" title="批量复制"></a>批量复制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入os和shutil模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义源目录和目标目录的路径，注意要用绝对路径或相对路径</span></span><br><span class="line">source_dir = <span class="string">&quot;C:/Users/xxx/source&quot;</span> <span class="comment"># 源目录，假设是C盘下的source文件夹</span></span><br><span class="line">target_dir = <span class="string">&quot;C:/Users/xxx/target&quot;</span> <span class="comment"># 目标目录，假设是C盘下的target文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历源目录下的所有子文件夹和文件</span></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(source_dir):</span><br><span class="line">    <span class="comment"># 对于每一个文件，获取它的完整路径</span></span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">        file_path = os.path.join(root, file)</span><br><span class="line">        <span class="comment"># 复制或移动文件到目标目录，注意要保留原来的文件名</span></span><br><span class="line">        <span class="comment"># 如果要复制文件，用shutil.copy，如果要移动文件，用shutil.move</span></span><br><span class="line">        shutil.copy(file_path, target_dir) <span class="comment"># 复制文件</span></span><br><span class="line">        <span class="comment"># shutil.move(file_path, target_dir) # 移动文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印完成提示信息</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;All files have been copied or moved to the target directory.&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="显示obj模型"><a href="#显示obj模型" class="headerlink" title="显示obj模型"></a>显示obj模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入open3d库</span></span><br><span class="line"><span class="keyword">import</span> open3d <span class="keyword">as</span> o3d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件中读取obj格式的网格</span></span><br><span class="line">mesh = o3d.io.read_triangle_mesh(<span class="string">&quot;D:/WORK/DTact/obj_gather/00000003_1ffb81a71e5b402e966b9341_trimesh_002.obj&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算网格的顶点法线</span></span><br><span class="line">mesh.compute_vertex_normals()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在一个OpenGL窗口中显示网格</span></span><br><span class="line">o3d.visualization.draw_geometries([mesh])</span><br></pre></td></tr></table></figure><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="comment"># print(matplotlib.__version__)</span></span><br><span class="line"></span><br><span class="line">h=<span class="number">0.04494988870551895</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取./6d_force/food文件夹下food.npy</span></span><br><span class="line">data_list = np.load(<span class="string">&quot;./6d_force/food/food.npy&quot;</span>)</span><br><span class="line"><span class="comment"># 创建6个空列表来存储x,y,z方向的力和力矩</span></span><br><span class="line">force_x = []</span><br><span class="line">force_y = []</span><br><span class="line">force_z = []</span><br><span class="line">torque_x = []</span><br><span class="line">torque_y = []</span><br><span class="line">torque_z = []</span><br><span class="line"><span class="comment">#给6个列表赋值</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> data_list:</span><br><span class="line">    force_x.append(data[<span class="number">0</span>])</span><br><span class="line">    force_y.append(data[<span class="number">1</span>])</span><br><span class="line">    force_z.append(data[<span class="number">2</span>])</span><br><span class="line">    torque_x.append(data[<span class="number">3</span>])</span><br><span class="line">    torque_y.append(data[<span class="number">4</span>])</span><br><span class="line">    torque_z.append(data[<span class="number">5</span>])</span><br><span class="line"><span class="comment"># 绘制各个力和力矩的分布直方图</span></span><br><span class="line"><span class="comment"># plt.figure()</span></span><br><span class="line"><span class="comment"># plt.subplot(2,3,1)#画布分为2行3列6个子图，这是第1个子图</span></span><br><span class="line"><span class="comment"># plt.hist(force_x, bins=100)#直方图，bins表示直方图的柱数，也就是100个子区间</span></span><br><span class="line"><span class="comment"># plt.title(&quot;force_x&quot;)</span></span><br><span class="line"><span class="comment"># plt.subplot(2,3,2)</span></span><br><span class="line"><span class="comment"># plt.hist(force_y, bins=100)</span></span><br><span class="line"><span class="comment"># plt.title(&quot;force_y&quot;)</span></span><br><span class="line"><span class="comment"># plt.subplot(2,3,3)</span></span><br><span class="line"><span class="comment"># plt.hist(force_z, bins=100)</span></span><br><span class="line"><span class="comment"># plt.title(&quot;force_z&quot;)</span></span><br><span class="line"><span class="comment"># plt.subplot(2,3,4)</span></span><br><span class="line"><span class="comment"># plt.hist(torque_x, bins=100)</span></span><br><span class="line"><span class="comment"># plt.title(&quot;torque_x&quot;)</span></span><br><span class="line"><span class="comment"># plt.subplot(2,3,5)</span></span><br><span class="line"><span class="comment"># plt.hist(torque_y, bins=100)</span></span><br><span class="line"><span class="comment"># plt.title(&quot;torque_y&quot;)</span></span><br><span class="line"><span class="comment"># plt.subplot(2,3,6)</span></span><br><span class="line"><span class="comment"># plt.hist(torque_z, bins=100)</span></span><br><span class="line"><span class="comment"># plt.title(&quot;torque_z&quot;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制六边形图</span></span><br><span class="line"><span class="comment"># plt.hexbin(force_x, force_y, gridsize=20)</span></span><br><span class="line"><span class="comment"># plt.xlabel(&#x27;force_x&#x27;)</span></span><br><span class="line"><span class="comment"># plt.ylabel(&#x27;force_y&#x27;)</span></span><br><span class="line"><span class="comment"># plt.colorbar()</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 假设你的force_x和force_y是列表</span></span><br><span class="line"><span class="comment"># force_x = pd.Series (force_x)</span></span><br><span class="line"><span class="comment"># force_y = pd.Series (force_y)</span></span><br><span class="line"><span class="comment"># force_z = pd.Series (force_z)</span></span><br><span class="line"><span class="comment"># # 绘制单变量核密度图</span></span><br><span class="line"><span class="comment"># force_z.plot.kde (color=&#x27;red&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show ()</span></span><br><span class="line"><span class="comment"># # 绘制双变量核密度图</span></span><br><span class="line"><span class="comment"># df = pd.DataFrame (&#123;&#x27;force_x&#x27;: force_x, &#x27;force_y&#x27;: force_y&#125;)</span></span><br><span class="line"><span class="comment"># df.plot.kde ()</span></span><br><span class="line"><span class="comment"># plt.show ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pd.Series (force_x).plot.kde (color=&#x27;red&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 散点图</span></span><br><span class="line"><span class="comment">#force_x 和 force_y</span></span><br><span class="line"><span class="comment"># plt.scatter (force_x, force_y, s=0.1, color=&#x27;blue&#x27;)</span></span><br><span class="line"><span class="comment"># plt.xlabel (&#x27;force_x&#x27;)</span></span><br><span class="line"><span class="comment"># plt.ylabel (&#x27;force_y&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># torque_x 和 torque_y</span></span><br><span class="line"><span class="comment"># plt.scatter (torque_x, torque_y, s=0.1, color=&#x27;blue&#x27;)</span></span><br><span class="line"><span class="comment"># plt.xlabel (&#x27;torque_x&#x27;)</span></span><br><span class="line"><span class="comment"># plt.ylabel (&#x27;torque_y&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># force_y and torque_x</span></span><br><span class="line"><span class="comment"># plt.scatter (force_y, torque_x, s=0.1, color=&#x27;blue&#x27;)</span></span><br><span class="line"><span class="comment"># plt.xlabel (&#x27;force_y&#x27;)</span></span><br><span class="line"><span class="comment"># plt.ylabel (&#x27;torque_x&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># force_x and torque_y</span></span><br><span class="line"><span class="comment"># plt.scatter (force_x, torque_y, s=0.1, color=&#x27;blue&#x27;)</span></span><br><span class="line"><span class="comment"># plt.xlabel (&#x27;force_x&#x27;)</span></span><br><span class="line"><span class="comment"># plt.ylabel (&#x27;torque_y&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.show ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制三维曲面图</span></span><br><span class="line"><span class="comment"># fig = plt.figure()</span></span><br><span class="line"><span class="comment"># ax = fig.add_subplot(111, projection=&#x27;3d&#x27;)</span></span><br><span class="line"><span class="comment"># ax.plot_surface(force_x, force_y, force_z)</span></span><br><span class="line"><span class="comment"># ax.set_xlabel(&#x27;force_x&#x27;)</span></span><br><span class="line"><span class="comment"># ax.set_ylabel(&#x27;force_y&#x27;)</span></span><br><span class="line"><span class="comment"># ax.set_zlabel(&#x27;force_z&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制三维散点图</span></span><br><span class="line"><span class="comment"># fig = plt.figure()</span></span><br><span class="line"><span class="comment"># ax = fig.add_subplot(111, projection=&#x27;3d&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # force_x and force_y and force_z</span></span><br><span class="line"><span class="comment"># ax.scatter3D(force_x, force_y, force_z, s=0.1,color=&#x27;red&#x27;)</span></span><br><span class="line"><span class="comment"># ax.set_xlabel(&#x27;force_x&#x27;)</span></span><br><span class="line"><span class="comment"># ax.set_ylabel(&#x27;force_y&#x27;)</span></span><br><span class="line"><span class="comment"># ax.set_zlabel(&#x27;force_z&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # torque_x and torque_y and torque_z</span></span><br><span class="line"><span class="comment"># # ax.scatter3D(torque_x, torque_y, torque_z,s=0.1,color=&#x27;red&#x27;)</span></span><br><span class="line"><span class="comment"># # ax.set_xlabel(&#x27;torque_x&#x27;)</span></span><br><span class="line"><span class="comment"># # ax.set_ylabel(&#x27;torque_y&#x27;)</span></span><br><span class="line"><span class="comment"># # ax.set_zlabel(&#x27;torque_z&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#位置分布</span></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"></span><br><span class="line">center_list = np.load(<span class="string">&quot;./image/food/food.npy&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> center <span class="keyword">in</span> center_list:</span><br><span class="line">    x.append(center[<span class="number">0</span>])</span><br><span class="line">    y.append(center[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># x[i] = torque_y[i]/force_z[i]</span></span><br><span class="line"><span class="comment"># y[i] = torque_x[i]/force_z[i]</span></span><br><span class="line"><span class="comment">#给x,y列表赋值</span></span><br><span class="line"><span class="comment"># Mx = -Fy*h + Fz*y</span></span><br><span class="line"><span class="comment"># My =  Fx*h - Fz*x</span></span><br><span class="line"><span class="comment"># x = (Fx*h - My)/Fz</span></span><br><span class="line"><span class="comment"># y = (Mx + Fy*h)/Fz</span></span><br><span class="line"><span class="comment"># len = len(force_x)</span></span><br><span class="line"><span class="comment"># #for遍历列表</span></span><br><span class="line"><span class="comment"># for i in range(len):</span></span><br><span class="line"><span class="comment">#     #每行打印一个列表中的六个值</span></span><br><span class="line"><span class="comment">#     # print(force_x[i], force_y[i], force_z[i], torque_x[i], torque_y[i], torque_z[i])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#     x.append((force_x[i]*h-torque_y[i])/force_z[i])</span></span><br><span class="line"><span class="comment">#     y.append((torque_x[i]+force_y[i]*h)/force_z[i])</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.distplot(x, kde=True)</span></span><br><span class="line"><span class="comment"># # plt.xlim(-0.02, 0.02)</span></span><br><span class="line"><span class="comment"># plt.xlabel(&#x27;x&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"><span class="comment"># sns.distplot(y, kde=True)</span></span><br><span class="line"><span class="comment"># # plt.xlim(-0.02, 0.02)</span></span><br><span class="line"><span class="comment"># plt.xlabel(&#x27;y&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line">My_fx = []</span><br><span class="line">Mx_fy = []</span><br><span class="line">scale_x = <span class="number">400</span></span><br><span class="line">scale_y = <span class="number">400</span></span><br><span class="line">bias_x = <span class="number">1</span></span><br><span class="line">bias_y = <span class="number">0.5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(x)):</span><br><span class="line">    x[i] = x[i]/scale_x-bias_x</span><br><span class="line">    y[i] = y[i]/scale_y-bias_y</span><br><span class="line">    Mx_fy.append(torque_x[i] - force_z[i]*y[i]) </span><br><span class="line">    My_fx.append(torque_y[i] + force_z[i]*x[i]) </span><br><span class="line">sns.jointplot(x=Mx_fy, y=force_y, kind=<span class="string">&#x27;kde&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">sns.<span class="built_in">set</span>(style=<span class="string">&quot;whitegrid&quot;</span>)</span><br><span class="line">tips = sns.load_dataset(<span class="string">&quot;tips&quot;</span>)</span><br><span class="line">g = sns.jointplot(x=force_x, y=force_y, kind=<span class="string">&#x27;kde&#x27;</span>, color=<span class="string">&#x27;purple&#x27;</span>)</span><br><span class="line">g.plot_joint(sns.kdeplot,fill=<span class="literal">True</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制分布直方图，范围为-0.02到0.02，分为100个子区间</span></span><br><span class="line"><span class="comment"># plt.hist(x, bins=100,range=(-0.02,0.02))</span></span><br><span class="line"><span class="comment"># plt.title(&quot;x&quot;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"><span class="comment"># plt.hist(y, bins=100)</span></span><br><span class="line"><span class="comment"># plt.title(&quot;y&quot;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"><span class="comment"># 绘制两者的散点图,范围-0.02到0.02</span></span><br><span class="line"><span class="comment"># plt.scatter (force_z, x, s=0.1, color=&#x27;blue&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## seaborn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制六个单变量核密度图</span></span><br><span class="line"><span class="comment"># sns.distplot(force_x, kde=True)</span></span><br><span class="line"><span class="comment"># plt.xlabel(&#x27;force_x&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"><span class="comment"># sns.distplot(force_y, kde=True)</span></span><br><span class="line"><span class="comment"># plt.xlabel(&#x27;force_y&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"><span class="comment"># sns.distplot(force_z, kde=True)</span></span><br><span class="line"><span class="comment"># plt.xlabel(&#x27;force_z&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"><span class="comment"># sns.distplot(torque_x, kde=True)</span></span><br><span class="line"><span class="comment"># plt.xlabel(&#x27;torque_x&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"><span class="comment"># sns.distplot(torque_y, kde=True)</span></span><br><span class="line"><span class="comment"># plt.xlabel(&#x27;torque_y&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"><span class="comment"># sns.distplot(torque_z, kde=True)</span></span><br><span class="line"><span class="comment"># plt.xlabel(&#x27;torque_z&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制六个双变量核密度图</span></span><br><span class="line"><span class="comment"># sns.jointplot(x=force_x, y=force_y, kind=&#x27;kde&#x27;)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"><span class="comment"># sns.set(style=&quot;whitegrid&quot;)</span></span><br><span class="line"><span class="comment"># tips = sns.load_dataset(&quot;tips&quot;)</span></span><br><span class="line"><span class="comment"># g = sns.jointplot(x=force_x, y=force_y, kind=&#x27;kde&#x27;, color=&#x27;purple&#x27;)</span></span><br><span class="line"><span class="comment"># g.plot_joint(sns.kdeplot,fill=True)</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br></pre></td></tr></table></figure><p>需要注意的一点是matplotlib的版本，建议更新到最新版。我一开始下载的旧版结果一直报错，后来才发现是库的bug</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img_list = []</span><br><span class="line">tresh_list = []</span><br><span class="line">center_list = []</span><br><span class="line"><span class="comment"># 读取./cliber/geometry所有子文件夹下所有图片并转换为灰度图像</span></span><br><span class="line"><span class="keyword">for</span> subfolder <span class="keyword">in</span> os.listdir(<span class="string">&quot;./cliber/geometry&quot;</span>):</span><br><span class="line">    subfolder_path = os.path.join(<span class="string">&quot;./cliber/geometry&quot;</span>, subfolder)</span><br><span class="line">    <span class="keyword">for</span> file <span class="keyword">in</span> os.listdir(subfolder_path):</span><br><span class="line">        file_path = os.path.join(subfolder_path, file)</span><br><span class="line">        img = cv2.imread(file_path)</span><br><span class="line">        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        <span class="comment"># 二值化灰度图像，阈值可以根据实际情况调整</span></span><br><span class="line">        ret, thresh = cv2.threshold(gray, <span class="number">150</span>, <span class="number">255</span>, cv2.THRESH_BINARY_INV)</span><br><span class="line">        <span class="comment"># 寻找白色区域的轮廓</span></span><br><span class="line">        contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">        filted_contours = []</span><br><span class="line">        centroids = []</span><br><span class="line">        areas = []</span><br><span class="line">        <span class="comment">#遍历轮廓列表</span></span><br><span class="line">        <span class="keyword">for</span> contour <span class="keyword">in</span> contours:</span><br><span class="line">            <span class="comment">#剔除面积等于0的轮廓</span></span><br><span class="line">            area = cv2.contourArea(contour)</span><br><span class="line">            <span class="keyword">if</span> area &gt; <span class="number">0</span>:</span><br><span class="line">                filted_contours.append(contour)</span><br><span class="line">                M = cv2.moments(contour)</span><br><span class="line">                cx = <span class="built_in">int</span>(M[<span class="string">&#x27;m10&#x27;</span>]/M[<span class="string">&#x27;m00&#x27;</span>])</span><br><span class="line">                cy = <span class="built_in">int</span>(M[<span class="string">&#x27;m01&#x27;</span>]/M[<span class="string">&#x27;m00&#x27;</span>])</span><br><span class="line">                centroids.append([cx, cy])</span><br><span class="line">                areas.append(area)</span><br><span class="line">        <span class="comment">#如果areas列表为空，则说明没有找到白色区域，跳过此次循环</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(areas) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        centroids = np.array(centroids)</span><br><span class="line">        areas = np.array(areas)</span><br><span class="line">        Cx = np.<span class="built_in">sum</span>(centroids[:,<span class="number">0</span>]*areas)/np.<span class="built_in">sum</span>(areas)</span><br><span class="line">        Cy = np.<span class="built_in">sum</span>(centroids[:,<span class="number">1</span>]*areas)/np.<span class="built_in">sum</span>(areas)</span><br><span class="line">        <span class="comment">#转换为整数</span></span><br><span class="line">        Cx = <span class="built_in">int</span>(Cx)</span><br><span class="line">        Cy = <span class="built_in">int</span>(Cy)</span><br><span class="line">        <span class="comment">#将形心坐标添加到列表中</span></span><br><span class="line">        center_list.append([Cx, Cy])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 打印图像名称和形心坐标</span></span><br><span class="line">        <span class="comment"># print(file, Cx, Cy)</span></span><br><span class="line">        <span class="comment"># 在原图上绘制形心点和轮廓</span></span><br><span class="line">        <span class="comment"># cv2.circle(img, (Cx, Cy), 5, (0, 0, 255), -1)</span></span><br><span class="line">        <span class="comment"># cv2.drawContours(img, filted_contours, -1, (0, 255, 0), 2)</span></span><br><span class="line">        <span class="comment"># 将修改后的图像保存到./cliber/mark_result文件夹下</span></span><br><span class="line">        <span class="comment"># cv2.imwrite(&quot;./cliber/mark_result/&quot;+file, img)</span></span><br><span class="line"><span class="comment"># 将center_list保存到./cliber/geometry/center.npy文件中</span></span><br><span class="line">np.save(<span class="string">&quot;./cliber/geometry/center.npy&quot;</span>, center_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 显示结果</span></span><br><span class="line"><span class="comment"># cv2.imshow(&quot;Result&quot;, img)</span></span><br><span class="line"><span class="comment"># cv2.waitKey(0)</span></span><br><span class="line"><span class="comment"># cv2.destroyAllWindows()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个窗口，设置标题和大小</span></span><br><span class="line"><span class="comment">#plt.figure(&quot;Thresholding&quot;, figsize=(10, 5))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 在窗口中绘制两个子图，左边是原图，右边是二值化后的图像</span></span><br><span class="line"><span class="comment"># plt.subplot(121), plt.imshow(img, cmap=&quot;gray&quot;), plt.title(&quot;Original&quot;)</span></span><br><span class="line"><span class="comment"># plt.subplot(122), plt.imshow(thresh, cmap=&quot;gray&quot;), plt.title(&quot;Thresholded&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># # 显示窗口</span></span><br><span class="line"><span class="comment"># plt.show()</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello,C51!</title>
      <link href="/2023/05/18/hello-C51/"/>
      <url>/2023/05/18/hello-C51/</url>
      
        <content type="html"><![CDATA[<p>学校教学用的是汇编，正好之前也没有怎么学过，一起学一学</p><h1 id="C51"><a href="#C51" class="headerlink" title="C51"></a>C51</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h3><p>计算1到5的和，并把结果存储在SUM这个地址中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    ;定义两个地址常量</span><br><span class="line">    INDEX EQU 20H ;索引寄存器，用于循环计数</span><br><span class="line">    SUM EQU 21H ;和寄存器，用于存储结果</span><br><span class="line"></span><br><span class="line">    ;定义程序起始地址</span><br><span class="line">    ORG 0000H</span><br><span class="line">START: ;程序开始标签</span><br><span class="line">    MOV INDEX, #5 ;把5赋值给索引寄存器</span><br><span class="line">    MOV A, #0 ;把0赋值给累加器A</span><br><span class="line">LOOP: ;循环开始标签</span><br><span class="line">    ADD A, INDEX ;把索引寄存器的值加到累加器A上</span><br><span class="line">    DJNZ INDEX, LOOP ;索引寄存器减1，如果不为0则跳转到循环开始标签</span><br><span class="line">    MOV SUM, A ;把累加器A的值赋值给和寄存器</span><br><span class="line">    SJMP $ ;无限循环，程序结束</span><br><span class="line">    END ;程序结束标签</span><br></pre></td></tr></table></figure><ul><li><code>EQU</code>是英文单词equal的缩写，用于定义一个符号常量，不占用存储空间12。比如，COUNT EQU 100就是把100赋值给符号名COUNT，以后在程序中使用COUNT就相当于使用100。</li><li><code>INDEX</code>是一个符号名，可以用EQU或其他方式定义，用于表示一个地址或一个数值。比如，INDEX EQU 20H就是把20H赋值给符号名INDEX，以后在程序中使用INDEX就相当于使用20H。</li><li><code>DJNZ</code>是一个指令助记符，表示递减并跳转（Decrement and Jump if Not Zero）。它的格式是DJNZ Rn, label或DJNZ direct, label，表示把寄存器Rn或直接寻址单元的内容减1，如果结果不为0，则跳转到标签label处执行3。比如，DJNZ INDEX, LOOP就是把索引寄存器INDEX的内容减1，如果不为0则跳转到循环开始标签LOOP处执行。</li><li><code>ORG</code>是英文单词Origin的缩写，表示起始地址或源。它是一个伪指令，用于指定程序的起始偏移地址12。比如，ORG 2000H就是把2000H作为程序的起始偏移地址。</li></ul><h3 id="demo2"><a href="#demo2" class="headerlink" title="demo2"></a>demo2</h3><p>赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ORG 0000H</span><br><span class="line">CLR A </span><br><span class="line">MOV DPTR, #200AH</span><br><span class="line">MOVX @DPTR, A </span><br><span class="line">SJMP $</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="demo3"><a href="#demo3" class="headerlink" title="demo3"></a>demo3</h3><p>批量填充数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    ; 声明一个常量，表示要填充的数据</span><br><span class="line">    DATA EQU 9CH</span><br><span class="line">    ; 声明一个常量，表示要填充的起始地址</span><br><span class="line">    START EQU 2010H</span><br><span class="line">    ; 声明一个常量，表示要填充的单元个数</span><br><span class="line">    COUNT EQU 256</span><br><span class="line"></span><br><span class="line">    ; 设置程序入口点</span><br><span class="line">    ORG 0000H</span><br><span class="line">    ; 跳转到主程序</span><br><span class="line">    AJMP MAIN</span><br><span class="line"></span><br><span class="line">; 主程序</span><br><span class="line">MAIN:</span><br><span class="line">    ; 将要填充的数据送入累加器</span><br><span class="line">    MOV A, #DATA</span><br><span class="line">    ; 将要填充的起始地址送入DPTR寄存器</span><br><span class="line">    MOV DPTR, #START</span><br><span class="line">    ; 将要填充的单元个数送入R0寄存器</span><br><span class="line">    MOV R0, #COUNT</span><br><span class="line"></span><br><span class="line">; 循环开始</span><br><span class="line">LOOP:</span><br><span class="line">    ; 将累加器中的数据写入DPTR指向的单元</span><br><span class="line">    MOVX @DPTR, A</span><br><span class="line">    ; 将DPTR加1，指向下一个单元</span><br><span class="line">    INC DPTR</span><br><span class="line">    ; 将R0减1，表示剩余的单元个数</span><br><span class="line">    DJNZ R0, LOOP</span><br><span class="line"></span><br><span class="line">; 循环结束，停止运行</span><br><span class="line">STOP:</span><br><span class="line">    SJMP STOP</span><br><span class="line"></span><br><span class="line">    END ; 程序结束</span><br></pre></td></tr></table></figure><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><blockquote><p>一个数码管是由八个发光二进管组成，用跳线将数码管位选 S1~S8 连接到 P1.0~P1.7，段选 A~H 接到单片机 IO 口 P2.0~P2.7。拨动开关 1~8 接到单片机 IO 口 P0.0~P0.7。将 EA 用跳线上拉到 VCC，程序从片内启动。</p></blockquote><h3 id="demo4"><a href="#demo4" class="headerlink" title="demo4"></a>demo4</h3><p>中断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ORG 0</span><br><span class="line">AJMP STAR</span><br><span class="line"></span><br><span class="line">ORG 0003H ;中断入口地址：INT0:0003H; TIM0:000BH</span><br><span class="line">;INT1:0013H; TIM1:001BH; UART:0023H</span><br><span class="line">RL A</span><br><span class="line">MOV P2,A</span><br><span class="line">RETI;中断返回函数</span><br><span class="line">STAR:</span><br><span class="line">MOV P1,#0FBH ;第三个数码管亮</span><br><span class="line">MOV A,#0FEH</span><br><span class="line">MOV P2,A</span><br><span class="line">SETB EA ;置 EA=1</span><br><span class="line">SETB EX0 ;允许 INT0 中断</span><br><span class="line">SETB IT0 ;边缘触发中断</span><br><span class="line">SJMP $</span><br></pre></td></tr></table></figure><h3 id="demo5"><a href="#demo5" class="headerlink" title="demo5"></a>demo5</h3><p><strong>记录并显示 INT0 中断次数(中断次数&lt;16 次)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ORG 0</span><br><span class="line">AJMP NT</span><br><span class="line">ORG 0003H</span><br><span class="line">AJMP INTOR</span><br><span class="line">NT:</span><br><span class="line">MOV IE,#81H ;允许 INT0 中断，置 EA=1</span><br><span class="line">SETB IT0 ;边沿触发中断</span><br><span class="line">MOVR0,#0 ;计数初值为 0</span><br><span class="line">BIOU:</span><br><span class="line">MOV P1,#0FEH ;第一个数码管显示中断次数</span><br><span class="line">MOV DPTR,#TAB0 ;字形码表送 DPTR</span><br><span class="line">MOV A,R0</span><br><span class="line">MOVC A,@A+DPTR ;查表</span><br><span class="line">MOV P2,A ;显示</span><br><span class="line">SJMP $ ;结束</span><br><span class="line">INTOR:</span><br><span class="line">INC R0 ;中断次数加 1</span><br><span class="line">CJNE R0,#010H,RET0 ;中断是否满 15 次</span><br><span class="line">MOV R0,#0 ;循环</span><br><span class="line">RET0:</span><br><span class="line">POP DPH ;从堆栈弹出断点地址</span><br><span class="line">POP DPL</span><br><span class="line">MOV DPTR,#BIOU</span><br><span class="line">PUSH DPL ;修改中断返回点</span><br><span class="line">PUSH DPH</span><br><span class="line">RETI</span><br><span class="line">TAB0:</span><br><span class="line">DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H,80H,90H,88H,83H,0C6H,0A1H,86H,8EH,0FFH</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="demo6"><a href="#demo6" class="headerlink" title="demo6"></a>demo6</h3><p><strong>选中第一个数码管并使其8个led轮流点亮</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ORG 0000H</span><br><span class="line">MOV P1,#0xFE</span><br><span class="line">MOV P2,#00H</span><br><span class="line">MOV A,#0xFE</span><br><span class="line">NEXT:</span><br><span class="line">MOV P2,A</span><br><span class="line">MOV R3,#0</span><br><span class="line">LOOP:</span><br><span class="line">MOV R4,#0</span><br><span class="line">DJNZ R4,$</span><br><span class="line">DJNZ R3,LOOP</span><br><span class="line">RL A</span><br><span class="line">SJMP NEXT</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="demo7"><a href="#demo7" class="headerlink" title="demo7"></a>demo7</h3><p><strong>使六个数码管，每个的a、b、c、d段，共24段LED各段轮流亮。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">NUM EQU 6 ; 6个数码管</span><br><span class="line">SEG EQU 4 ; 4个发光二极管</span><br><span class="line">DELAY EQU 0 ; 延时为0</span><br><span class="line">ORG 0000H</span><br><span class="line">AJMP MAIN ; 跳转</span><br><span class="line"></span><br><span class="line">MAIN:</span><br><span class="line">MOV P1, #0xFE ;初始化和重置</span><br><span class="line">MOV P2, #00H </span><br><span class="line">MOV R0, #NUM ; 每次重置R0</span><br><span class="line"></span><br><span class="line">;大循环遍历数码管</span><br><span class="line">LOOP:</span><br><span class="line">MOV R1, #SEG ;每次大循环重置小循环R1</span><br><span class="line">MOV A,#0xFE;重置A</span><br><span class="line">;小循环遍历二极管</span><br><span class="line">SUB_LOOP:</span><br><span class="line">MOVP2 A</span><br><span class="line">LCALL DELAY_SUB ; 调用延时子程序</span><br><span class="line">RLA</span><br><span class="line">DJNZ R1, SUB_LOOP ; 循环判断</span><br><span class="line">;借助A来移动P1</span><br><span class="line">MOVAP1</span><br><span class="line">RLA </span><br><span class="line">MOVP1A; 选择下一个数码管</span><br><span class="line">DJNZ R0, LOOP ;R0自减1，如果不为0，跳转到循环开始，否则继续执行</span><br><span class="line">SJMP MAIN ; 跳转</span><br><span class="line"></span><br><span class="line">; 延时子程序</span><br><span class="line">DELAY_SUB:</span><br><span class="line">MOV R3,#0</span><br><span class="line">DELAY_LOOP:</span><br><span class="line">MOV R4,#0</span><br><span class="line">DJNZ R4,$</span><br><span class="line">DJNZ R3,DELAY_LOOP</span><br><span class="line">RET ; 返回</span><br><span class="line"></span><br><span class="line">END ; 程序结束</span><br></pre></td></tr></table></figure><h3 id="demo8"><a href="#demo8" class="headerlink" title="demo8"></a>demo8</h3><p><strong>拨动几号开关置“0N”第一个数码管显示几。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ORG 0</span><br><span class="line">MOV DPTR,#TAB0</span><br><span class="line">MOV P1,#0FEH</span><br><span class="line">STA1:</span><br><span class="line">SETB C</span><br><span class="line">MOV R0,#01</span><br><span class="line">ASP:</span><br><span class="line">MOV P0,#0FFH</span><br><span class="line">MOV A,P0</span><br><span class="line">ASP1:</span><br><span class="line">RRC A</span><br><span class="line">JNC LED ;检测是那个开关置“ON”</span><br><span class="line">INC R0</span><br><span class="line">CJNE R0,#9,ASP1</span><br><span class="line">SJMP STA1</span><br><span class="line">LED:</span><br><span class="line">MOV A,R0 ;R0 为开关号</span><br><span class="line">MOVC A,@A+DPTR</span><br><span class="line">MOV P2,A</span><br><span class="line">SJMP STA1</span><br><span class="line">TAB0:</span><br><span class="line">DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H,80H,90H,88H,83H,0C6H,0A1H,86H,8EH,0FFH</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>这里需要注意的是<strong>ASP</strong>函数，是从P0口读取八个开关的情况。</p><p><code>MOV P0,#0FFH</code>这句是将P0口的八个引脚都写为1，表示<strong>高阻输入</strong>。这样可以从P0口读取八个开关的状态，对应位为 <strong>0</strong> 就意味着<strong>ON</strong>状态。</p><p><code>MOV A,P0</code>这句是将P0口的状态值送入A寄存器，然后用<code>RRC A</code>指令来<strong>带上C位循环右移</strong>A寄存器，便可以通过检测C标志位来判断哪个开关置ON。</p><p>至于用<code>#0FF</code>赋值和用<code>#FF</code>赋值效果是一样的，不过加个零可能是从形式上做出某种区分？</p><h3 id="demo9"><a href="#demo9" class="headerlink" title="demo9"></a>demo9</h3><p><strong>数码管跑马程序</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">ORG 0</span><br><span class="line">DLED:</span><br><span class="line">MOV R0,#0H ;R0 存字形表偏移量</span><br><span class="line">WE:</span><br><span class="line">MOV A,#0FEH ;A 置数码管位选码</span><br><span class="line">NEXT:</span><br><span class="line">MOV B,A ;保存位选码</span><br><span class="line">MOV P1,A</span><br><span class="line">MOV DPTR,#TAB0 ;DPTR 置字形表头地址</span><br><span class="line">MOV A,R0</span><br><span class="line">MOVC A,@A+DPTR ;查字形码表</span><br><span class="line">MOV P2,A ;送 P2 口输出</span><br><span class="line">MOV R3,#0 ;延时</span><br><span class="line">LOP:</span><br><span class="line">MOV R4,#0</span><br><span class="line">LOP1:</span><br><span class="line">NOP</span><br><span class="line">NOP</span><br><span class="line">DJNZ R4,LOP1</span><br><span class="line">DJNZ R3,LOP</span><br><span class="line">MOV A,B</span><br><span class="line">RL A ;指向下一位</span><br><span class="line">CJNE A,#0FEH,NEXT ;8 个数码管显示完否</span><br><span class="line">INC R0 ;指向下一位字形</span><br><span class="line">CJNE R0,#10H,WE ;从 0 到 F 显示完否</span><br><span class="line">SJMP DLED</span><br><span class="line">TAB0:</span><br><span class="line">DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H,80H,90H,88H,83H,0C6H,0A1H,86H,8EH,0FFH</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="demo10"><a href="#demo10" class="headerlink" title="demo10"></a>demo10</h3><p><strong>置1键ON六个数码管轮流亮“1”，拨2键六个数码管轮流亮“2”，拨3键六个数码管轮流亮“3”。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">NUM EQU 6 ; 6个数码管</span><br><span class="line">DELAY EQU 0 ; 延时寄存器初值0</span><br><span class="line">TAB0 EQU 0020H ; 字形码表地址</span><br><span class="line"></span><br><span class="line">ORG 0000H</span><br><span class="line">MOV DPTR,#TAB0</span><br><span class="line">AJMP MAIN ; 跳转</span><br><span class="line"></span><br><span class="line">MAIN:</span><br><span class="line">MOV P1, #0FEH ; 选择第一个数码管</span><br><span class="line">MOV P2, #0FFH ; 关闭所有发光二极管</span><br><span class="line">MOV R0, #NUM </span><br><span class="line">MOV A,  #0FEH ; 11111110</span><br><span class="line">LOOP:</span><br><span class="line">;段选</span><br><span class="line">MOV B, A</span><br><span class="line">MOV P1,A</span><br><span class="line"></span><br><span class="line">MOV A, P0 ; A = P0</span><br><span class="line">ANL A, #07H ; 屏蔽高五位，只保留低三位</span><br><span class="line">CASE1:</span><br><span class="line">CJNE A, #01H, CASE2 ; 如果是置1键不等于ON，跳转到NEXT1，否则继续执行</span><br><span class="line">SJMP DISPLAY ;展示</span><br><span class="line"></span><br><span class="line">CASE2:</span><br><span class="line">CJNE A, #02H, CASE3 ; 如果是2键不等于ON，跳转到NEXT3，否则继续执行</span><br><span class="line">SJMP DISPLAY </span><br><span class="line"></span><br><span class="line">CASE3:</span><br><span class="line">CJNE A, #04H, CASE4 ; 如果是3键不等于ON，跳转到NEXT4，否则继续执行</span><br><span class="line">SJMP DISPLAY</span><br><span class="line"></span><br><span class="line">CASE4:</span><br><span class="line">MOV A, #00H; 显示0</span><br><span class="line">SJMP DISPLAY</span><br><span class="line"></span><br><span class="line">DISPLAY:</span><br><span class="line">;位选</span><br><span class="line">MOVC A,@A+DPTR</span><br><span class="line">MOV P2, A ; 将字形码送入P2口，表示显示对应的数</span><br><span class="line">LCALL DELAY_SUB ; 调用延时子程序</span><br><span class="line"></span><br><span class="line">MOV A,B</span><br><span class="line">RL A</span><br><span class="line">; R0自减1，如果不为0，跳转到循环开始，否则继续执行</span><br><span class="line">DJNZ R0, LOOP ; 完成一个小循环：单个数码管根据开关显示数字</span><br><span class="line">SJMP MAIN ; 完成大循环：六个数码管均完成小循环。跳转MAIN, reset NUM 和段选的A</span><br><span class="line"></span><br><span class="line">; 延时子程序</span><br><span class="line">DELAY_SUB:</span><br><span class="line">MOV R3,#0</span><br><span class="line">DELAY_LOOP:</span><br><span class="line">MOV R4,#0</span><br><span class="line">DJNZ R4,$</span><br><span class="line">DJNZ R3,DELAY_LOOP</span><br><span class="line">RET ; 返回</span><br><span class="line"></span><br><span class="line">TAB0:</span><br><span class="line">DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H,80H,90H,88H,83H,0C6H,0A1H,86H,8EH,0FFH</span><br><span class="line"></span><br><span class="line">END ; 程序结束</span><br></pre></td></tr></table></figure><p><code>TAB0 EQU 0020H</code>  在最开始将字形码表地址设置为了<code>0020H</code> ，但是这个地址可能会和内部RAM的地址冲突，因为内部RAM的地址范围是0000H-007FH。可以把<strong>TAB0</strong>地址改成一个较大的值，比如<code>0100H</code>，以免造成数据混乱。</p><p><code>JC:</code> 如果进位位 <strong>©为1</strong>，就跳转到指定的地址，否则顺序执行。</p><p><code>JNC:</code> 如果进位位 <strong>©为0</strong>，就跳转到指定的地址，否则顺序执行。</p><p><code>CJNE:</code> 比较两个操作数，如果<strong>不相等</strong>，就跳转到指定的地址，并根据比较结果设置进位位 ©；否则顺序执行。如果<strong>前面</strong>的数大，则©被赋 <strong>0</strong>，<strong>后面</strong>的数大就赋 <strong>1</strong></p><p><code>DJNE:</code> 如<code>DJNZ R3,DELAY_LOOP</code> 即为将<strong>R3</strong>值减一，<strong>等于零</strong>则执行下一条语句，否则跳转到<code>DELAY_LOOP</code></p><h3 id="demo11"><a href="#demo11" class="headerlink" title="demo11"></a>demo11</h3><p><strong>将开关1~8的置位情況显示在数码管上，开关置“0N”的对应数码管显“0”，开关置“0FF” (拨向下的对应数码管显“1”)。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">NUM EQU 8 ; 8个数码管</span><br><span class="line">DELAY EQU 0</span><br><span class="line"></span><br><span class="line">ORG 0000H</span><br><span class="line">AJMP MAIN ; 跳转</span><br><span class="line"></span><br><span class="line">MAIN:</span><br><span class="line">MOV P1, #0FEH ; 选择第一个数码管</span><br><span class="line">MOV P2, #0FFH ; 关闭所有发光二极管</span><br><span class="line">MOV R0, #NUM ;小循环次数：已点亮数码管数</span><br><span class="line">;获取P0口开关情况</span><br><span class="line">MOV P0,#0FFH</span><br><span class="line">MOV A, P0 </span><br><span class="line">MOV R1, A ;记录P0口开关情况</span><br><span class="line">MOV A,  #0FEH ; 11111110</span><br><span class="line"></span><br><span class="line">;展示八个数码管</span><br><span class="line">LOOP:</span><br><span class="line">;段选</span><br><span class="line">MOV B, A</span><br><span class="line">MOV P1,A</span><br><span class="line">;位选</span><br><span class="line">MOV A, R1</span><br><span class="line">RLC A ; 循环左移A寄存器，并将最高位送入C标志位 </span><br><span class="line">JC ZERO ; 如果C标志位为1，表示开关置“ON”，跳转到ZERO</span><br><span class="line">ONE: </span><br><span class="line">MOV P2, #F9H ; 如果C标志位为0，表示开关置“OFF”，显示数字“1” </span><br><span class="line">SJMP NEXT </span><br><span class="line">ZERO: </span><br><span class="line">MOV P2, #C0H ;显示数字“0” </span><br><span class="line">NEXT: </span><br><span class="line">LCALL DELAY_SUB ; 调用延时子程序 </span><br><span class="line"></span><br><span class="line">;段选</span><br><span class="line">MOV A, B</span><br><span class="line">RLA </span><br><span class="line">; R0自减1，如果不为0，跳转到循环开始，否则继续执行 </span><br><span class="line">DJNZ R0, LOOP ; 循环判断 </span><br><span class="line">; 循环结束，跳转到主程序开始处，重复执行 </span><br><span class="line">SJMP MAIN ; 跳转 </span><br><span class="line"></span><br><span class="line">; 延时子程序</span><br><span class="line">DELAY_SUB:</span><br><span class="line">MOV R3,#0</span><br><span class="line">DELAY_LOOP:</span><br><span class="line">MOV R4,#0</span><br><span class="line">DJNZ R4,$</span><br><span class="line">DJNZ R3,DELAY_LOOP</span><br><span class="line">RET ; 返回</span><br><span class="line"></span><br><span class="line">END ; 程序结束</span><br></pre></td></tr></table></figure><h3 id="外部中断接线"><a href="#外部中断接线" class="headerlink" title="外部中断接线"></a>外部中断接线</h3><blockquote><p>用跳线将轻触按键 KEY1 连接到单片机的 IO 口 P3.2，即连向 INT0，脉冲源向单片机的外部中断INT0 引脚提供中断所需的脉冲，每按一次开关 KEY1，电平变换一次，产生一个跳变源，作为外部中断INT0 的中断请求信号</p></blockquote><h3 id="demo12"><a href="#demo12" class="headerlink" title="demo12"></a>demo12</h3><p><strong>记录并显示 INT0 中断次数(中断次数&lt;16 次)</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ORG 0</span><br><span class="line">AJMP NT</span><br><span class="line">ORG 0003H</span><br><span class="line">AJMP INTOR</span><br><span class="line"></span><br><span class="line">NT:</span><br><span class="line">MOV IE,#81H ;允许 INT0 中断，置 EA=1</span><br><span class="line">SETB IT0 ;边沿触发中断</span><br><span class="line">MOV R0,#0 ;计数初值为 0</span><br><span class="line">BIOU:</span><br><span class="line">MOV P1,#0FEH ;第一个数码管显示中断次数</span><br><span class="line">MOV DPTR,#TAB0 ;字形码表送 DPTR</span><br><span class="line">MOV A,R0</span><br><span class="line">MOVC A,@A+DPTR ;查表</span><br><span class="line">MOV P2,A ;显示</span><br><span class="line">SJMP $ ;结束</span><br><span class="line">INTOR:</span><br><span class="line">INC R0 ;中断次数加 1</span><br><span class="line">CJNE R0,#010H,RET0 ;中断是否满 15 次</span><br><span class="line">MOV R0,#0 ;循环</span><br><span class="line">RET0:</span><br><span class="line">POP DPH ;弹出断点</span><br><span class="line">POP DPL</span><br><span class="line">MOV DPTR,#BIOU</span><br><span class="line">PUSH DPL ;修改中断返回点</span><br><span class="line">PUSH DPH</span><br><span class="line">RETI</span><br><span class="line">TAB0:</span><br><span class="line">DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H,80H,90H,88H,83H,0C6H,0A1H,86H,8EH,0FFH</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>这里面有一个修改中断函数返回点的操作<code>RET0</code></p><p>需要知道的是，<code>DPH</code>和<code>DPL</code>就是<code>DPTR</code>的两个八位寄存器，分别存放DPTR的<strong>高八位</strong>和<strong>低八位</strong>。这里将堆栈中保存的原来的程序计数器PC的高低字节弹出到DPH和DPL寄存器中（不过原来是多少倒是不关心）。就是把<code>BIOU</code>标号的地址送入DPTR寄存器，直接覆盖之前的地址，然后把DPTR寄存器的高低字节压入堆栈中。这样就相当于<strong>把堆栈中保存的原来的PC值改成了BIOU标号的地址。</strong></p><p>一般来说，当我们按下按键触发中断的时候程序在<code>BIOU</code> 里的<code>SJMP $</code>语句，不修改返回点的话中断完了就返回到这里。</p><h3 id="demo13"><a href="#demo13" class="headerlink" title="demo13"></a>demo13</h3><p><strong>用8XX51并行口接的三个数码管，显示INT0中断次数, 显示次数超过255后清零，重新计数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">ORG 0</span><br><span class="line">AJMP NT</span><br><span class="line">ORG 0003H</span><br><span class="line">AJMP INTOR</span><br><span class="line"></span><br><span class="line">INIT:</span><br><span class="line">MOV IE,#81H ;允许 INT0 中断，置 EA=1</span><br><span class="line">SETB IT0 ;边沿触发中断</span><br><span class="line">MOV R0,#0 ;计数初值为 0,高八位</span><br><span class="line">MOV R1,#0 ;低八位</span><br><span class="line">BIOU:</span><br><span class="line">MOV P1,#0FEH ;第一个数码管</span><br><span class="line">MOV DPTR,#TAB0 ;字形码表送 DPTR</span><br><span class="line">MOV A,R0</span><br><span class="line">MOVC A,@A+DPTR ;查表</span><br><span class="line">MOV P2,A ;显示</span><br><span class="line">LCALL DELAY_SUB ; 调用延时子程序 </span><br><span class="line"></span><br><span class="line">MOV P1，#0FDH ;第二个数码管</span><br><span class="line">MOV DPTR,#TAB0 ;字形码表送 DPTR</span><br><span class="line">MOV A,R1</span><br><span class="line">MOVC A,@A+DPTR ;查表</span><br><span class="line">MOV P2,A ;显示</span><br><span class="line">LCALL DELAY_SUB</span><br><span class="line">SJMP BIOU</span><br><span class="line"></span><br><span class="line">INTOR:</span><br><span class="line">INC R0 ;中断次数加 1</span><br><span class="line">CJNE R0,#010H,RET0 ;中断是否满 15 次</span><br><span class="line">MOV R0,#0 </span><br><span class="line">INC R1 ;进一位</span><br><span class="line">CJNE R1,#010H,RET0</span><br><span class="line">MOV R1,#0</span><br><span class="line">RET0:</span><br><span class="line">POP DPH ;弹出断点</span><br><span class="line">POP DPL</span><br><span class="line">MOV DPTR,#BIOU</span><br><span class="line">PUSH DPL ;修改中断返回点</span><br><span class="line">PUSH DPH</span><br><span class="line">RETI</span><br><span class="line"></span><br><span class="line">; 延时子程序</span><br><span class="line">DELAY_SUB:</span><br><span class="line">MOV R3,#0</span><br><span class="line">DELAY_LOOP:</span><br><span class="line">MOV R4,#0</span><br><span class="line">DJNZ R4,$</span><br><span class="line">DJNZ R3,DELAY_LOOP</span><br><span class="line">RET ; 返回</span><br><span class="line"></span><br><span class="line">TAB0:</span><br><span class="line">DB 0C0H,0F9H,0A4H,0B0H,99H,92H,82H,0F8H,80H,90H,88H,83H,0C6H,0A1H,86H,8EH,0FFH</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><h2 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h2><blockquote><p>用跳线将轻触按键 KEY1 连接到单片机的 IO 口 P3.4（即连向 T0 方向）， P3.4 和脉冲源相连，脉冲源向单片机的定时计数器 0 提供外部计数脉冲，每按一次按键 KEY1，产生一个跳变源</p></blockquote><h3 id="demo14"><a href="#demo14" class="headerlink" title="demo14"></a>demo14</h3><p><strong>査询方式计数外部脉冲,计两个脉冲， LED 显示段加 1</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ORG 0000H</span><br><span class="line">MOV TMOD,#06 ;计数器方式 2</span><br><span class="line">MOV TH0,#0FEH</span><br><span class="line">MOV TL0,#0FEH ;计两个脉冲</span><br><span class="line">SETB TR0 ;启动定时器</span><br><span class="line">MOV P1,#0F0H</span><br><span class="line">MOV A,#0FFH</span><br><span class="line">COUN:</span><br><span class="line">JNB TF0,$ ;等待计满两个脉冲</span><br><span class="line">CLR TF0 ;中断标志</span><br><span class="line">DEC A</span><br><span class="line">MOV P2,A</span><br><span class="line">SJMP COUN</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>定时器0被设置为计数器方式2，即自动重装载方式。这种方式下，当TL0溢出时，会自动从TH0中重新装入初始值，并产生一个中断请求，TF0会置一，跳出<code>JNB TF0,$</code>循环。</p><h3 id="demo15"><a href="#demo15" class="headerlink" title="demo15"></a>demo15</h3><p><strong>中断方式计数外部脉冲，计两个脉冲中断一次 LED 显示段加一。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ORG 0000H</span><br><span class="line">AJMP COUN</span><br><span class="line"></span><br><span class="line">;中断函数</span><br><span class="line">ORG 00BH</span><br><span class="line">DEC A</span><br><span class="line">MOV P2,A</span><br><span class="line">RETI</span><br><span class="line">COUN:</span><br><span class="line">MOV TMOD,#06H</span><br><span class="line">MOV TH0,#0FEH</span><br><span class="line">MOV TL0,#0FEH</span><br><span class="line">SETB EA ;总中断允许</span><br><span class="line">SETB ET0;T0中断允许</span><br><span class="line">SETB TR0</span><br><span class="line">MOV P1,#0F0H</span><br><span class="line">MOV A,#0FFH</span><br><span class="line">MOV P2,A</span><br><span class="line">SJMP $</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="demo16"><a href="#demo16" class="headerlink" title="demo16"></a>demo16</h3><p><strong>利用T0定时，使数码管的“8”字每隔100MS顺次亮下一个。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ORG 0000H</span><br><span class="line">AJMP MAIN</span><br><span class="line">MOV TMOD,#01H ;计数方式1</span><br><span class="line">MOV TH0,#04CH</span><br><span class="line">MOV TL0,#000H </span><br><span class="line"></span><br><span class="line">SETB TR0 ;启动定时器</span><br><span class="line">MOV P1,#0FEH</span><br><span class="line">MOV A,#0FEH</span><br><span class="line">MOV P2,#80H ;数字8</span><br><span class="line">LOOP:</span><br><span class="line">MOV R0 ,#2</span><br><span class="line">T0_LOOP:</span><br><span class="line">MOV TH0,#04CH</span><br><span class="line">MOV TL0,#000H ;重新装载初值</span><br><span class="line">JNB TF0,$ ;等待中断</span><br><span class="line">CLR TF0 ;中断标志</span><br><span class="line">DJNZ R0,T0_LOOP</span><br><span class="line">RL A</span><br><span class="line">MOV P1 A</span><br><span class="line">MOV P2,#80H</span><br><span class="line">SJMP LOOP</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>使用计数方式1（每次需要手动重新赋初值），计数器位数为 <strong>16</strong>，晶振频率为 <strong>11.0592MHz</strong>，那么一个机器周期为<strong>1.08507us</strong>, 即使初值全设为0也只有<strong>71.11ms</strong>的时长，无法实现<strong>100ms</strong>的定时。所以需要再加一个<strong>R0</strong>实现循环定时。这里让他计数 <strong>46080</strong> 次，即<strong>50ms</strong>，那么<strong>R0=2</strong>。设初值为65536-46080=<strong>19456</strong>，即<code>MOV TH0,#04CH</code> , <code>MOV TL0,#000H</code> 。</p><h3 id="demo17"><a href="#demo17" class="headerlink" title="demo17"></a>demo17</h3><p><strong>利用8XX51做一个秒表，基础计时百分之一秒，满100，记1秒，key1键可实现秒表开始计时，暂停，及继续，key2键可实现秒表任意时刻计数值清零。秒表满量程99秒，溢出后自动清零，重新开始。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">;定义数码管显示的字形码表</span><br><span class="line">LED_CODE: DB 3FH, 06H, 5BH, 4FH, 66H, 6DH, 7DH, 07H</span><br><span class="line">         DB 7FH, 6FH, 77H, 7CH, 39H, 5EH, 79H, 71H</span><br><span class="line">;定义数码管显示的位选码表</span><br><span class="line">LED_POS: DB 0FEH, 0FDH, 0FBH, 0F7H</span><br><span class="line">;定义按键扫描的位掩码表</span><br><span class="line">KEY_MASK: DB 0EFH, 0DFH</span><br><span class="line"></span><br><span class="line">ORG 0000H ;设置程序起始地址为0000H</span><br><span class="line">MOV TMOD,#01H ;设置定时器T0为工作方式1，16位定时器</span><br><span class="line">MOV TH0,#0FFH ;给定时器T0装初值，定时10ms</span><br><span class="line">MOV TL0,#0D9H</span><br><span class="line">SETB EA ;开总中断</span><br><span class="line">SETB ET0 ;开T0中断</span><br><span class="line"></span><br><span class="line">MAIN: MOV DPTR,#LED_CODE ;设置DPTR指向字形码表</span><br><span class="line">      MOV R2,#00H ;设置R2为数码管显示的百分之一秒位的索引，初始为00H</span><br><span class="line">      MOV R3,#00H ;设置R3为数码管显示的秒位的索引，初始为00H</span><br><span class="line">      MOV R4,#00H ;设置R4为数码管显示的十秒位的索引，初始为00H</span><br><span class="line">      MOV R5,#01H ;设置R5为按键扫描的状态标志，初始为01H（开始计时）</span><br><span class="line">      MOV R6,#00H ;设置R6为按键扫描的延时计数器，初始为00H</span><br><span class="line"></span><br><span class="line">LOOP: CALL SCAN_KEY ;调用按键扫描子程序</span><br><span class="line">      CALL SHOW_LED ;调用数码管显示子程序</span><br><span class="line">      SJMP LOOP ;无限循环</span><br><span class="line"></span><br><span class="line">SCAN_KEY: PUSH ACC ;保存累加器内容</span><br><span class="line">          PUSH PSW ;保存程序状态字内容</span><br><span class="line">          MOV DPTR,#KEY_MASK ;设置DPTR指向位掩码表</span><br><span class="line">          MOV A,R5 ;将按键状态标志送入累加器A</span><br><span class="line">          ANL A,#01H ;与01H进行逻辑与运算，取出最低位（开始/暂停标志）</span><br><span class="line">          JZ SCAN_KEY1 ;如果最低位为0，则跳转到SCAN_KEY1（暂停状态）</span><br><span class="line">          CLR P3.2 ;如果最低位为1，则清除P3.2（开始状态）</span><br><span class="line">          SETB P3.3 ;置位P3.3（开始状态）</span><br><span class="line">          ACALL DELAY_KEY ;调用按键延时子程序</span><br><span class="line">          JB P1.4,NEXT1 ;如果P1.4为高电平，则跳转到NEXT1（未按下key1）</span><br><span class="line">          CPL R5.0 ;如果P1.4为低电平，则反转R5.0（按下key1）</span><br><span class="line">NEXT1:    JB P1.5,NEXT2 ;如果P1.5为高电平，则跳转到NEXT2（未按下key2）</span><br><span class="line">          MOV R2,#00H ;如果P1.5为低电平，则清零R2（按下key2）</span><br><span class="line">          MOV R3,#00H ;清零R3（按下key2）</span><br><span class="line">          MOV R4,#00H ;清零R4（按下key2）</span><br><span class="line">NEXT2:    POP PSW ;恢复程序状态字内容</span><br><span class="line">          POP ACC ;恢复累加器内容</span><br><span class="line">          RET ;返回主程序</span><br><span class="line"></span><br><span class="line">SCAN_KEY1: SETB P3.2 ;如果最低位为0，则置位P3.2（暂停状态）</span><br><span class="line">           CLR P3.3 ;清除P3.3（暂停状态）</span><br><span class="line">           ACALL DELAY_KEY ;调用按键延时子程序</span><br><span class="line">           JB P1.4,NEXT3 ;如果P1.4为高电平，则跳转到NEXT3（未按下key1）</span><br><span class="line">           CPL R5.0 ;如果P1.4为低电平，则反转R5.0（按下key1）</span><br><span class="line">NEXT3:     JB P1.5,NEXT4 ;如果P1.5为高电平，则跳转到NEXT4（未按下key2）</span><br><span class="line">           MOV R2,#00H ;如果P1.5为低电平，则清零R2（按下key2）</span><br><span class="line">           MOV R3,#00H ;清零R3（按下key2）</span><br><span class="line">           MOV R4,#00H ;清零R4（按下key2）</span><br><span class="line">NEXT4:     POP PSW ;恢复程序状态字内容</span><br><span class="line">           POP ACC ;恢复累加器内容</span><br><span class="line">           RET ;返回主程序</span><br><span class="line"></span><br><span class="line">DELAY_KEY: PUSH ACC ;保存累加器内容</span><br><span class="line">           PUSH PSW ;保存程序状态字内容</span><br><span class="line">           INC R6 ;将R6自增一</span><br><span class="line">           CJNE R6,#20,NEXT5; 如果R6不等于20，则跳转到NEXT5（未达到延时要求）</span><br><span class="line">           CLR R6; 如果R6等于20，则清零R6（达到延时要求）</span><br><span class="line">NEXT5:     POP PSW; 恢复程序状态字内容</span><br><span class="line">           POP ACC; 恢复累加器内容</span><br><span class="line">           RET; 返回主程序</span><br><span class="line"></span><br><span class="line">SHOW_LED: PUSH ACC; 保存累加器内容</span><br><span class="line">          PUSH PSW; 保存程序状态字内容</span><br><span class="line"></span><br><span class="line">          MOV A,R2; 将百分之一秒位的索引送入累加器A</span><br><span class="line">          MOVC A,@A+DPTR; 根据索引从字形码表中取出对应的字形码，并送入累加器A</span><br><span class="line">          MOV P0,A; 将字形码送入P0口输出</span><br><span class="line"></span><br><span class="line">          MOV A,R6; 将延时计数器的值送入累加器A</span><br><span class="line">          ANL A,#03H; 与03H进行逻辑与运算，取出最低两位作为位选索引，并送入累加器A</span><br><span class="line">          MOVC A,@A+DPTR; 根据索引从位选码表中取出对应的位选码，并送入累加器A          </span><br><span class="line">          MOV P2,A; 将位选码送入P2口输出</span><br><span class="line"></span><br><span class="line">          POP PSW; 恢复程序状态字内容          </span><br><span class="line">          POP ACC; 恢复累加器内容          </span><br><span class="line">          RET; 返回主程序</span><br><span class="line"></span><br><span class="line">T0_ISR: PUSH ACC; 保存累加器内容          </span><br><span class="line">        PUSH PSW; 保存程序状态字内容          </span><br><span class="line">        MOV TH0,#0FFH; 给定时器T0重新装初值，保证每次进入中断函数都是10ms          </span><br><span class="line">        MOV TL0,#0D9H          </span><br><span class="line">        INC R2; 将百分之一秒位的索引自增一          </span><br><span class="line">        CJNE R2,#64,NEXT6; 如果百分之一秒位的索引不等于64，则跳转到NEXT6（未满100）          </span><br><span class="line">        CLR R2; 如果百分之一秒位的索引等于64，则清零R2（满100）          </span><br><span class="line">        INC R3; 将秒位的索引自增一          </span><br><span class="line">        CJNE R3,#10,NEXT7; 如果秒位的索引不等于10，则跳转到NEXT7（未满10）          </span><br><span class="line">        CLR R3; 如果秒位的索引等于10，则清零R3（满10）          </span><br><span class="line">        INC R4; 将十秒位的索引自增一          </span><br><span class="line">        CJNE R4,#10,NEXT8; 如果十秒位的索引不等于10，则跳转到NEXT8（未满10）          </span><br><span class="line">        CLR R4; 如果十秒位的索引等于10，则清零R4（满10）          </span><br><span class="line">NEXT8:   NOP          </span><br><span class="line">NEXT7:   NOP</span><br></pre></td></tr></table></figure><p>因为next7和next8是跳转标签，用来实现条件分支。如果不加nop指令，那么跳转到这两个标签后，程序会继续执行下面的指令，可能会造成逻辑错误。nop指令是空操作指令，不会影响任何寄存器或标志位，只是占用一个机器周期。加上nop指令可以保证跳转到这两个标签后，程序会直接跳出中断服务子程序，而不会执行其他多余的指令。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C51 </tag>
            
            <tag> Assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,Pegasus!</title>
      <link href="/2023/05/18/Hello-Pegasus/"/>
      <url>/2023/05/18/Hello-Pegasus/</url>
      
        <content type="html"><![CDATA[<h1 id="Taurus-amp-Pegasus"><a href="#Taurus-amp-Pegasus" class="headerlink" title="Taurus &amp; Pegasus"></a>Taurus &amp; Pegasus</h1><p><a href="https://www.bilibili.com/video/av425214737/?vd_source=0f383e93e945bca07eaef9a9ee5d9db3">Taurus &amp; Pegasus AI计算机视觉基础开发套件组装指导视频</a></p><p><a href="https://developer.hisilicon.com/forum/all">海思社区 (hisilicon.com)</a></p><p><a href="https://developer.hisilicon.com/postDetail?tid=0206112326723530001">官方教程</a></p><p><a href="https://gitee.com/HiSpark/HiSpark_NICU2023/blob/master/Taurus%20&amp;%20Pegasus%20AI%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99.pdf">官网老是进不去，这是gitee上的pdf</a></p><p><a href="https://developer.hisilicon.com/postDetail?tid=0238117167085302003">训练服务器获取文档</a></p><p><a href="https://developer.huawei.com/consumer/cn/training/course/mooc/C101641968823265204?refresh=1669428623989">华为开发者学堂-HarmonyOS物联网开发课程 (huawei.com)</a></p><p><a href="https://gitee.com/hihope_iot/embedded-race-hisilicon-track-2022/blob/master/%E7%A1%AC%E4%BB%B6%E8%B5%84%E6%96%99/HiSpark_WiFi_IoT%E6%99%BA%E8%83%BD%E5%AE%B6%E5%B1%85%E5%BC%80%E5%8F%91%E5%A5%97%E4%BB%B6_%E5%8E%9F%E7%90%86%E5%9B%BE.rar">硬件资料/HiSpark_WiFi_IoT智能家居开发套件_原理图.rar</a></p><p><a href="https://gitee.com/hihope_iot/embedded-race-hisilicon-track-2022/raw/master/%E8%8A%AF%E7%89%87%E8%B5%84%E6%96%99/Hi3861V100%EF%BC%8FHi3861LV100%20AT%E5%91%BD%E4%BB%A4%20%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97.pdf">Hi3861LV100 AT命令 使用指南.pdf</a></p><h1 id="lt-零-gt-Pegasus环境配置与文件架构"><a href="#lt-零-gt-Pegasus环境配置与文件架构" class="headerlink" title="&lt;零&gt; Pegasus环境配置与文件架构"></a>&lt;零&gt; Pegasus环境配置与文件架构</h1><p>跟着官方教程走，到了<strong>build</strong>步骤的时候出现报错</p><p><img src="https://s2.loli.net/2023/05/18/4JW8kgfoKsdvtUA.png" alt="零2.png"></p><p>或者是这样的</p><p><img src="https://s2.loli.net/2023/05/18/wQvckH82I5GWqYX.png" alt="零0.png"></p><p>这个问题教程里也有讲过：<strong>尽量将工程文件夹放在根目录下；</strong>实际上应该是：<strong>一定要将工程文件夹放在根目录下</strong></p><p>之后就可以成功编译了</p><p><img src="https://s2.loli.net/2023/05/18/Sy6Unm2oTzQNrt5.png" alt="零1.png"></p><h2 id="Build-gn文件"><a href="#Build-gn文件" class="headerlink" title="Build.gn文件"></a>Build.gn文件</h2><p>BUILD.gn是一种用于描述软件构建信息的文件，它是GN（Generate Ninja）构建系统的一部分12。它的作用是：</p><ul><li>定义要编译的源文件、头文件路径、编译方式等。</li><li>声明目标的依赖关系，如静态库、共享库、可执行文件等。</li><li>将设置放在config中，如编译器标志、预处理器定义、包含目录等。</li><li>生成Ninja构建文件，用于实际编译和链接代码。</li></ul><p>BUILD.gn文件通常位于每个源码目录下，以及根目录下。官方demo的 <strong>app</strong> 文件夹下是要烧录到板子之中的代码，通过该目录下的 <strong>BUILD.gn</strong> 文件选择具体使用的 <strong>库</strong> 以及 <strong>源代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入一个名为lite_component的模板，用于定义OpenHarmony应用组件</span></span><br><span class="line"><span class="keyword">import</span>(<span class="string">&quot;//build/lite/config/component/lite_component.gni&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用lite_component模板定义一个名为app的应用组件</span></span><br><span class="line">lite_component(<span class="string">&quot;app&quot;</span>) &#123;</span><br><span class="line">  <span class="comment"># 指定要依赖的其他目标列表，这里依赖了netDemo静态库目标</span></span><br><span class="line"><span class="comment"># [子文件夹名:子文件夹下声明的静态库]</span></span><br><span class="line">  features = [ <span class="string">&quot;lwip_demo:netDemo&quot;</span>, ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <strong>app</strong> 文件夹下有存放着各种源码的子文件夹，上面这个例子就应该有着类似 <strong>lwip_demo</strong> 的子文件夹，在这里面存放着<strong>源码</strong>与自己的 <strong>BUILD.gn</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个静态库目标，名为netDemo</span></span><br><span class="line">static_library(<span class="string">&quot;netDemo&quot;</span>) &#123;</span><br><span class="line">  <span class="comment"># 指定要编译的源文件列表</span></span><br><span class="line">  sources = [ <span class="string">&quot;lwip_tcp_server.c&quot;</span> ]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 追加更多的源文件到列表中</span></span><br><span class="line">  sources += [</span><br><span class="line">    <span class="string">&quot;demo_entry_cmsis.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;wifi_connecter.c&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 指定要包含的头文件目录列表</span></span><br><span class="line">  include_dirs = [</span><br><span class="line">    <span class="string">&quot;//utils/native/lite/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//kernel/liteos_m/components/cmsis/2.0&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//base/iot_hardware/interfaces/kits/wifiiot_lite&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//base/iot_hardware/peripheral/interfaces/kits&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//foundation/communication/wifi_lite/interfaces/wifiservice&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>sources</code>和<code>sources+</code>添加的源文件没有本质的区别，都是指定要编译的源文件列表。只是为了方便阅读和维护，可以使用+号来追加文件，而不是一次性写出所有的文件。这样可以按照功能或模块来分组文件，也可以避免一行过长的问题，；例如</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 指定要编译的源文件列表</span></span><br><span class="line">sources = [ <span class="string">&quot;lwip_tcp_server.c&quot;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加来自demo_entry_cmsis目录的源文件</span></span><br><span class="line">sources += [ <span class="string">&quot;demo_entry_cmsis/*.c&quot;</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加来自wifi_connecter目录的源文件</span></span><br><span class="line">sources += [ <span class="string">&quot;wifi_connecter/*.c&quot;</span> ]</span><br></pre></td></tr></table></figure><h1 id="lt-一-gt-hello-world"><a href="#lt-一-gt-hello-world" class="headerlink" title="&lt;一&gt; hello world"></a>&lt;一&gt; hello world</h1><h2 id="修改BUILD-gn来选择需要编译的工程文件"><a href="#修改BUILD-gn来选择需要编译的工程文件" class="headerlink" title="修改BUILD.gn来选择需要编译的工程文件"></a>修改<strong>BUILD.gn</strong>来选择需要编译的工程文件</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">import(&quot;//build/lite/config/component/lite_component.gni&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="string">lite_component(&quot;app&quot;)</span> &#123;</span><br><span class="line">    <span class="string">features</span> <span class="string">=</span> [</span><br><span class="line">        <span class="string">&quot;hello_world_demo:helloWorld&quot;</span>,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>hello_world_demo</strong>：指的是需要编译的工程目录对应的文件夹名</p><p><strong>helloWorld</strong>：指的是需要编译的代码中的BUILD.gn的静态库，名称为helloWorld；比如这里就是 <code>./hello_world_demo/BUILD.gn</code> 中声明的库名</p><h2 id="修改usr-config-mk文件来配置外设驱动"><a href="#修改usr-config-mk文件来配置外设驱动" class="headerlink" title="修改usr_config.mk文件来配置外设驱动"></a>修改usr_config.mk文件来配置外设驱动</h2><p><code>src/device/hisilicon/hispark_pegasus/sdk_liteos/build/config/usr_config.mk</code></p><h1 id="lt-二-gt-Operating-System"><a href="#lt-二-gt-Operating-System" class="headerlink" title="&lt;二&gt; Operating System"></a>&lt;二&gt; Operating System</h1><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>源码见仓库 <em>Hello_Pegasus</em> 中的 <em>Thread_demo/thread.c</em></p><p>入口函数为 <strong>ThreadTestTask</strong> 创建了 <strong>rtosv2_thread_main</strong> 线程。在 <strong>rtosv2_thread_main</strong> 中创建了 <strong>threadTest</strong> 线程，<strong>threadTest</strong> 在<code>while</code>中不断打印； <strong>rtosv2_thread_main</strong> 没有<code>while</code>循环，从头到尾走一遍，调了几个API示例就没了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Creates an active thread.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* The priority ranges from 9 to 38. Select a proper priority as required.</span></span><br><span class="line"><span class="comment">* The maximum of tasks is LOSCFG_BASE_CORE_TSK_LIMIT(LOSCFG_BASE_CORE_TSK_LIMIT is defined in the traget_config.h).</span></span><br><span class="line"><span class="comment">* @param func Indicates the entry of the thread callback function.线程函数</span></span><br><span class="line"><span class="comment">* @param argument Indicates the pointer to the argument passed to the thread.开始参数</span></span><br><span class="line"><span class="comment">* @param attr Indicates the thread attributes.线程属性</span></span><br><span class="line"><span class="comment">* @return Returns the thread ID; returns NULL in the case of an error.</span></span><br><span class="line"><span class="comment">* @since 1.0</span></span><br><span class="line"><span class="comment">* @version 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">osThreadId_t <span class="title function_">osThreadNew</span> <span class="params">(osThreadFunc_t func, <span class="type">void</span> *argument, <span class="type">const</span> osThreadAttr_t *attr)</span>;</span><br></pre></td></tr></table></figure><p>常用API</p><div class="table-container"><table><thead><tr><th>接口名称</th><th>函数说明</th></tr></thead><tbody><tr><td>osThreadGetName</td><td>获取指定线程的名字</td></tr><tr><td>osThreadGetId</td><td>获取当前运行线程的线程ID</td></tr><tr><td>osThreadGetState</td><td>获取当前线程的状态</td></tr><tr><td>osThreadSetPriority</td><td>设置指定线程的优先级</td></tr><tr><td>osThreadGetPriority</td><td>获取当前线程的优先级</td></tr><tr><td>osThreadYield</td><td>将运行控制转交给下一个处于READY状态的线程</td></tr><tr><td>osThreadSuspend</td><td>挂起指定线程的运行</td></tr><tr><td>osThreadResume</td><td>恢复指定线程的运行</td></tr><tr><td>osThreadDetach</td><td>分离指定的线程（当线程终止运行时，线程存储可以被回收）</td></tr><tr><td>osThreadJoin</td><td>等待指定线程终止运行</td></tr><tr><td>osThreadExit</td><td>终止当前线程的运行</td></tr><tr><td>osThreadTerminate</td><td>终止指定线程的运行</td></tr><tr><td>osThreadGetStackSize</td><td>获取指定线程的栈空间大小</td></tr><tr><td>osThreadGetStackSpace</td><td>获取指定线程的未使用的栈空间大小</td></tr><tr><td>osThreadGetCount</td><td>获取活跃线程数</td></tr><tr><td>osThreadEnumerate</td><td>获取线程组中的活跃线程数</td></tr></tbody></table></div><h2 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h2><p>创建函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Creates and initializes a timer.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* This function creates a timer associated with the arguments callback function. The timer stays in the stopped state until OSTimerStart is used to start the timer.</span></span><br><span class="line"><span class="comment">* The timer precision is 1000 / LOSCFG_BASE_CORE_TICK_PER_SECOND ms(LOSCFG_BASE_CORE_TICK_PER_SECOND is defined in the traget_config.h).</span></span><br><span class="line"><span class="comment">* @param func Indicates the entry of the timer callback function.</span></span><br><span class="line"><span class="comment">* @param type Indicates the timer type.</span></span><br><span class="line"><span class="comment">* @param argument Indicates the pointer to the argument used in timer callback.</span></span><br><span class="line"><span class="comment">* @param attr Indicates the pointer to the timer attributes. This parameter is not used.</span></span><br><span class="line"><span class="comment">* @return Returns the timer ID; returns NULL in the case of an error.</span></span><br><span class="line"><span class="comment">* @since 1.0</span></span><br><span class="line"><span class="comment">* @version 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">osTimerId_t <span class="title function_">osTimerNew</span> <span class="params">(osTimerFunc_t func, osTimerType_t type, <span class="type">void</span> *argument, <span class="type">const</span> osTimerAttr_t *attr)</span>;</span><br></pre></td></tr></table></figure><p>常用API</p><div class="table-container"><table><thead><tr><th>API名称</th><th>说明</th></tr></thead><tbody><tr><td>osTimerNew</td><td>创建和初始化定时器</td></tr><tr><td>osTimerGetName</td><td>获取指定的定时器名字</td></tr><tr><td>osTimerStart</td><td>启动或者重启指定的定时器</td></tr><tr><td>osTimerStop</td><td>停止指定的定时器</td></tr><tr><td>osTimerIsRunning</td><td>检查一个定时器是否在运行</td></tr><tr><td>osTimerDelete</td><td>删除定时器</td></tr></tbody></table></div><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><strong>互斥锁</strong></h2><p><a href="https://www.zhihu.com/question/379849079">什么是临界资源，临界区？ - 知乎 (zhihu.com)</a></p><p>互斥锁（Mutex）是一种用来保证多个线程或进程之间对共享资源的互斥访问的同步机制。只有一个线程或进程可以获得互斥锁，这意味着互斥锁有所有权的概念，只有拥有互斥锁的线程或进程才能释放它1。<br>互斥锁可以用来实现临界区（Critical Section），即一段只能被一个线程或进程执行的代码。一个线程或进程在进入临界区之前，必须先请求获得互斥锁，如果互斥锁已经被占用，那么该线程或进程就会阻塞等待，直到互斥锁被释放。一个线程或进程在离开临界区之后，必须释放互斥锁，以便其他线程或进程可以进入临界区2。<br>互斥锁有两种类型：本地互斥锁和命名系统互斥锁。如果你使用一个接受名字的构造函数来创建一个互斥锁对象，它就会与操作系统中同名的对象关联。命名系统互斥锁在操作系统中是可见的，可以用来同步不同进程的活动。你可以创建多个代表同一个命名系统互斥锁的对象，也可以使用OpenExisting方法来打开一个已存在的命名系统互斥锁。本地互斥锁只存在于你的进程中。它可以被你的进程中任何拥有该本地互斥锁对象引用的线程使用。每个互斥锁对象都是一个单独的本地互斥锁3。</p><blockquote><p>哲学家就餐问题1：这是一个经典的并发编程问题，有五个哲学家围坐在一张圆桌旁，每两个哲学家之间有一只叉子，每个哲学家要么思考要么吃饭，吃饭时需要同时拿起左右两只叉子。如果使用互斥锁来保护每只叉子，那么可能出现死锁的情况，即每个哲学家都拿起了左边的叉子，然后等待右边的叉子，导致无法进餐。一种解决方案是让每个哲学家按照编号顺序拿起叉子，即先拿编号较小的叉子，再拿编号较大的叉子，这样可以避免环路等待的条件。<br>丈夫与妻子模型：这是一个简单的信号量问题，有一个丈夫和一个妻子共享一个洗手间，洗手间只能容纳一个人。如果使用互斥锁来保护洗手间，那么可以实现互斥访问，即只有一个人可以进入洗手间，另一个人必须等待。当一个人用完洗手间后，必须释放互斥锁，以便另一个人可以进入。</p></blockquote><p>死锁是指两个或多个进程互相等待对方占用的资源而无法继续执行的状态。死锁的产生必须满足四个条件：互斥、请求和保持、不剥夺、环路等待。要避免死锁，可以破坏这四个条件中的任何一个。一个通俗的例子是：有两把钥匙和两扇门，每把钥匙只能打开一扇门。如果两个人分别拿了一把钥匙，但是都想打开另一扇门，就会形成死锁1。<br>饥饿是指一个进程因为无法获得所需的资源而长时间等待的现象。饥饿可能是由于资源分配不公平、优先级调度不合理、进程阻塞等原因导致的。一个通俗的例子是：有一个餐厅只有一个服务员，他总是优先服务点菜最多的客人，而忽略了点菜少的客人。这样就会导致点菜少的客人饿肚子。<br>忙等是指一个进程在等待某个条件成立时，不断地检查该条件是否成立，而不释放处理器或让出CPU给其他进程的行为。忙等会浪费CPU资源和时间片，降低系统效率。一个通俗的例子是：有一个人在等待电梯到达自己的楼层时，不断地按电梯按钮，而不去做其他事情。<br>信号量是一种用于实现进程间同步和互斥的机制。信号量是一个整数变量，可以通过P操作（减一）和V操作（加一）来修改。当信号量为零时，P操作会阻塞等待，直到信号量变为正数。当信号量为正数时，V操作会唤醒等待的进程。通过初始化信号量为1或0，可以实现互斥锁或条件变量的功能。一个通俗的例子是：有一个公共厕所只有一个坑位，有多个人想要上厕所。可以设置一个信号量为1，表示坑位是否空闲。每个人在上厕所前要执行P操作，如果坑位空闲就占用坑位并将信号量减为0；如果坑位占用就等待信号量变为1。每个人在上完厕所后要执行V操作，释放坑位并将信号量加为123。</p><p>创建函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**<span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Creates and initializes a mutex.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param attr Indicates the pointer to the mutex attributes. This parameter is not used.</span></span><br><span class="line"><span class="comment">* @return Returns the mutex ID; returns NULL in the case of an error.</span></span><br><span class="line"><span class="comment">* @since 1.0</span></span><br><span class="line"><span class="comment">* @version 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">osMutexId_t <span class="title function_">osMutexNew</span> <span class="params">(<span class="type">const</span> osMutexAttr_t *attr)</span>;**</span><br></pre></td></tr></table></figure><p>常用API</p><div class="table-container"><table><thead><tr><th>osMutexGetName</th><th>获得指定互斥锁的名字</th></tr></thead><tbody><tr><td>osMutexAcquire</td><td>获得指定的互斥锁的访问权限，若互斥锁已经被锁，则返回超时</td></tr><tr><td>osMutexRelease</td><td>释放指定的互斥锁</td></tr><tr><td>osMutexGetOwner</td><td>获得指定互斥锁的所有者线程</td></tr><tr><td>osMutexDelete</td><td>删除指定的互斥锁</td></tr></tbody></table></div><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>关于信号量的基本知识这篇文章写得很清楚</p><p><a href="https://blog.csdn.net/weixin_43914272/article/details/108317212">(42条消息) 操作系统——信号量（理解什么是信号量，信号量如何解决同步互斥问题，信号量一些注意点）_五斤w的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_43914272/category_10332365.html">(42条消息) 操作系统_五斤w的博客-CSDN博客</a></p><p>创建函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Creates and initializes a semaphore object.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param max_count 最大令牌数，Indicates the maximum number of available tokens that can be applied for.</span></span><br><span class="line"><span class="comment">* @param initial_count 初始令牌数，Indicates the initial number of available tokens.</span></span><br><span class="line"><span class="comment">* @param attr Indicates the pointer to the semaphore attributes. This parameter is not used.</span></span><br><span class="line"><span class="comment">* @return Returns the semaphore ID; returns NULL in the case of an error.</span></span><br><span class="line"><span class="comment">* @since 1.0</span></span><br><span class="line"><span class="comment">* @version 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">osSemaphoreId_t <span class="title function_">osSemaphoreNew</span> <span class="params">(<span class="type">uint32_t</span> max_count, <span class="type">uint32_t</span> initial_count, <span class="type">const</span> osSemaphoreAttr_t *attr)</span>;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>API名称</th><th>说明</th></tr></thead><tbody><tr><td>osSemaphoreNew</td><td>创建并初始化一个信号量</td></tr><tr><td>osSemaphoreGetName</td><td>获取一个信号量的名字</td></tr><tr><td>osSemaphoreAcquire</td><td>获取一个信号量的令牌，若获取不到，则会超时返回</td></tr><tr><td>osSemaphoreRelease</td><td>释放一个信号量的令牌，但是令牌的数量不超过初始定义的的令牌数</td></tr><tr><td>osSemaphoreGetCount</td><td>获取当前的信号量令牌数</td></tr><tr><td>osSemaphoreDelete</td><td>删除一个信号量</td></tr></tbody></table></div><p><strong>例程</strong></p><p>典型的生产者-消费者问题，其中有一个共享的缓冲区，生产者线程向缓冲区中放入产品，消费者线程从缓冲区中取出产品。为了避免缓冲区溢出或者空闲，需要用两个信号量来控制缓冲区的状态。</p><p>empty信号量表示缓冲区中空闲的位置的数量，它的初始值是BUFFER_SIZE，表示一开始缓冲区是空的。当生产者线程想要向缓冲区中放入一个产品时，它需要先获取一个empty信号量的令牌，如果empty信号量有剩余的令牌，说明缓冲区还有空闲的位置，那么生产者线程就可以获取一个令牌并继续执行，如果empty信号量没有剩余的令牌，说明缓冲区已经满了，那么生产者线程就需要等待直到有消费者线程释放令牌或者超时返回。当生产者线程向缓冲区中放入一个产品后，它需要释放一个filled信号量的令牌，表示缓冲区中有一个产品可以被消费。</p><p>filled信号量表示缓冲区中已经放入的产品的数量，它的初始值是0，表示一开始缓冲区是没有产品的。当消费者线程想要从缓冲区中取出一个产品时，它需要先获取一个filled信号量的令牌，如果filled信号量有剩余的令牌，说明缓冲区还有产品可以被消费，那么消费者线程就可以获取一个令牌并继续执行，如果filled信号量没有剩余的令牌，说明缓冲区已经空了，那么消费者线程就需要等待直到有生产者线程释放令牌或者超时返回。当消费者线程从缓冲区中取出一个产品后，它需要释放一个empty信号量的令牌，表示缓冲区中有一个空闲的位置可以被填充。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">producer_thread</span><span class="params">(<span class="type">int</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">int</span>)arg;</span><br><span class="line">    empty_id = osSemaphoreNew(BUFFER_SIZE, BUFFER_SIZE, <span class="literal">NULL</span>);</span><br><span class="line">    filled_id = osSemaphoreNew(BUFFER_SIZE, <span class="number">0U</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        osSemaphoreAcquire(empty_id, osWaitForever);</span><br><span class="line">        product_number++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Semp Test]%s produces a product, now product number: %d.\r\n&quot;</span>,</span><br><span class="line">            osThreadGetName(osThreadGetId()), product_number);</span><br><span class="line">        osDelay(OS_DELAY);</span><br><span class="line">        osSemaphoreRelease(filled_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer_thread</span><span class="params">(<span class="type">int</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">while</span> (NUM) &#123;</span><br><span class="line">        osSemaphoreAcquire(filled_id, osWaitForever);</span><br><span class="line">        product_number--;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[Semp Test]%s consumes a product, now product number: %d.\r\n&quot;</span>,</span><br><span class="line">            osThreadGetName(osThreadGetId()), product_number);</span><br><span class="line">        osDelay(OS_DELAY_S);</span><br><span class="line">        osSemaphoreRelease(empty_id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结起来就是生产者<code>productor</code>根据<strong>空闲位置<code>empty_id</code></strong>获取继续生产的资格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osSemaphoreAcquire(empty_id, osWaitForever);</span><br></pre></td></tr></table></figure><p>只能使<strong>空闲位置</strong><code>empty_id</code><strong>减少</strong>，使<strong>产品数量</strong><code>filled_id</code>增加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osSemaphoreRelease(filled_id);</span><br></pre></td></tr></table></figure><p>消费者<code>consumer</code>根据<strong>产品数量</strong><code>filled_id</code>获取消费资格</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osSemaphoreAcquire(filled_id, osWaitForever);</span><br></pre></td></tr></table></figure><p>只能使<strong>产品数量</strong><code>filled_id</code><strong>减少</strong>，使<strong>空闲位置</strong><code>empty_id</code>增加</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">osSemaphoreRelease(empty_id);</span><br></pre></td></tr></table></figure><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><div class="table-container"><table><thead><tr><th>API名称</th><th>说明</th></tr></thead><tbody><tr><td>osMessageQueueNew</td><td>创建和初始化一个消息队列</td></tr><tr><td>osMessageQueueGetName</td><td>返回指定的消息队列的名字</td></tr><tr><td>osMessageQueuePut</td><td>向指定的消息队列存放1条消息，如果消息队列满了，那么返回超时</td></tr><tr><td>osMessageQueueGet</td><td>从指定的消息队列中取得1条消息，如果消息队列为空，那么返回超时</td></tr><tr><td>osMessageQueueGetCapacity</td><td>获得指定的消息队列的消息容量</td></tr><tr><td>osMessageQueueGetMsgSize</td><td>获得指定的消息队列中可以存放的最大消息的大小</td></tr><tr><td>osMessageQueueGetCount</td><td>获得指定的消息队列中当前的消息数</td></tr><tr><td>osMessageQueueGetSpace</td><td>获得指定的消息队列中还可以存放的消息数</td></tr><tr><td>osMessageQueueReset</td><td>将指定的消息队列重置为初始状态</td></tr><tr><td>osMessageQueueDelete</td><td>删除指定的消息队列</td></tr></tbody></table></div><p>创建函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Creates and initializes a message queue.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param msg_count 队列长度：Indicates the number of messages in the message queue.</span></span><br><span class="line"><span class="comment">* @param msg_size 队列消息大小：Indicates the size of messages in the message queue.</span></span><br><span class="line"><span class="comment">* @param attr Indicates the pointer to the message queue attributes. This parameter is not used.</span></span><br><span class="line"><span class="comment">* @return Returns the message queue ID; returns NULL in the case of an error.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">osMessageQueueId_t <span class="title function_">osMessageQueueNew</span> <span class="params">(<span class="type">uint32_t</span> msg_count, <span class="type">uint32_t</span> msg_size, <span class="type">const</span> osMessageQueueAttr_t *attr)</span>;</span><br></pre></td></tr></table></figure><p>发送消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Places a message in a message queue.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param mq_id 消息队列ID：Indicates the message queue ID, which is obtained using osMessageQueueNew.</span></span><br><span class="line"><span class="comment">* @param msg_ptr 消息指针：Indicates the pointer to the buffer for storing the message to be placed in the message queue.</span></span><br><span class="line"><span class="comment">* @param msg_prio 消息优先级（此参数没用）Indicates the priority of the message to be placed in the message queue. This parameter is not used.</span></span><br><span class="line"><span class="comment">* @param timeout Indicates the timeout duration.</span></span><br><span class="line"><span class="comment"> 表示超时时间，如果消息队列已满，函数会等待一段时间，直到有空间可以放入消息或者超时返回。</span></span><br><span class="line"><span class="comment">* @return Returns the CMSIS-RTOS running result.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">osStatus_t <span class="title function_">osMessageQueuePut</span> <span class="params">(osMessageQueueId_t mq_id, <span class="type">const</span> <span class="type">void</span> *msg_ptr, <span class="type">uint8_t</span> msg_prio, <span class="type">uint32_t</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>获取消息</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Obtains a message in a message queue.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param mq_id 队列ID：Indicates the message queue ID, which is obtained using osMessageQueueNew.</span></span><br><span class="line"><span class="comment">* @param msg_ptr 存放取得消息的指针：Indicates the pointer to the buffer for storing the message to be retrieved from the message queue.</span></span><br><span class="line"><span class="comment">* @param msg_prio （无用）Indicates the pointer to the buffer for storing the priority of the message to be retrieved from the message queue. This parameter is not used.</span></span><br><span class="line"><span class="comment">* @param timeout Indicates the timeout duration.</span></span><br><span class="line"><span class="comment">* @return Returns the CMSIS-RTOS running result.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">osStatus_t <span class="title function_">osMessageQueueGet</span> <span class="params">(osMessageQueueId_t mq_id, <span class="type">void</span> *msg_ptr, <span class="type">uint8_t</span> *msg_prio, <span class="type">uint32_t</span> timeout)</span>;</span><br></pre></td></tr></table></figure><p>可以看出，消息队列是一种先进先出的数据结构，不区分发送者和接收者线程的身份，只按照消息的到达顺序进行存取，即使有多个发布者和接收者线程共用这个消息队列的时候也是如此。如果要指定某个线程的功能，可以在消息的内容中加入标识符或者使用其他的通信机制。</p><h1 id="lt-三-gt-基本外设"><a href="#lt-三-gt-基本外设" class="headerlink" title="&lt;三&gt; 基本外设"></a>&lt;三&gt; 基本外设</h1><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><div class="table-container"><table><thead><tr><th>API名称</th><th>说明</th></tr></thead><tbody><tr><td>unsigned int GpioInit(void);</td><td>GPIO模块初始化</td></tr><tr><td>unsigned int GpioSetDir(WifiIotGpioIdx id, WifiIotGpioDir dir);</td><td>设置GPIO引脚方向，id参数用于指定引脚，dir参数用于指定输入或输出</td></tr><tr><td>unsigned int GpioSetOutputVal(WifiIotGpioIdx id, WifiIotGpioValue val);</td><td>设置GPIO引脚的输出状态，id参数用于指定引脚，val参数用于指定高电平或低电平</td></tr><tr><td>unsigned int IoSetFunc(WifiIotIoName id, unsigned char val);</td><td>设置引脚功能，id参数用于指定引脚，val用于指定引脚功能</td></tr><tr><td>unsigned int GpioDeinit(void);</td><td>解除GPIO模块初始化</td></tr></tbody></table></div><p>每个IO口具体的可以配置的功能可以参考 <strong>iot_gpio_ex.h，</strong>里面有各个IO口的宏定义；通过 <strong>IoSetFunc( )</strong> 配置IO口功能</p><h2 id="GPIO中断"><a href="#GPIO中断" class="headerlink" title="GPIO中断"></a>GPIO中断</h2><div class="table-container"><table><thead><tr><th>API名称</th><th>说明</th></tr></thead><tbody><tr><td>unsigned int GpioGetInputVal(WifiIotGpioIdx id, WifiIotGpioValue *val);</td><td>获取GPIO引脚状态，id参数用于指定引脚，val参数用于接收GPIO引脚状态</td></tr><tr><td>unsigned int IoSetPull(WifiIotIoName id, WifiIotIoPull val);</td><td>设置引脚上拉或下拉状态，id参数用于指定引脚，val参数用于指定上拉或下拉状态</td></tr><tr><td>unsigned int GpioRegisterIsrFunc(WifiIotGpioIdx id, WifiIotGpioIntType intType, WifiIotGpioIntPolarity intPolarity, GpioIsrCallbackFunc func, char *arg);</td><td>注册GPIO引脚中断，id参数用于指定引脚，intType参数用于指定中断触发类型（边缘触发或水平触发），intPolarity参数用于指定具体的边缘类型（下降沿或上升沿）或水平类型（高电平或低电平），func参数用于指定中断处理函数，arg参数用于指定中断处理函数的附加参数</td></tr><tr><td>typedef void (<em>GpioIsrCallbackFunc) (char </em>arg);</td><td>中断处理函数原型，arg参数为附加参数，可以不适用（填NULL），或传入指向用户自定义类型的参数</td></tr><tr><td>unsigned int GpioUnregisterIsrFunc(WifiIotGpioIdx id);</td><td>解除GPIO引脚中断注册，id参数用于指定引脚</td></tr></tbody></table></div><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IoTGpioInit(LED_TEST_GPIO);</span><br><span class="line">IoTGpioSetDir(LED_TEST_GPIO, IOT_GPIO_DIR_OUT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//GPIO5链接按键</span></span><br><span class="line">IoTGpioInit(IOT_GPIO_KEY);</span><br><span class="line">IoSetFunc(IOT_GPIO_KEY, <span class="number">0</span>);<span class="comment">//GPIO模式</span></span><br><span class="line">IoTGpioSetDir(IOT_GPIO_KEY, IOT_GPIO_DIR_IN);<span class="comment">//输入</span></span><br><span class="line">IoSetPull(IOT_GPIO_KEY, IOT_IO_PULL_UP);<span class="comment">//上拉</span></span><br><span class="line">IoTGpioRegisterIsrFunc(IOT_GPIO_KEY, IOT_INT_TYPE_EDGE, IOT_GPIO_EDGE_FALL_LEVEL_LOW, OnButtonPressed, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>示例demo实现了通过按键控制<strong>led</strong>在<strong>亮、灭、闪烁</strong>间切换</p><h2 id="PWM输出"><a href="#PWM输出" class="headerlink" title="PWM输出"></a>PWM输出</h2><div class="table-container"><table><thead><tr><th>unsigned int PwmInit(WifiIotPwmPort port);</th><th>PWM模块初始化</th></tr></thead><tbody><tr><td>unsigned int PwmStart(WifiIotPwmPort port, unsigned short duty, unsigned short freq);</td><td>开始输出PWM信号</td></tr><tr><td>unsigned int PwmStop(WifiIotPwmPort port);</td><td>停止输出PWM信号</td></tr><tr><td>unsigned int PwmDeinit(WifiIotPwmPort port);</td><td>解除PWM模块初始化</td></tr><tr><td>unsigned int PwmSetClock(WifiIotPwmClkSource clkSource);</td><td>设置PWM模块时钟源</td></tr><tr><td></td></tr></tbody></table></div><h3 id="example-1"><a href="#example-1" class="headerlink" title="example"></a>example</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOT_PWM_BEEP        9</span></span><br><span class="line">IoTGpioInit(IOT_PWM_BEEP);</span><br><span class="line">IoSetFunc(IOT_PWM_BEEP, <span class="number">5</span>); </span><br><span class="line">IoTGpioSetDir(IOT_PWM_BEEP, IOT_GPIO_DIR_OUT);</span><br><span class="line">IoTPwmInit(IOT_PWM_PORT_PWM0);</span><br><span class="line">IoTPwmStart(IOT_PWM_PORT_PWM0, <span class="number">50</span>, <span class="number">4000</span>); <span class="comment">/* 占空比50 / 4000,频率4000 */</span></span><br><span class="line">IoTPwmStop(IOT_PWM_PORT_PWM0);</span><br></pre></td></tr></table></figure><p>具体的IO口及其功能配置可参考<code>iot_gpio_ex.h</code>，这里是将<strong>GPIO9</strong>配置为<strong>5</strong>号功能，即<strong>PWM0_OUT</strong></p><h2 id="ADC输入"><a href="#ADC输入" class="headerlink" title="ADC输入"></a>ADC输入</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">AdcRead</span><span class="params">(WifiIotAdcChannelIndex channel, <span class="type">unsigned</span> <span class="type">short</span> *data, WifiIotAdcEquModelSel equModel, WifiIotAdcCurBais curBais, <span class="type">unsigned</span> <span class="type">short</span> rstCnt)</span>;</span><br></pre></td></tr></table></figure><p>输入参数是通道<code>channel</code>，存数据的的指针<code>*data</code>，ADC方程模型<code>equModel</code>，参考电压<code>curBais</code>，<code>rstnt</code>表示从复位到转换开始的时间计数，每个计数相当于334纳秒，取值范围是0到0xFF0。</p><h3 id="方程模型"><a href="#方程模型" class="headerlink" title="方程模型"></a>方程模型</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/** One-equation model */</span></span><br><span class="line">    IOT_ADC_EQU_MODEL_1,</span><br><span class="line">    <span class="comment">/** Two-equation model */</span></span><br><span class="line">    IOT_ADC_EQU_MODEL_2,</span><br><span class="line">    <span class="comment">/** Four-equation model */</span></span><br><span class="line">    IOT_ADC_EQU_MODEL_4,</span><br><span class="line">    <span class="comment">/** Eight-equation model */</span></span><br><span class="line">    IOT_ADC_EQU_MODEL_8,</span><br><span class="line">    <span class="comment">/** Button value */</span></span><br><span class="line">    IOT_ADC_EQU_MODEL_BUTT,</span><br><span class="line">&#125; IotAdcEquModelSel;</span><br></pre></td></tr></table></figure><p>方程模型是用来设置ADC的分辨率的，也就是ADC能够区分多少个不同等级的模拟输入电压。分辨率越高，表示ADC能够更精确地转换模拟信号，但也需要更多的时间和资源。方程模型的枚举类型有四个选项，分别对应一元、二元、四元和八元方程模型。一元方程模型是最简单的，它只需要一个方程就能确定ADC的输出值。二元方程模型需要两个方程，四元方程模型需要四个方程，八元方程模型需要八个方程。方程的数量越多，表示ADC的分辨率越高，但也越复杂。</p><h3 id="复位rstcnt"><a href="#复位rstcnt" class="headerlink" title="复位rstcnt"></a>复位rstcnt</h3><p>（bing说的，仅供参考）</p><p>rstCnt是用来设置从复位到转换开始的时间计数的，也就是ADC在复位后需要等待多久才能开始转换模拟信号。这个参数可以用来调节ADC的采样速率，也就是每秒钟能转换多少次模拟信号。rstCnt的值越大，表示等待的时间越长，采样速率越低。rstCnt的值越小，表示等待的时间越短，采样速率越高。rstCnt的单位是ADC时钟周期，每个周期相当于334纳秒。rstCnt的取值范围是0到0xFF0，也就是0到4080个时钟周期。</p><ul><li><a href="https://securitycamcenter.com/reset-adc-alarm-com-camera/">ADC可以通过软件或硬件的方式来复位。软件复位是通过设置ADC的控制寄存器来实现的，比如ADC_Reset函数<strong>1</strong></a><a href="https://support.citrix.com/article/CTX200852/citrix-adc-netscaler-reset-codes-reference">。硬件复位是通过外部信号或电源来实现的，比如ADC_ResetPin函数<strong>2</strong></a>。</li><li><a href="https://blog.csdn.net/mrlixirong/article/details/102763721">ADC可以在初始化时进行复位，以清除之前的设置和状态，保证ADC的正常工作。比如在STM32F0xx标准库中，有一个函数叫做ADC_DeInit，它可以把ADC恢复到默认状态<strong>3</strong></a>。</li><li><a href="https://blog.csdn.net/Redbean33/article/details/109614383">ADC可以在转换前或转换后进行复位，以避免一些错误或干扰。比如在F28335芯片中，有一个函数叫做ADC_reset，它可以在转换前复位整个ADC模块<strong>4</strong></a>。另外，在某些模式下，比如连续转换模式或DMA模式，ADC可能会在转换完成后自动复位。</li><li>ADC可以在遇到异常情况时进行复位，以恢复正常工作。比如在Alarm.Com摄像头中，如果出现连接问题或配置问题，可以通过按住复位按钮来恢复出厂设置。</li></ul><h3 id="参考电压"><a href="#参考电压" class="headerlink" title="参考电压"></a>参考电压</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">/** Automatic control */</span></span><br><span class="line">    IOT_ADC_CUR_BAIS_DEFAULT,</span><br><span class="line">    <span class="comment">/** Automatic control */</span></span><br><span class="line">    IOT_ADC_CUR_BAIS_AUTO,</span><br><span class="line">    <span class="comment">/** Manual control (AVDD = 1.8 V) */</span></span><br><span class="line">    IOT_ADC_CUR_BAIS_1P8V,</span><br><span class="line">    <span class="comment">/** Manual control (AVDD = 3.3 V) */</span></span><br><span class="line">    IOT_ADC_CUR_BAIS_3P3V,</span><br><span class="line">    <span class="comment">/** Button value */</span></span><br><span class="line">    IOT_ADC_CUR_BAIS_BUTT,</span><br><span class="line">&#125; IotAdcCurBais;</span><br></pre></td></tr></table></figure><p>参考电压是用来作为ADC转换的标准的，也就是ADC能够测量的最大输入电压。参考电压越高，表示ADC能够接受更大范围的模拟信号，但也会降低转换的精度。参考电压可以是内部或外部提供的，也可以是自动控制的。模拟电源控制模式是用来设置参考电压的来源和值的。模拟电源控制模式的枚举类型有五个选项，分别对应默认、自动、1.8V、3.3V和按钮值。默认和自动表示由系统自动选择合适的参考电压，1.8V和3.3V表示手动选择固定的参考电压，按钮值表示无效的选项。</p><h2 id="I2C通信"><a href="#I2C通信" class="headerlink" title="I2C通信"></a>I2C通信</h2><div class="table-container"><table><thead><tr><th>API名称</th><th>说明</th></tr></thead><tbody><tr><td>IoTI2cInit(unsigned int id, unsigned int baudrate);</td><td>用指定的波特速率初始化I2C设备</td></tr><tr><td>IoTI2cDeinit(unsigned int id);</td><td>取消初始化I2C设备</td></tr><tr><td>IoTI2cWrite(unsigned int id, unsigned short deviceAddr, const unsigned char *data, unsigned int dataLen);</td><td>将数据写入I2C设备</td></tr><tr><td>IoTI2cRead(unsigned int id, unsigned short deviceAddr, unsigned char *data, unsigned int dataLen);</td><td>从I2C设备中读取数据</td></tr><tr><td>IoTI2cSetBaudrate(unsigned int id, unsigned int baudrate);</td><td>设置I2C设备的波特率</td></tr></tbody></table></div><h1 id="lt-四-gt-TCP通讯"><a href="#lt-四-gt-TCP通讯" class="headerlink" title="&lt;四&gt; TCP通讯"></a>&lt;四&gt; TCP通讯</h1><p><a href="https://zhuanlan.zhihu.com/p/400788077">一篇看懂 | TCP原理详细图解 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/64155705">TCP协议详解 - 知乎 (zhihu.com)</a></p><p><a href="https://zhuanlan.zhihu.com/p/341011748">socket套接字详解（TCP与UDP） - 知乎 (zhihu.com)</a></p><p>例程代码使用了<strong>lwip</strong>库来实现tcp通信的功能。</p><blockquote><p>lwip是一个轻量级的tcp/ip协议栈，适用于嵌入式系统。</p></blockquote><h3 id="client"><a href="#client" class="headerlink" title="client"></a>client</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 包含标准输入输出库</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 包含lwip库中的sockets头文件，提供了socket编程的接口</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;lwip/sockets.h&quot;</span></span></span><br><span class="line"><span class="comment">// 包含net_demo头文件，定义了一些函数原型和宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net_demo.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局变量g_request，是一个字符串数组，存放了要发送给服务器的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> g_request[] = <span class="string">&quot;Hello,I am Lwip&quot;</span>;</span><br><span class="line"><span class="comment">// 定义一个全局变量g_response，是一个字符串数组，存放了从服务器接收到的数据</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> g_response[<span class="number">128</span>] = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数TcpClientTest，用于作为客户端与服务器进行tcp通信</span></span><br><span class="line"><span class="comment">// 参数host是服务器的IP地址，参数port是服务器的端口号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">TcpClientTest</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* host, <span class="type">unsigned</span> <span class="type">short</span> port)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用socket函数创建一个TCP套接字，返回一个套接字描述符sockfd</span></span><br><span class="line"><span class="comment">//套接字是网络编程中的一种通信机制，是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点</span></span><br><span class="line"><span class="comment">//简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</span></span><br><span class="line">    <span class="comment">// 参数AF_INET表示使用IPv4协议族，参数SOCK_STREAM表示使用TCP协议，参数0表示使用默认协议</span></span><br><span class="line">    <span class="type">int</span> sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); <span class="comment">// TCP socket</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个结构体变量serverAddr，用于存放服务器的地址信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serverAddr</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 设置地址族为AF_INET，与套接字参数一致</span></span><br><span class="line">    serverAddr.sin_family = AF_INET;  <span class="comment">// AF_INET表示IPv4协议</span></span><br><span class="line">    <span class="comment">// 设置端口号为port，并转换为网络字节序（大端序）</span></span><br><span class="line"><span class="comment">//主机字节序是指不同的计算机系统存储数据的方式，有大端字节序和小端字节序之分。网络字节序是指TCP/IP协议规定的数据传输的方式，采用大端字节序。</span></span><br><span class="line">    serverAddr.sin_port = htons(port);  <span class="comment">// 端口号，从主机字节序转为网络字节序</span></span><br><span class="line">    <span class="comment">// 调用inet_pton函数将主机IP地址从“点分十进制”字符串转化为标准格式（32位整数），并存放在serverAddr.sin_addr中</span></span><br><span class="line">    <span class="comment">// 如果转换成功则返回正数，如果失败则返回负数或0，并关闭套接字</span></span><br><span class="line">    <span class="keyword">if</span> (inet_pton(AF_INET, host, &amp;serverAddr.sin_addr) &lt;= <span class="number">0</span>) &#123;  <span class="comment">// 将主机IP地址从“点分十进制”字符串 转化为 标准格式（32位整数）</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;inet_pton failed!\r\n&quot;</span>);</span><br><span class="line">        lwip_close(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用connect函数尝试和目标主机建立连接，连接成功会返回0 ，失败返回 -1</span></span><br><span class="line">    <span class="comment">// 参数sockfd是套接字描述符，参数serverAddr是目标主机的地址信息，参数sizeof(serverAddr)是地址信息的长度</span></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (<span class="keyword">struct</span> sockaddr *)&amp;serverAddr, <span class="keyword">sizeof</span>(serverAddr)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;connect failed!\r\n&quot;</span>);</span><br><span class="line">        lwip_close(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果连接成功，则打印提示信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;connect to server %s success!\r\n&quot;</span>, host);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立连接成功之后，这个TCP套接字描述符sockfd就具有了“连接状态”，发送、接收对端都是connect参数指定的目标主机和端口</span></span><br><span class="line">    <span class="comment">// 调用send函数发送数据给服务器，返回值retval是实际发送的字节数</span></span><br><span class="line">    <span class="comment">// 参数sockfd是套接字描述符，参数g_request是要发送的数据缓冲区，参数sizeof(g_request)是要发送的数据长度，参数0表示使用默认标志</span></span><br><span class="line">    <span class="type">ssize_t</span> retval = send(sockfd, g_request, <span class="keyword">sizeof</span>(g_request), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果返回值小于0，则表示发送失败，并关闭套接字</span></span><br><span class="line">    <span class="keyword">if</span> (retval &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send g_request failed!\r\n&quot;</span>);</span><br><span class="line">        lwip_close(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果发送成功，则打印提示信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;send g_request&#123;%s&#125; %ld to server done!\r\n&quot;</span>, g_request, retval);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用recv函数接收服务器发送过来的数据，并存放在g_response缓冲区中，返回值retval是实际接收到的字节数</span></span><br><span class="line">    <span class="comment">// sockfd是套接字描述符，g_response是要接收的数据缓冲区，sizeof(g_response)是要接收的数据长度，参数0表示使用默认标志</span></span><br><span class="line">    retval = recv(sockfd, &amp;g_response, <span class="keyword">sizeof</span>(g_response), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 如果返回值小于等于0，则表示接收失败或者完成，并关闭套接字</span></span><br><span class="line">    <span class="keyword">if</span> (retval &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;send g_response from server failed or done, %ld!\r\n&quot;</span>, retval);</span><br><span class="line">        lwip_close(sockfd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果接收成功，则在g_response末尾添加一个空字符&#x27;\0&#x27;作为字符串结束符，并打印提示信息</span></span><br><span class="line">    g_response[retval] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;recv g_response&#123;%s&#125; %ld from server done!\r\n&quot;</span>, g_response, retval);</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    lwip_close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数NetDemoTest，用于调用TcpClientTest函数进行测试</span></span><br><span class="line"><span class="comment">// 参数port是服务器端口号，参数host是服务器IP地址</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">NetDemoTest</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> port, <span class="type">const</span> <span class="type">char</span>* host)</span></span><br><span class="line">&#123;</span><br><span class="line">    (<span class="type">void</span>) host;</span><br><span class="line">    <span class="comment">// 打印提示信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpClientTest start\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I will connect to %s\r\n&quot;</span>, host);</span><br><span class="line">    <span class="comment">// 调用TcpClientTest函数进行tcp通信测试</span></span><br><span class="line">    TcpClientTest(host, port);</span><br><span class="line">    <span class="comment">// 打印提示信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;TcpClientTest done!\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval = recv(sockfd, &amp;g_response, <span class="keyword">sizeof</span>(g_response), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>关于接收函数，我问了newbing一些问题，这是它的回答。</p><p>如果接收成功的话，retval就是接收到的数据字节数吗？</p><p>是的，如果接收成功的话，retval就是接收到的数据长度，单位是字节。recv函数的返回值是一个ssize_t类型的整数，它表示实际接收到的字节数。如果返回值等于0，表示对方已经关闭了连接；如果返回值小于0，表示发生了错误，可以用errno变量来查看错误码。</p><p>retval小于零或等于零分别有什么含义吗？</p><p>如上所述，retval小于零表示发生了错误，retval等于零表示对方已经关闭了连接。一些常见的错误码有：</p><ul><li>EAGAIN或EWOULDBLOCK：表示套接字是非阻塞的，而当前没有可用的数据，需要稍后再试。</li><li>EBADF：表示套接字描述符无效。</li><li>ECONNREFUSED：表示远程主机拒绝了连接请求。</li><li>EFAULT：表示缓冲区指针指向无效的内存地址。</li><li>EINTR：表示接收过程被信号中断。</li><li>EINVAL：表示传递了无效的参数。</li><li>ENOMEM：表示内存不足。</li><li>ENOTCONN：表示套接字没有连接。</li><li>ENOTSOCK：表示套接字描述符不是一个套接字。</li><li>ETIMEDOUT：表示连接超时。</li></ul><p>接收到的数据是被自动接收然后存放在某个缓冲区里吗？如果我不调用这个函数，发送者是否会接收到这个数据的ACK呢？</p><p>是的，接收到的数据是被自动接收然后存放在内核为每个套接字维护的一个缓冲区里。recv函数只是从缓冲区中读取数据，并将其复制到用户指定的缓冲区中。如果用户不调用recv函数，那么内核缓冲区可能会被填满，导致TCP流量控制机制生效，使得发送者降低发送速率或停止发送。发送者是否会接收到这个数据的ACK取决于内核缓冲区是否有空间来存放新到达的数据。如果有空间，那么内核会发送ACK给发送者；如果没有空间，那么内核会延迟发送ACK或发送窗口为零的ACK给发送者。</p><p>我是否可以将发送和接受分别使用两个线程实现呢？</p><p>是的，你可以将发送和接受分别使用两个线程实现。这样可以实现全双工通信，即同时进行发送和接受操作。你需要为每个线程传递相同的套接字描述符，并在每个线程中调用send和recv函数。你还需要注意同步和互斥问题，避免多个线程同时操作同一个资源。</p><h1 id="lt-五-gt-MQTT协议"><a href="#lt-五-gt-MQTT协议" class="headerlink" title="&lt;五&gt; MQTT协议"></a>&lt;五&gt; MQTT协议</h1><p><a href="https://zhuanlan.zhihu.com/p/421109780">MQTT协议，终于有人讲清楚了 - 知乎 (zhihu.com)</a></p><p><a href="https://www.runoob.com/json/json-syntax.html">JSON 语法 | 菜鸟教程 (runoob.com)</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hi_task.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hi_wifi_api.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hi_mux.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hi_io.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;hi_gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iot_config.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iot_log.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iot_main.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iot_profile.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ohos_init.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;cmsis_os2.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* attribute initiative to report */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TAKE_THE_INITIATIVE_TO_REPORT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ONE_SECOND                          (1000)</span></span><br><span class="line"><span class="comment">/* oc request id */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CN_COMMADN_INDEX                    <span class="string">&quot;commands/request_id=&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WECHAT_SUBSCRIBE_LIGHT              <span class="string">&quot;light&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WECHAT_SUBSCRIBE_LIGHT_ON_STATE     <span class="string">&quot;1&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WECHAT_SUBSCRIBE_LIGHT_OFF_STATE    <span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="comment">// &lt; 全局变量，表示灯的状态，-1表示未初始化，0表示关，1表示开</span></span><br><span class="line"><span class="type">int</span> g_ligthStatus = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt; 这是一个函数指针类型，用于回调函数的参数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*FnMsgCallBack)</span><span class="params">(hi_gpio_value val)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt; 这是一个结构体类型，用于存储一些功能回调的相关信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FunctionCallback</span> &#123;</span></span><br><span class="line"> hi_bool stop; <span class="comment">// &lt; 是否停止</span></span><br><span class="line"> hi_u32 conLost; <span class="comment">// &lt; 连接丢失次数</span></span><br><span class="line"> hi_u32 queueID; <span class="comment">// &lt; 队列ID</span></span><br><span class="line"> hi_u32 iotTaskID; <span class="comment">// &lt; IoT任务ID</span></span><br><span class="line"> FnMsgCallBack msgCallBack; <span class="comment">// &lt; 消息回调函数指针</span></span><br><span class="line">&#125;FunctionCallback;</span><br><span class="line">FunctionCallback g_functinoCallback; <span class="comment">// &lt; 定义一个全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* CPU Sleep time Set */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">TaskMsleep</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span> (ms &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> HI_ERR_FAILURE;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> hi_sleep((hi_u32)ms);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt; 这是一个设备配置初始化的函数，用于设置GPIO_9引脚的功能和输出值</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DeviceConfigInit</span><span class="params">(hi_gpio_value val)</span></span><br><span class="line">&#123;</span><br><span class="line"> hi_io_set_func(HI_IO_NAME_GPIO_9, HI_IO_FUNC_GPIO_9_GPIO); <span class="comment">// &lt; 设置GPIO_9引脚为GPIO功能</span></span><br><span class="line"> hi_gpio_set_dir(HI_GPIO_IDX_9, HI_GPIO_DIR_OUT); <span class="comment">// &lt; 设置GPIO_9引脚为输出方向</span></span><br><span class="line"> hi_gpio_set_ouput_val(HI_GPIO_IDX_9, val); <span class="comment">// &lt; 设置GPIO_9引脚的输出值为val</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt; 这是一个设备消息回调函数的注册函数，用于将回调函数指针赋值给全局变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">DeviceMsgCallback</span><span class="params">(FnMsgCallBack msgCallBack)</span></span><br><span class="line">&#123;</span><br><span class="line"> g_functinoCallback.msgCallBack = msgCallBack;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt; 这是一个微信控制设备消息的函数，用于根据val值初始化设备配置</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">wechatControlDeviceMsg</span><span class="params">(hi_gpio_value val)</span></span><br><span class="line">&#123;</span><br><span class="line"> DeviceConfigInit(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt; 这是一个MQTT消息接收回调函数，当有消息到达时会被调用</span></span><br><span class="line"><span class="comment">// &lt; qos:数据可靠性  topic:订阅主题  payload参数是一个json字符串，包含了设备状态信息</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DemoMsgRcvCallBack</span><span class="params">(<span class="type">int</span> qos, <span class="type">const</span> <span class="type">char</span> *topic, <span class="type">const</span> <span class="type">char</span> *payload)</span></span><br><span class="line">&#123;</span><br><span class="line"> IOT_LOG_DEBUG(<span class="string">&quot;RCVMSG:QOS:%d TOPIC:%s PAYLOAD:%s\r\n&quot;</span>, qos, topic, payload);</span><br><span class="line"> <span class="comment">/* 云端下发命令后，板端的操作处理 */</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strstr</span>(payload, WECHAT_SUBSCRIBE_LIGHT) != <span class="literal">NULL</span>) &#123; <span class="comment">// &lt; 如果payload中包含了WECHAT_SUBSCRIBE_LIGHT字符串</span></span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">strstr</span>(payload, WECHAT_SUBSCRIBE_LIGHT_OFF_STATE) != <span class="literal">NULL</span>) &#123; <span class="comment">// &lt; 如果payload中包含了WECHAT_SUBSCRIBE_LIGHT_OFF_STATE字符串</span></span><br><span class="line"> wechatControlDeviceMsg(HI_GPIO_VALUE1); <span class="comment">// &lt; 调用微信控制设备消息函数，传入HI_GPIO_VALUE1作为参数</span></span><br><span class="line"> g_ligthStatus = HI_FALSE; <span class="comment">// &lt; 将灯的状态设置为关</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">// &lt; 否则</span></span><br><span class="line"> wechatControlDeviceMsg(HI_GPIO_VALUE0); <span class="comment">// &lt; 调用微信控制设备消息函数，传入HI_GPIO_VALUE0作为参数</span></span><br><span class="line"> g_ligthStatus = HI_TRUE; <span class="comment">// &lt; 将灯的状态设置为开</span></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> HI_NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* publish sample */</span></span><br><span class="line">hi_void <span class="title function_">IotPublishSample</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="comment">/* reported attribute */</span></span><br><span class="line"> WeChatProfile weChatProfile = &#123;</span><br><span class="line"> .subscribeType = <span class="string">&quot;type&quot;</span>,<span class="comment">//订阅类型，表示设备的类型，比如温度计、湿度计、电机、灯等。</span></span><br><span class="line"> .status.subState = <span class="string">&quot;state&quot;</span>,<span class="comment">//订阅状态，表示设备是否订阅了云端的服务，比如接收命令或发送数据。</span></span><br><span class="line"> .status.subReport = <span class="string">&quot;reported&quot;</span>,<span class="comment">//订阅报告，表示设备是否向云端报告了自己的属性信息。</span></span><br><span class="line"> .status.reportVersion = <span class="string">&quot;version&quot;</span>,<span class="comment">//表示设备属性信息的版本号，用于区分不同的报告。</span></span><br><span class="line"> .status.Token = <span class="string">&quot;clientToken&quot;</span>,<span class="comment">//客户端令牌，表示设备与云端通信的身份标识，用于验证和授权。</span></span><br><span class="line"> <span class="comment">/* report motor */</span></span><br><span class="line"> .reportAction.subDeviceActionMotor = <span class="string">&quot;motor&quot;</span>,</span><br><span class="line"> .reportAction.motorActionStatus = <span class="number">0</span>, <span class="comment">/* 0 : motor off */</span></span><br><span class="line"> <span class="comment">/* report temperature */</span></span><br><span class="line"> .reportAction.subDeviceActionTemperature = <span class="string">&quot;temperature&quot;</span>,</span><br><span class="line"> .reportAction.temperatureData = <span class="number">30</span>, <span class="comment">/* 30 :temperature data */</span></span><br><span class="line"> <span class="comment">/* report humidity */</span></span><br><span class="line"> .reportAction.subDeviceActionHumidity = <span class="string">&quot;humidity&quot;</span>,</span><br><span class="line"> .reportAction.humidityActionData = <span class="number">70</span>, <span class="comment">/* humidity data */</span></span><br><span class="line"> <span class="comment">/* report light_intensity */</span></span><br><span class="line"> .reportAction.subDeviceActionLightIntensity = <span class="string">&quot;light_intensity&quot;</span>,</span><br><span class="line"> .reportAction.lightIntensityActionData = <span class="number">60</span>, <span class="comment">/* 60 : light_intensity */</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* report light */</span></span><br><span class="line"> <span class="keyword">if</span> (g_ligthStatus == HI_TRUE) &#123; <span class="comment">// &lt; 如果灯的状态是开</span></span><br><span class="line"> weChatProfile.reportAction.subDeviceActionLight = <span class="string">&quot;light&quot;</span>;</span><br><span class="line"> weChatProfile.reportAction.lightActionStatus = <span class="number">1</span>; <span class="comment">/* 1: light on */</span></span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (g_ligthStatus == HI_FALSE) &#123; <span class="comment">// &lt; 如果灯的状态是关</span></span><br><span class="line"> weChatProfile.reportAction.subDeviceActionLight = <span class="string">&quot;light&quot;</span>;</span><br><span class="line"> weChatProfile.reportAction.lightActionStatus = <span class="number">0</span>; <span class="comment">/* 0: light off */</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123; <span class="comment">// &lt; 否则</span></span><br><span class="line"> weChatProfile.reportAction.subDeviceActionLight = <span class="string">&quot;light&quot;</span>;</span><br><span class="line"> weChatProfile.reportAction.lightActionStatus = <span class="number">0</span>; <span class="comment">/* 0: light off */</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* profile report */</span></span><br><span class="line"> IoTProfilePropertyReport(CONFIG_USER_ID, &amp;weChatProfile); <span class="comment">// &lt; 调用IoTProfilePropertyReport函数，传入用户ID和weChatProfile结构体指针作为参数，向云端报告设备属性信息</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt; 这是一个示例主任务入口函数，在这里我们会设置wifi/cjson/mqtt准备好并等待有任何工作要做的while循环中</span></span><br><span class="line"><span class="type">static</span> hi_void *<span class="title function_">DemoEntry</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line"> WifiStaReadyWait(); <span class="comment">// &lt; 等待wifi连接成功</span></span><br><span class="line"> cJsonInit(); <span class="comment">// &lt; 初始化cjson库</span></span><br><span class="line"> IoTMain(); <span class="comment">// &lt; 调用IoTMain函数，初始化MQTT客户端并连接到服务器</span></span><br><span class="line"> <span class="comment">/* 云端下发回调 */</span></span><br><span class="line"> IoTSetMsgCallback(DemoMsgRcvCallBack); <span class="comment">// &lt; 调用IoTSetMsgCallback函数，将DemoMsgRcvCallBack函数指针作为参数传入，设置MQTT消息接收回调函数</span></span><br><span class="line"> <span class="comment">/* 主动上报 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> TAKE_THE_INITIATIVE_TO_REPORT </span></span><br><span class="line"> <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"> <span class="comment">/* 用户可以在这调用发布函数进行发布，需要用户自己写调用函数 */</span></span><br><span class="line"> IotPublishSample(); <span class="comment">// 发布例程 </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"> TaskMsleep(ONE_SECOND); </span><br><span class="line"> &#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// &lt; 这是一个示例入口函数，在这里我们创建了一个任务，</span></span><br><span class="line"><span class="comment">// 所有的工作都在demo_entry中完成了 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CN_IOT_TASK_STACKSIZE 0x1000 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CN_IOT_TASK_PRIOR 25 </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CN_IOT_TASK_NAME <span class="string">&quot;IOTDEMO&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">AppDemoIot</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"> osThreadAttr_t attr;</span><br><span class="line"> IoTWatchDogDisable();</span><br><span class="line"></span><br><span class="line"> attr.name = <span class="string">&quot;IOTDEMO&quot;</span>;</span><br><span class="line"> attr.attr_bits = <span class="number">0U</span>;</span><br><span class="line"> attr.cb_mem = <span class="literal">NULL</span>;</span><br><span class="line"> attr.cb_size = <span class="number">0U</span>;</span><br><span class="line"> attr.stack_mem = <span class="literal">NULL</span>;</span><br><span class="line"> attr.stack_size = CN_IOT_TASK_STACKSIZE;</span><br><span class="line"> attr.priority = CN_IOT_TASK_PRIOR;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (osThreadNew((osThreadFunc_t)DemoEntry, <span class="literal">NULL</span>, &amp;attr) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;[mqtt] Falied to create IOTDEMO!\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SYS_RUN(AppDemoIot);</span><br></pre></td></tr></table></figure><h2 id="发送函数"><a href="#发送函数" class="headerlink" title="发送函数"></a>发送函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CN_PROFILE_TOPICFMT_TOPIC            <span class="string">&quot;$shadow/operation/19VUBHD786/mqtt&quot;</span></span></span><br><span class="line"><span class="comment">//向微信小程序发送设备的属性信息。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IoTProfilePropertyReport</span><span class="params">(<span class="type">char</span> *deviceID, WeChatProfile *payload)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"> <span class="type">char</span> *topic;</span><br><span class="line"> <span class="type">char</span> *msg;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 函数有两个参数：deviceID和payload。</span></span><br><span class="line"> <span class="comment">// deviceID是一个字符串，表示设备的唯一标识符；</span></span><br><span class="line"> <span class="comment">// payload是一个WeChatProfile类型的指针，表示设备的属性信息。</span></span><br><span class="line"> <span class="keyword">if</span> ((deviceID == <span class="literal">NULL</span>) || (payload== <span class="literal">NULL</span>)) &#123;</span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 函数内部定义了三个局部变量：ret，topic和msg。</span></span><br><span class="line"> <span class="comment">// ret是一个整数，用于存储发送结果；</span></span><br><span class="line"> <span class="comment">// topic是一个字符串指针，用于存储发送的主题；</span></span><br><span class="line"> <span class="comment">// msg是一个字符串指针，用于存储发送的消息。</span></span><br><span class="line"> topic = MakeTopic(CN_PROFILE_TOPICFMT_TOPIC, deviceID, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="comment">// 调用MakeTopic函数，根据CN_PROFILE_TOPICFMT_TOPIC和deviceID生成一个主题，并赋值给topic。</span></span><br><span class="line"> <span class="comment">// CN_PROFILE_TOPICFMT_TOPIC是一个宏定义，表示主题的格式；</span></span><br><span class="line"> <span class="comment">// MakeTopic函数是一个自定义函数，用于拼接字符串。</span></span><br><span class="line"> <span class="keyword">if</span> (topic == <span class="literal">NULL</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> msg = MakeProfileReport(payload);</span><br><span class="line"> <span class="comment">// 调用MakeProfileReport函数，根据payload生成一个消息，并赋值给msg。</span></span><br><span class="line"> <span class="comment">// MakeProfileReport函数是一个自定义函数，用于将WeChatProfile类型的结构体转换为JSON格式的字符串。</span></span><br><span class="line"> <span class="keyword">if</span> ((topic != <span class="literal">NULL</span>) &amp;&amp; (msg != <span class="literal">NULL</span>)) &#123;</span><br><span class="line"> ret = IotSendMsg(<span class="number">0</span>, topic, msg);</span><br><span class="line"> <span class="comment">// 如果topic和msg都不为空，则调用IotSendMsg函数，向微信小程序发送消息，并将返回值赋给ret。</span></span><br><span class="line"> <span class="comment">// IotSendMsg函数是一个自定义函数，用于通过MQTT协议发送消息。</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> hi_free(<span class="number">0</span>, topic);</span><br><span class="line"> cJSON_free(msg);</span><br><span class="line"> <span class="comment">// 释放topic和msg占用的内存。</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> ret;</span><br><span class="line"> <span class="comment">// 函数返回一个整数，表示发送结果。如果成功，返回0；如果失败，返回-1。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="lt-六-gt-MQTT通讯实验"><a href="#lt-六-gt-MQTT通讯实验" class="headerlink" title="&lt;六&gt; MQTT通讯实验"></a>&lt;六&gt; MQTT通讯实验</h1><h2 id="小程序环境配置"><a href="#小程序环境配置" class="headerlink" title="小程序环境配置"></a>小程序环境配置</h2><p>跟着教程走，在<strong>cloudfunctions</strong>选择环境之前会新建一个云环境，但是选择的时候却没有这个选项。关闭工程重新打开即可刷新。</p><h2 id="工程源码阅读"><a href="#工程源码阅读" class="headerlink" title="工程源码阅读"></a>工程源码阅读</h2><p>首先看工程配置。souce中的多个<strong>c文件</strong>被编译为静态库供父级使用；在父级的BUILD文件中调用<strong>app_demo_iot</strong>，故其为app层入口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// iottencent_demo/BUILD.gn</span><br><span class="line">static_library(<span class="string">&quot;appDemoIot&quot;</span>) &#123;</span><br><span class="line">  sources = [</span><br><span class="line">    <span class="string">&quot;app_demo_iot.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cjson_init.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iot_hmac.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iot_log.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iot_main.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iot_profile.c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;iot_sta.c&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  include_dirs = [</span><br><span class="line">    <span class="string">&quot;./&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//utils/native/lite/include&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//kernel/liteos_m/kal/cmsis&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//base/iot_hardware/peripheral/interfaces/kits&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//device/hisilicon/hispark_pegasus/sdk_liteos/third_party/lwip_sack/include/lwip&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//third_party/cJSON&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//device/hisilicon/hispark_pegasus/sdk_liteos/third_party/mbedtls/include/mbedtls&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//foundation/communication/wifi_lite/interfaces/wifiservice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//device/hisilicon/hispark_pegasus/sdk_liteos/third_party/paho.mqtt.c/include/mqtt&quot;</span>,</span><br><span class="line">    <span class="string">&quot;//device/hisilicon/hispark_pegasus/sdk_liteos/third_party/libcoap/include/coap2&quot;</span>,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">  defines = [ <span class="string">&quot;WITH_LWIP&quot;</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iot-profile"><a href="#iot-profile" class="headerlink" title="iot_profile"></a>iot_profile</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CN_PROFILE_TOPICFMT_TOPIC            <span class="string">&quot;$shadow/operation/Pegasus/Board1&quot;</span></span></span><br></pre></td></tr></table></figure><ul><li><strong><code>$shadow</code></strong>表示设备影子的主题前缀，设备影子是一种用于存储和同步设备状态的机制。</li><li><strong><code>/operation</code></strong>表示操作类型的主题分隔符，操作类型包括获取、更新、删除等。</li><li><strong><code>/Pegasus/Board1</code></strong>表示设备的标识符，用于区分不同的设备。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个函数，用于上报物联网设备的配置信息，其实就是将wechatprofile转化为话题消息并发送</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IoTProfilePropertyReport</span><span class="params">(<span class="type">char</span> *deviceID, WeChatProfile *payload)</span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">-1</span>; <span class="comment">//定义一个变量，表示返回值，默认为-1，表示失败</span></span><br><span class="line">  <span class="type">char</span> *topic; <span class="comment">//定义一个变量，表示主题字符串</span></span><br><span class="line">  <span class="type">char</span> *msg; <span class="comment">//定义一个变量，表示消息字符串</span></span><br><span class="line">  <span class="keyword">if</span> ((deviceID == <span class="literal">NULL</span>) || (payload== <span class="literal">NULL</span>)) &#123; <span class="comment">//如果参数为空</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回-1，表示失败</span></span><br><span class="line">  &#125;</span><br><span class="line">  topic = MakeTopic(CN_PROFILE_TOPICFMT_TOPIC, deviceID, <span class="literal">NULL</span>); <span class="comment">//调用MakeTopic()函数，根据设备ID和一个固定的主题格式，生成一个主题字符串，并赋值给topic变量</span></span><br><span class="line">  <span class="keyword">if</span> (topic == <span class="literal">NULL</span>) &#123; <span class="comment">//如果主题字符串为空</span></span><br><span class="line">    <span class="keyword">return</span> ret; <span class="comment">//返回-1，表示失败</span></span><br><span class="line">  &#125;</span><br><span class="line">  msg = MakeProfileReport(payload); <span class="comment">//调用MakeProfileReport()函数，根据设备的配置信息结构体，生成一个JSON格式的消息字符串，并赋值给msg变量</span></span><br><span class="line">  <span class="keyword">if</span> ((topic != <span class="literal">NULL</span>) &amp;&amp; (msg != <span class="literal">NULL</span>)) &#123; <span class="comment">//如果主题字符串和消息字符串都不为空</span></span><br><span class="line">    ret = IotSendMsg(<span class="number">0</span>, topic, msg); <span class="comment">//调用IotSendMsg()函数，将消息发送到主题，并将返回值赋值给ret变量</span></span><br><span class="line">  &#125;</span><br><span class="line">  hi_free(<span class="number">0</span>, topic); <span class="comment">//释放主题字符串占用的内存</span></span><br><span class="line">  cJSON_free(msg); <span class="comment">//释放消息字符串占用的内存</span></span><br><span class="line">  <span class="keyword">return</span> ret; <span class="comment">//返回ret变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通信数据格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个结构体类型，表示设备影子的状态信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *subState; <span class="comment">//表示订阅状态，有sub和unsub两种取值</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *subReport; <span class="comment">//表示上报状态，有report和unreport两种取值</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *reportVersion; <span class="comment">//表示上报版本，用于同步设备影子的版本</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *Token; <span class="comment">//表示令牌，用于验证设备身份</span></span><br><span class="line">&#125;WeChatProfileStatus;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体类型，表示设备的上报信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">int</span> lightActionStatus; <span class="comment">//表示灯的动作状态，有0和1两种取值，分别表示关和开</span></span><br><span class="line">  <span class="type">int</span> motorActionStatus; <span class="comment">//表示电机的动作状态，有0和1两种取值，分别表示停止和运行</span></span><br><span class="line">  <span class="type">int</span> temperatureData; <span class="comment">//表示温度数据，单位是摄氏度</span></span><br><span class="line">  <span class="type">int</span> humidityActionData; <span class="comment">//表示湿度数据，单位是百分比</span></span><br><span class="line">  <span class="type">int</span> lightIntensityActionData; <span class="comment">//表示光照强度数据，单位是勒克斯</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *subDeviceActionLight; <span class="comment">//表示灯的动作指令，有on和off两种取值，分别表示开和关</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *subDeviceActionMotor; <span class="comment">//表示电机的动作指令，有start和stop两种取值，分别表示运行和停止</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *subDeviceActionTemperature; <span class="comment">//表示温度的动作指令，有get和set两种取值，分别表示获取和设置</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *subDeviceActionHumidity; <span class="comment">//表示湿度的动作指令，有get和set两种取值，分别表示获取和设置</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *subDeviceActionLightIntensity; <span class="comment">//表示光照强度的动作指令，有get和set两种取值，分别表示获取和设置</span></span><br><span class="line">&#125;WeChatProfileReporte;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体类型，表示设备影子的完整信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *subscribeType; <span class="comment">//表示订阅类型，有status、report、all三种取值，分别表示订阅状态、上报、全部</span></span><br><span class="line">  WeChatProfileStatus status; <span class="comment">//表示设备影子的状态信息结构体</span></span><br><span class="line">  WeChatProfileReporte reportAction; <span class="comment">//表示设备的上报信息结构体</span></span><br><span class="line">&#125;WeChatProfile;</span><br></pre></td></tr></table></figure><h3 id="app-demo-iot-c"><a href="#app-demo-iot-c" class="headerlink" title="app_demo_iot.c"></a>app_demo_iot.c</h3><p>主函数创建了一个线程，注册消息接收回调函数，并且可以不断发送消息汇报当前状态。</p><p>回调函数解析数据，并依此控制led亮灭。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">IoTSetMsgCallback(DemoMsgRcvCallBack);<span class="comment">//回调函数的注册</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">DemoMsgRcvCallBack</span><span class="params">(<span class="type">int</span> qos, <span class="type">const</span> <span class="type">char</span> *topic, <span class="type">const</span> <span class="type">char</span> *payload)</span></span><br><span class="line">&#123;</span><br><span class="line">    IOT_LOG_DEBUG(<span class="string">&quot;RCVMSG:QOS:%d TOPIC:%s PAYLOAD:%s\r\n&quot;</span>, qos, topic, payload);</span><br><span class="line">    <span class="comment">/* 云端下发命令后，板端的操作处理 */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(payload, WECHAT_SUBSCRIBE_LIGHT) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strstr</span>(payload, WECHAT_SUBSCRIBE_LIGHT_OFF_STATE) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            wechatControlDeviceMsg(HI_GPIO_VALUE1);</span><br><span class="line">            g_ligthStatus = HI_FALSE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            wechatControlDeviceMsg(HI_GPIO_VALUE0);</span><br><span class="line">            g_ligthStatus = HI_TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> HI_NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>strstr()</code> 函数搜索一个字符串在另一个字符串中的第一次出现。</p><ul><li>找到所搜索的字符串，则该函数返回第一次匹配的字符串的地址；</li><li>如果未找到所搜索的字符串，则返回NULL。</li></ul><p>需要注意的是收到消息后第一时间触发的回调函数并不是这个函数，查看DEBUG信息可知</p><blockquote><p>[DEBUG][MsgRcvCallBack] RCVMSG:QOS:0 TOPIC:GNJOUT1LQ6/Board1/data PAYLOAD:{“light”:0}</p><p>[DEBUG][ProcessQueueMsg] QUEUEMSG:QOS:0 TOPIC:GNJOUT1LQ6/Board1/data PAYLOAD:{“light”:0}</p><p>[DEBUG][DemoMsgRcvCallBack] RCVMSG:QOS:0 TOPIC:GNJOUT1LQ6/Board1/data PAYLOAD:{“light”:0}</p></blockquote><p>系统先通过<code>MsgRcvCallBack()</code>和<code>ProcessQueueMsg()</code>处理后，再将信息给到我们<strong>自己定义</strong>的回调函数中</p><h3 id="iot-main"><a href="#iot-main" class="headerlink" title="iot_main"></a>iot_main</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个枚举类型，表示消息的类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">  EN_IOT_MSG_PUBLISH = <span class="number">0</span>, <span class="comment">//发布消息</span></span><br><span class="line">  EN_IOT_MSG_RECV, <span class="comment">//接收消息</span></span><br><span class="line">&#125;EnIotMsg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体类型，表示消息的内容</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  EnIotMsg type; <span class="comment">//消息的类型</span></span><br><span class="line">  <span class="type">int</span> qos; <span class="comment">//消息的服务质量</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *topic; <span class="comment">//消息的主题</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *payload; <span class="comment">//消息的有效载荷</span></span><br><span class="line">&#125;IoTMsg_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构体类型，表示应用程序的回调信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="type">bool</span> stop; <span class="comment">//是否停止运行</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> conLost; <span class="comment">//连接丢失的次数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> queueID; <span class="comment">//消息队列的ID</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> iotTaskID; <span class="comment">//物联网任务的ID</span></span><br><span class="line">  fnMsgCallBack msgCallBack; <span class="comment">//消息回调函数的指针</span></span><br><span class="line">  MQTTClient_deliveryToken tocken; <span class="comment">//发布消息的令牌</span></span><br><span class="line">&#125;IotAppCb_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明一个全局变量，存储应用程序的回调信息</span></span><br><span class="line"><span class="type">static</span> IotAppCb_t gIoTAppCb;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @brief Obtains a message in a message queue.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param mq_id Indicates the message queue ID, which is obtained using osMessageQueueNew.</span></span><br><span class="line"><span class="comment">* @param msg_ptr Indicates the pointer to the buffer for storing the message to be retrieved from the message queue.</span></span><br><span class="line"><span class="comment">* @param msg_prio Indicates the pointer to the buffer for storing the priority of the message to be retrieved from the message queue. This parameter is not used.</span></span><br><span class="line"><span class="comment">* @param timeout Indicates the timeout duration.</span></span><br><span class="line"><span class="comment">* @return Returns the CMSIS-RTOS running result.</span></span><br><span class="line"><span class="comment">* @since 1.0</span></span><br><span class="line"><span class="comment">* @version 1.0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">osStatus_t <span class="title function_">osMessageQueueGet</span> <span class="params">(osMessageQueueId_t mq_id, <span class="type">void</span> *msg_ptr, <span class="type">uint8_t</span> *msg_prio, <span class="type">uint32_t</span> timeout)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * When you want to send some messages to the iot server(including the response message),</span></span><br><span class="line"><span class="comment"> * please call this api</span></span><br><span class="line"><span class="comment"> * @param qos: the mqtt qos,:0,1,2</span></span><br><span class="line"><span class="comment"> * @param topic: the iot mqtt topic</span></span><br><span class="line"><span class="comment"> * @param payload: the mqtt payload</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 0 success while others failed</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @instruction: if success means we write the message to the queue susccess,</span></span><br><span class="line"><span class="comment"> * not means communicate with the server success</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IotSendMsg</span><span class="params">(<span class="type">int</span> qos, <span class="type">const</span> <span class="type">char</span> *topic, <span class="type">const</span> <span class="type">char</span> *payload)</span>;</span><br></pre></td></tr></table></figure><p>接收到信息的“底层”回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CN_TOPIC_SUBSCRIBE_NUM     (sizeof(gDefaultSubscribeTopic) / sizeof(const char *))</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">MsgRcvCallBack</span><span class="params">(<span class="type">char</span> *context, <span class="type">char</span> *topic, <span class="type">int</span> topicLen, MQTTClient_message *message)</span></span><br><span class="line">&#123;</span><br><span class="line">    IoTMsg_t  *msg;</span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">int</span> bufSize;</span><br><span class="line">    <span class="type">int</span> topiLen = topicLen;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (topiLen == <span class="number">0</span>) &#123;</span><br><span class="line">        topiLen = <span class="built_in">strlen</span>(topic);</span><br><span class="line">    &#125;</span><br><span class="line">    bufSize = topiLen + <span class="number">1</span>  + message-&gt;payloadlen + <span class="number">1</span> + <span class="keyword">sizeof</span>(IoTMsg_t);</span><br><span class="line">    buf = hi_malloc(<span class="number">0</span>, bufSize);</span><br><span class="line">    <span class="keyword">if</span> (buf != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        msg = (IoTMsg_t *)buf;</span><br><span class="line">        buf += <span class="keyword">sizeof</span>(IoTMsg_t);</span><br><span class="line">        bufSize -= <span class="keyword">sizeof</span>(IoTMsg_t);</span><br><span class="line">        msg-&gt;qos = message-&gt;qos;</span><br><span class="line">        msg-&gt;type = EN_IOT_MSG_RECV;</span><br><span class="line">        (<span class="type">void</span>)memcpy_s(buf, bufSize, topic, topiLen);</span><br><span class="line">        buf[topiLen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        msg-&gt;topic = buf;</span><br><span class="line">        buf += topiLen + <span class="number">1</span>;</span><br><span class="line">        bufSize -= (topiLen + <span class="number">1</span>);</span><br><span class="line">        (<span class="type">void</span>)memcpy_s(buf, bufSize, message-&gt;payload, message-&gt;payloadlen);</span><br><span class="line">        buf[message-&gt;payloadlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        msg-&gt;payload = buf;</span><br><span class="line">        IOT_LOG_DEBUG(<span class="string">&quot;RCVMSG:QOS:%d TOPIC:%s PAYLOAD:%s\r\n&quot;</span>, msg-&gt;qos, msg-&gt;topic, msg-&gt;payload);</span><br><span class="line">        <span class="keyword">if</span> (IOT_SUCCESS != osMessageQueuePut(gIoTAppCb.queueID, &amp;msg, <span class="number">0</span>, CN_QUEUE_WAITTIMEOUT)) &#123;</span><br><span class="line">            IOT_LOG_ERROR(<span class="string">&quot;Wrie queue failed\r\n&quot;</span>);</span><br><span class="line">            hi_free(<span class="number">0</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    MQTTClient_freeMessage(&amp;message);</span><br><span class="line">    MQTTClient_free(topic);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个函数，用于处理消息队列中的消息</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">MqttProcessQueueMsg</span><span class="params">(MQTTClient client, IoTMsg_t *msg, MQTTClient_message pubMsg)</span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (msg-&gt;type) &#123; <span class="comment">//根据消息的类型执行不同的操作</span></span><br><span class="line">    <span class="keyword">case</span> EN_IOT_MSG_PUBLISH: <span class="comment">//如果消息类型是发布消息</span></span><br><span class="line">      pubMsg.payload = (<span class="type">void</span> *)msg-&gt;payload; <span class="comment">//将消息的有效载荷赋值给发布消息结构体</span></span><br><span class="line">      pubMsg.payloadlen = (<span class="type">int</span>)<span class="built_in">strlen</span>(msg-&gt;payload); <span class="comment">//将消息的长度赋值给发布消息结构体</span></span><br><span class="line">      pubMsg.qos = msg-&gt;qos; <span class="comment">//将消息的服务质量赋值给发布消息结构体</span></span><br><span class="line">      pubMsg.retained = <span class="number">0</span>; <span class="comment">//将消息的保留标志赋值给发布消息结构体</span></span><br><span class="line">      ret = MQTTClient_publishMessage(client, msg-&gt;topic, &amp;pubMsg, &amp;gIoTAppCb.tocken); <span class="comment">//调用MQTT客户端对象的发布消息方法，将消息发送到指定的主题</span></span><br><span class="line">      <span class="keyword">if</span> (ret != MQTTCLIENT_SUCCESS) &#123; <span class="comment">//如果发送失败</span></span><br><span class="line">        IOT_LOG_ERROR(<span class="string">&quot;MSGSEND:failed\r\n&quot;</span>); <span class="comment">//打印错误日志</span></span><br><span class="line">      &#125;</span><br><span class="line">      IOT_LOG_DEBUG(<span class="string">&quot;MSGSEND:SUCCESS\r\n&quot;</span>); <span class="comment">//打印调试日志</span></span><br><span class="line">      gIoTAppCb.tocken++; <span class="comment">//将令牌加一</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> EN_IOT_MSG_RECV: <span class="comment">//如果消息类型是接收消息</span></span><br><span class="line">      <span class="keyword">if</span> (gIoTAppCb.msgCallBack != <span class="literal">NULL</span>) &#123; <span class="comment">//如果应用程序回调信息中有消息回调函数的指针</span></span><br><span class="line">        gIoTAppCb.msgCallBack(msg-&gt;qos, msg-&gt;topic, msg-&gt;payload); <span class="comment">//调用该函数，并将消息的服务质量、主题和有效载荷作为参数传递</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">//如果消息类型是其他值</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &lt;use this function to deal all the comming message</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ProcessQueueMsg</span><span class="params">(MQTTClient client)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">int</span>     ret;</span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">int</span>     msgSize;</span><br><span class="line">    IoTMsg_t  *msg;</span><br><span class="line">    <span class="type">unsigned</span>  <span class="type">int</span>     timeout;</span><br><span class="line">    MQTTClient_message pubmsg = MQTTClient_message_initializer;</span><br><span class="line"></span><br><span class="line">    timeout = CN_QUEUE_WAITTIMEOUT;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        msg = <span class="literal">NULL</span>;</span><br><span class="line">        msgSize = <span class="keyword">sizeof</span>(hi_pvoid);</span><br><span class="line">        ret = osMessageQueueGet(gIoTAppCb.queueID, &amp;msg, &amp;msgSize, timeout);</span><br><span class="line">        <span class="keyword">if</span> (msg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            IOT_LOG_DEBUG(<span class="string">&quot;QUEUEMSG:QOS:%d TOPIC:%s PAYLOAD:%s\r\n&quot;</span>, msg-&gt;qos, msg-&gt;topic, msg-&gt;payload);</span><br><span class="line">            MqttProcessQueueMsg(client, msg, pubmsg);</span><br><span class="line">            hi_free(<span class="number">0</span>, msg);</span><br><span class="line">        &#125;</span><br><span class="line">        timeout = <span class="number">0</span>;  <span class="comment">// &lt; continous to deal the message without wait here</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (ret == IOT_SUCCESS);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h3><p>理论上来说板子会根据云端信息控制灯的亮灭，但实际上云端只能接受信息更新状态，并不能控制板子（会提示发布失败）</p>]]></content>
      
      
      
        <tags>
            
            <tag> Pegasus </tag>
            
            <tag> 物联网开发 </tag>
            
            <tag> 嵌入式开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>camera-imu联合标定</title>
      <link href="/2023/04/23/camera-imu%E8%81%94%E5%90%88%E6%A0%87%E5%AE%9A/"/>
      <url>/2023/04/23/camera-imu%E8%81%94%E5%90%88%E6%A0%87%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="IMU-camera联合标定"><a href="#IMU-camera联合标定" class="headerlink" title="IMU-camera联合标定"></a>IMU-camera联合标定</h1><p><img src="https://res.craft.do/user/full/263e5170-1edd-c6df-5898-f56572924e86/doc/b083fb8b-a3c8-4d57-90b3-31446d0db472/03032585-cda8-45cd-92c6-965fd90503c0" alt="概览.jpg"></p><h1 id="Kalibr"><a href="#Kalibr" class="headerlink" title="Kalibr"></a>Kalibr</h1><h3 id="kalibr官方教程"><a href="#kalibr官方教程" class="headerlink" title="kalibr官方教程"></a>kalibr官方教程</h3><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/ethz-asl/kalibr/wiki/camera-imu-calibration">github.com</a></p></div><h1 id="ROS-Message-filter"><a href="#ROS-Message-filter" class="headerlink" title="ROS :: Message-filter"></a>ROS :: Message-filter</h1><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="http://wiki.ros.org/message_filters">wiki.ros.org</a></p></div><h2 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h2><p>安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-message-filters</span><br></pre></td></tr></table></figure><p>设置环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /opt/ros/noetic/setup.bash</span><br></pre></td></tr></table></figure><p>或者添加到<code>.bashrc</code>中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source /opt/ros/noetic/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><h3 id="喜闻乐见的报错环节🙃"><a href="#喜闻乐见的报错环节🙃" class="headerlink" title="喜闻乐见的报错环节🙃"></a>喜闻乐见的报错环节🙃</h3><blockquote><p>CMake Error at /opt/ros/noetic/share/catkin/cmake/catkinConfig.cmake:83 (find_package): Could not find a package configuration file provided by “message_filter” with any of the following names:    </p><p>​    message_filterConfig.cmake<br>​    message_filter-config.cmake</p><p>Add the installation prefix of “message_filter” to CMAKE_PREFIX_PATH or set “message_filter_DIR” to a directory containing one of the above files. If “message_filter” provides a separate development package or SDK, be sure it has been installed. Call Stack (most recent call first): msg_filter/CMakeLists.txt:10 (find_package)</p></blockquote><p>安装完包之后可以尝试刷新环境</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /opt/ros/noetic/setup.bash</span><br></pre></td></tr></table></figure><p>检查是否正确安装了包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rospack find mseeage_filter</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[rospack] Error: package <span class="string">&#x27;message_filter&#x27;</span> not found</span></span><br><span class="line">rospack find mseeage_filters</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">/opt/ros/noetic/share/message_filters</span></span><br></pre></td></tr></table></figure><p>发现是因为我把<code>filters</code>写成了<code>filter</code> 😆</p><h2 id="example"><a href="#example" class="headerlink" title="example"></a>example</h2><h3 id="msg-filter-subscriber"><a href="#msg-filter-subscriber" class="headerlink" title="msg_filter(subscriber)"></a>msg_filter(subscriber)</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">message_filters::Subscriber&lt;sensor_msgs::Image&gt; <span class="title">image_sub</span><span class="params">(nh, <span class="string">&quot;image&quot;</span>, <span class="number">1</span>)</span>；</span></span><br></pre></td></tr></table></figure><p>从创建订阅实体<code>image_sub</code>，话题为<code>”image”</code>，消息类型为<code>&lt;sensor_msgs::Image&gt;</code></p><h4 id="ApproximateTime-policy"><a href="#ApproximateTime-policy" class="headerlink" title="ApproximateTime policy"></a><strong>ApproximateTime policy</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> sync_policies::ApproximateTime&lt;sensor_msgs::Image, geometry_msgs::WrenchStamped&gt; MySyncPolicy;</span><br></pre></td></tr></table></figure><p>​    这一行是定义了一个同步策略的类型，叫做<code>MySyncPolicy</code>，它使用了<strong>message_filters</strong>中的 <strong>ApproximateTime policy</strong> ，这个策略可以根据时间戳来匹配不同话题的消息，即使它们有不同的时间戳。这个策略需要指定两个参数，分别是要同步的两个话题的消息类型，这里是<code>sensor_msgs::Image</code>和<code>geometry_msgs::WrenchStamped</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Synchronizer&lt;MySyncPolicy&gt; <span class="title">sync</span><span class="params">(MySyncPolicy(<span class="number">10</span>), image_sub, wrench_sub)</span></span>;</span><br></pre></td></tr></table></figure><p>​    这一行是创建了一个<code>Synchronizer</code>对象，它是一个消息过滤器，可以根据指定的同步策略来同步不同话题的消息。这个对象需要三个参数，第一个是同步策略的实例，这里是<code>MySyncPolicy(10)</code>，其中 <strong>10</strong> 表示消息队列大小。第二个和第三个参数是要同步的两个话题的订阅器，这里是<strong>image_sub</strong>和<strong>wrench_sub</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sync.<span class="built_in">registerCallback</span>(boost::<span class="built_in">bind</span>(&amp;callback, _1, _2));</span><br></pre></td></tr></table></figure><p>​    这一行是注册了一个回调函数，当Synchronizer对象同步了两个话题的消息后，就会调用这个回调函数，并把同步后的消息作为参数传递给它1。这里使用了<code>boost::bind</code>来绑定回调函数的地址和占位符，表示当Synchronizer对象有两个参数时，就调用<code>callback</code>函数，并把第一个参数传递给<strong>_1</strong>，第二个参数传递给<strong>_2</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">callback</span><span class="params">(<span class="type">const</span> sensor_msgs::ImageConstPtr&amp; image, <span class="type">const</span> geometry_msgs::WrenchStampedConstPtr&amp; wrench)</span></span></span><br></pre></td></tr></table></figure><p>​    这一行是定义了一个回调函数<code>callback</code>，它有两个参数，分别是<code>sensor_msgs::ImageConstPtr&amp;</code>和<code>geometry_msgs::WrenchStampedConstPtr&amp;</code>。这两个参数的类型都是智能指针（smart pointer），它们可以自动管理内存，避免内存泄漏或无效指针1。智能指针的类型由消息类型加上ConstPtr后缀组成，例如<strong>sensor_msgs::Image</strong>消息对应的智能指针类型是<strong>sensor_msgs::ImageConstPtr</strong>。智能指针的好处是，它们可以在不同的节点间共享同一块内存，提高效率。在回调函数中，我们使用const修饰符和引用符号（&amp;）来表示这些参数是常量引用，也就是说我们不会修改它们的值，也不会拷贝它们的值。</p><p><img src="https://res.craft.do/user/full/263e5170-1edd-c6df-5898-f56572924e86/doc/6c0c5dad-e8aa-49de-8871-24534e9bd383/31383ea8-ce37-4d73-94bc-61c387ee2eff" alt="2023-04-22 10-04-46 的屏幕截图.png"></p><p>可以看到这个策略只能筛选出时间相近的信息，并不能对齐。🤔</p><h4 id="TimeSynchronizer"><a href="#TimeSynchronizer" class="headerlink" title="TimeSynchronizer"></a>TimeSynchronizer</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TimeSynchronizer&lt;sensor_msgs::Image, geometry_msgs::WrenchStamped&gt; <span class="title">sync2</span><span class="params">(image_sub, wrench_sub, <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>这个同步器对时间精度的要求会比较高/</p><h3 id="mypub-publisher"><a href="#mypub-publisher" class="headerlink" title="mypub(publisher)"></a>mypub(publisher)</h3><blockquote><p>生成随机图像数据和力矢量数据<br>安装新的包</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ros-noetic-opencv-apps ros-noetic-cv-bridg</span><br><span class="line">source /opt/ros/noetic/setup.bash</span><br></pre></td></tr></table></figure><h4 id="创建图像"><a href="#创建图像" class="headerlink" title="创建图像"></a>创建图像</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a dummy image with random pixels</span></span><br><span class="line"><span class="function">cv::Mat <span class="title">image</span><span class="params">(<span class="number">480</span>, <span class="number">640</span>, CV_8UC3)</span></span>;</span><br><span class="line">cv::<span class="built_in">randu</span>(image, cv::<span class="built_in">Scalar</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), cv::<span class="built_in">Scalar</span>(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>));</span><br></pre></td></tr></table></figure><p>​    使用OpenCV库创建了一个480x640的三通道无符号字符型矩阵，也就是一个彩色图像。然后使用cv::randu函数给图像的每个像素赋予了一个随机的颜色值，范围是从黑色（0,0,0）到白色（255,255,255）。</p><blockquote><p><strong>cv_8uc3</strong>是一个表示图像类型的枚举值，就是用来选择图像类型，它意味着每个像素由三个无符号字符组成，分别代表蓝色、绿色和红色通道。这样的图像占用了8位的空间，也就是一个字节。</p></blockquote><h4 id="转换为ROS的图像消息"><a href="#转换为ROS的图像消息" class="headerlink" title="转换为ROS的图像消息"></a>转换为ROS的图像消息</h4><p>​    首先创建了一个<code>cv_bridge::CvImage</code>对象，它包含了一个<code>std_msgs::Header</code>对象（用于存储消息的元数据），一个字符串（用于指定图像的编码方式，这里是<strong>bgr8</strong>，表示每个像素由三个无符号字符组成，分别代表蓝色、绿色和红色通道），和一个cv::Mat对象（就是前面创建的图像）。</p><p>​    然后调用了<code>toImageMsg()</code> ，将<code>cv_bridge::CvImage</code>对象转换为<code>sensor_msgs::ImagePtr</code>对象，也就是一个指向<code>sensor_msgs::Image</code>消息的智能指针。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// convert the image to a sensor_msgs::Image message</span></span><br><span class="line">sensor_msgs::ImagePtr msg = cv_bridge::<span class="built_in">CvImage</span>(std_msgs::<span class="built_in">Header</span>(), <span class="string">&quot;bgr8&quot;</span>, image).<span class="built_in">toImageMsg</span>();</span><br></pre></td></tr></table></figure><p>在发布的时候发布指针或者直接发送对象都可以，不过指针会快一点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pub.<span class="built_in">publish</span>(msg); <span class="comment">// 发布指针</span></span><br><span class="line">pub.<span class="built_in">publish</span>(*msg); <span class="comment">// 发布指针指向的对象</span></span><br></pre></td></tr></table></figure><h4 id="添加时间戳信息"><a href="#添加时间戳信息" class="headerlink" title="添加时间戳信息"></a>添加时间戳信息</h4><p>这个其实就是这份代码最主要的部分了，虽然简单，但是我一开始确实漏了。🤫</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msg-&gt;header.stamp = ros::Time::<span class="built_in">now</span>();</span><br></pre></td></tr></table></figure><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>如果消息缺少时间戳信息的话是不会触发回调函数的。</p></div><h1 id="Recoder"><a href="#Recoder" class="headerlink" title="Recoder"></a>Recoder</h1><h3 id="Cv-bridge保存-image"><a href="#Cv-bridge保存-image" class="headerlink" title="Cv-bridge保存/image"></a>Cv-bridge保存/image</h3><p>保存<strong>sensor_msgs::Image</strong>为<strong>PNG</strong>，并且以时间戳命名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">cv_bridge::CvImagePtr cv_ptr;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        cv_ptr = cv_bridge::<span class="built_in">toCvCopy</span>(msg, <span class="string">&quot;bgr8&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (cv_bridge::Exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;cv_bridge exception: %s&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​    使用cv_bridge::toCvCopy函数，将ROS的图像消息msg转换为OpenCV的图像，并赋值给cv_ptr。如果转换过程中发生异常，就会抛出cv_bridge::Exception类型的错误，并使用ROS_ERROR宏打印错误信息，并返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Get the timestamp of the image message</span></span><br><span class="line">std::stringstream ss;</span><br><span class="line">ss &lt;&lt; msg-&gt;header.stamp;</span><br><span class="line">std::string timestamp = ss.<span class="built_in">str</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Construct the filename with timestamp</span></span><br><span class="line"><span class="type">char</span> filename[<span class="number">256</span>];</span><br><span class="line"><span class="built_in">sprintf</span>(filename, filename_format.<span class="built_in">c_str</span>(), timestamp.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// Save the image as a png file</span></span><br><span class="line">cv::<span class="built_in">imwrite</span>(save_path + filename, cv_ptr-&gt;image);</span><br></pre></td></tr></table></figure><p>​    将<code>msg</code>的时间戳<code>msg-&gt;header.stamp</code>转换为字符串，并赋值给<code>timestamp</code>变量。具体有关 <strong>stringstream</strong> 的内容可以参考文章后面的补充。</p><p>​    使用<code>cv::imwrite</code>函数，将OpenCV图像<code>cv_ptr-&gt;image</code>保存为<strong>png</strong>格式的文件。这个函数需要两个参数，第一个是要保存的文件路径和文件名，这里使用了save_path和filename拼接而成的字符串，<code>save_path</code>是一个预定义的变量，表示文件保存的路径，例如<code>&quot;/home/user/images/&quot;</code>。第二个参数是要保存的OpenCV图像。</p><h3 id="message-filter-cache"><a href="#message-filter-cache" class="headerlink" title="message_filter::cache"></a>message_filter::cache</h3><p>环形缓存器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//set up subscriber &amp; cache</span></span><br><span class="line"><span class="function">message_filters::Subscriber&lt;sensor_msgs::Image&gt; <span class="title">sub</span><span class="params">(nh, image_topic, <span class="number">1</span>)</span></span>;</span><br><span class="line">sub.<span class="built_in">registerCallback</span>(boost::<span class="built_in">bind</span>(&amp;image_callback, _1));</span><br><span class="line">cache.<span class="built_in">connectInput</span>(sub);<span class="comment">//输入</span></span><br><span class="line">cache.<span class="built_in">setCacheSize</span>(cache_size);<span class="comment">//大小</span></span><br></pre></td></tr></table></figure><h3 id="保存-imu-amp-wrench"><a href="#保存-imu-amp-wrench" class="headerlink" title="保存/imu &amp; /wrench"></a>保存/imu &amp; /wrench</h3><p>一般选择保存为csv文件。</p><ul><li>使用<strong>rostopic echo -p</strong>命令，将订阅到的话题数据以<strong>csv</strong>格式输出到文件，例如：<code>rostopic echo -p /imu/data &gt; imu_data.csv</code></li><li>使用rosbag record命令，将订阅到的话题数据保存为rosbag文件，然后使用rosbag_to_csv包或者自己编写的脚本，将rosbag文件中的数据转换为csv文件。</li><li>使用自己编写的节点，订阅到话题数据后，使用标准库或者第三方库（如pandas）来创建和保存csv文件。</li></ul><p>前两种方法可能简单一些，但是显然即时性不太好，所以还是选择第三种好了。😋</p><h4 id="csv-parser第三方库"><a href="#csv-parser第三方库" class="headerlink" title="csv-parser第三方库"></a>csv-parser第三方库</h4><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/vincentlaucsb/csv-parser">GitHub - vincentlaucsb/csv-parser: A modern C++ library for reading, writing, and analyzing CSV (and similar) files.</a></p></div><p>我是在功能包目录下克隆仓库</p><p>在<strong>CmakeLists.txt中添加</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">add_subdirectory</span>(csv-parser)</span><br><span class="line"></span><br><span class="line"><span class="built_in">add_executable</span>(&lt;your program&gt; ...)</span><br><span class="line"><span class="built_in">target_link_libraries</span>(&lt;your program&gt; csv)</span><br></pre></td></tr></table></figure><p>编译后在节点文件里面引用，我不能直接引用，要加上相对路径</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;../csv-parser/single_include/csv.hpp&quot;</span></span></span><br></pre></td></tr></table></figure><p>我的文件目录</p><blockquote><p>msg_filter(功能包)</p><blockquote><p>include</p><p>src</p><blockquote><p>writeCSV_demo.cpp</p></blockquote><p>csv-parse</p><blockquote><p>single_include</p><blockquote><p>csv.hpp</p></blockquote></blockquote></blockquote></blockquote><h4 id="code-example"><a href="#code-example" class="headerlink" title="code_example"></a>code_example</h4><p>​    定义一个<code>CSVWriter</code>对象的指针，使用<code>std::ofstream</code>作为输出流类型</p><p>​    <code>csv::CSVWriter</code>是一个<strong>模板类</strong>，它需要一个模板参数，来指定输出流的类型。需要在声明CSVWriter对象的时候，提供一个模板参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CSVWriter&lt;std::ofstream&gt;* writer;</span><br><span class="line">writer = <span class="keyword">new</span> <span class="built_in">CSVWriter</span>&lt;std::ofstream&gt;(<span class="string">&quot;/home/stonewu/Data/test.csv&quot;</span>);</span><br></pre></td></tr></table></figure><p>或者可以使用<code>auto</code>关键字，让编译器自动推断模板参数的类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> writer = <span class="keyword">new</span> <span class="built_in">CSVWriter</span>(<span class="string">&quot;/home/stonewu/Data/test.csv&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>写入数据</strong></p><p>需要注意的是<code>writer</code>是一个<strong>指针</strong>，需要先解引用指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> header = std::vector&lt;std::string&gt;&#123;<span class="string">&quot;topic&quot;</span>, <span class="string">&quot;time&quot;</span>, <span class="string">&quot;fx&quot;</span>, <span class="string">&quot;fy&quot;</span>, <span class="string">&quot;fz&quot;</span>, <span class="string">&quot;tx&quot;</span>,<span class="string">&quot;ty&quot;</span>,<span class="string">&quot;tz&quot;</span>,<span class="string">&quot;\n&quot;</span>&#125;;</span><br><span class="line">*writer &lt;&lt; header;</span><br></pre></td></tr></table></figure><p>这个是将订阅到的数据写入CSV文件中。虽然只有短短几行代码，却花了不少时间。</p><p>​    实际上要注意的就是这个库传给writer的数据必须是<code>std::vector&lt;std::string&gt;</code>，所以要将这些数据转换为字符串形式，这里使用了<code>ostringstream oss</code>来存储。但是也不能直接通过ostringstream来构造一个<strong>vector<string></strong>，所以又构造了一个<code>istringstream</code>来作为中介。</p><p>​    也不能通过<code>&lt;&lt;endl</code>来输入换行，这里直接用<code>“\n”</code>即可。    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrench_callback</span><span class="params">(<span class="type">const</span> geometry_msgs::WrenchStampedConstPtr&amp; msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将消息中的数据写入到CSV文件中</span></span><br><span class="line">    ostringstream oss;</span><br><span class="line">    oss &lt;&lt; msg-&gt;header.stamp &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; msg-&gt;wrench.force.x &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">        &lt;&lt; msg-&gt;wrench.force.y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; msg-&gt;wrench.force.z &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">        &lt;&lt; msg-&gt;wrench.torque.x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; msg-&gt;wrench.torque.y &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">        &lt;&lt; msg-&gt;wrench.torque.z&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="comment">// 创建一个vector&lt;string&gt;对象</span></span><br><span class="line">    vector&lt;string&gt; data;</span><br><span class="line">    <span class="comment">// 创建一个istringstream对象，用来读取oss中的字符串</span></span><br><span class="line">    <span class="function">istringstream <span class="title">iss</span><span class="params">(oss.str())</span></span>;</span><br><span class="line">    <span class="comment">// 创建一个string对象，用来存储每个子字符串</span></span><br><span class="line">    string word;</span><br><span class="line">    <span class="comment">// 使用空格作为分隔符，循环读取每个子字符串</span></span><br><span class="line">    <span class="keyword">while</span> (iss &gt;&gt; word) &#123;</span><br><span class="line">      <span class="comment">// 将子字符串放入向量中</span></span><br><span class="line">      data.<span class="built_in">push_back</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line">    *writer &lt;&lt; data ;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rosbag工具"><a href="#rosbag工具" class="headerlink" title="rosbag工具"></a>rosbag工具</h4><p>使用rosbag工具录制topic数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag record -O output.bag /imu /wrench</span><br></pre></td></tr></table></figure><p>这样可以将<strong>/imu</strong>和<strong>/wrench</strong>主题的数据保存到<strong>output.bag</strong>文件中。</p><p>回放数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosbag play output.bag</span><br></pre></td></tr></table></figure><p>使用<strong>rostopic</strong>完成数据转存：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rostopic echo -b output.bag -p /imu &gt; imu.csv</span><br><span class="line">rostopic echo -b output.bag -p /wrench &gt; wrench.csv</span><br></pre></td></tr></table></figure><p>这样就可以将/<strong>imu</strong>和/<strong>wrench</strong>主题的数据保存到<strong>imu.csv</strong>和<strong>wrench.csv</strong>文件中，它们是以逗号分隔的文本格式。</p><h3 id="Keyboard-Input"><a href="#Keyboard-Input" class="headerlink" title="Keyboard Input"></a>Keyboard Input</h3><h4 id="原来的keyboard扫描函数"><a href="#原来的keyboard扫描函数" class="headerlink" title="原来的keyboard扫描函数"></a>原来的keyboard扫描函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">scanKeyboard</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> in;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">termios</span> new_settings;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">termios</span> stored_settings;</span><br><span class="line">    <span class="comment">//设置终端参数</span></span><br><span class="line"><span class="built_in">tcgetattr</span>(<span class="number">0</span>,&amp;stored_settings);</span><br><span class="line">new_settings = stored_settings;</span><br><span class="line">new_settings.c_lflag &amp;= (~ICANON);</span><br><span class="line">new_settings.c_cc[VTIME] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">tcgetattr</span>(<span class="number">0</span>,&amp;stored_settings);</span><br><span class="line">new_settings.c_cc[VMIN] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">tcsetattr</span>(<span class="number">0</span>,TCSANOW,&amp;new_settings);</span><br><span class="line">in = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="built_in">tcsetattr</span>(<span class="number">0</span>,TCSANOW,&amp;stored_settings);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> in;<span class="comment">//返回的是字符对应的ascii码</span></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这个函数会一直等待输入，直到有键盘按键被按下。它使用了<code>tcsetattr</code>函数来修改终端的属性，将其设置为非规范模式（non-canonical mode），这意味着输入不会被缓冲，而是立即被读取。同时，它将VMIN属性设置为1，表示至少需要一个字符才能返回。因此，这个函数会阻塞其他函数的进行，除非有键盘输入。</p><h4 id="重新设置终端参数"><a href="#重新设置终端参数" class="headerlink" title="重新设置终端参数"></a>重新设置终端参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">new_settings.c_lflag &amp;= ~(ICANON | ECHO); </span><br><span class="line"><span class="comment">//当关闭规范模式时，输入不会被缓冲，而是立即被读取</span></span><br><span class="line"><span class="comment">//如果开启规范模式，输入会被缓冲，直到遇到换行符或文件结束符才会被读取（真的吗）</span></span><br><span class="line">new_settings.c_cc[VTIME] = <span class="number">0</span>; <span class="comment">//设置超时时间为0，即不等待输入</span></span><br><span class="line">new_settings.c_cc[VMIN] = <span class="number">0</span>; <span class="comment">//设置最小字符数为0，即不需要输入任何字符就可以读取</span></span><br></pre></td></tr></table></figure><p><strong>指令集</strong></p><blockquote><ul><li>q: save latest data</li><li>w: save all data</li><li>b: begin to save data</li><li>stop saving data</li></ul></blockquote><h1 id="serial"><a href="#serial" class="headerlink" title="serial"></a>serial</h1><p>串口及比较简单了，直接对照下位机的协议写即可</p><h2 id="下位机协议"><a href="#下位机协议" class="headerlink" title="下位机协议"></a>下位机协议</h2><h1 id="c-与ros库-补充"><a href="#c-与ros库-补充" class="headerlink" title="c++与ros库 补充"></a>c++与ros库 补充</h1><h3 id="boost-bind"><a href="#boost-bind" class="headerlink" title="boost::bind"></a>boost::bind</h3><p>假设我们有一个函数<strong>f</strong>，它接受三个整数参数，并返回它们的和：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>boost::bind</code>来创建一个新的函数对象，它只接受一个整数参数，并把它作为f的第二个参数，而把第一和第三个参数固定为1和2。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boost::function&lt;<span class="type">int</span> (<span class="type">int</span>)&gt; g = boost::<span class="built_in">bind</span>(f, <span class="number">1</span>, _1, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>这里，_1是一个占位符，表示g的第一个参数。我们可以这样调用g：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">g</span>(<span class="number">3</span>); <span class="comment">// x = f(1, 3, 2) = 6</span></span><br><span class="line"><span class="type">int</span> y = <span class="built_in">g</span>(<span class="number">4</span>); <span class="comment">// y = f(1, 4, 2) = 7</span></span><br></pre></td></tr></table></figure><p>我们也可以使用<code>boost::bind</code>来绑定类的成员函数。假设我们有一个类<code>myclass</code>，它有一个成员函数<strong>fun</strong>，它接受一个整数参数，并打印它：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myclass</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>boost::bind</code>来创建一个函数对象，它接受一个<code>myclass</code>的对象和一个整数参数，并调用该对象的<code>fun</code>方法。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boost::function&lt;<span class="type">void</span> (myclass&amp;, <span class="type">int</span>)&gt; h = boost::<span class="built_in">bind</span>(&amp;myclass::fun, _1, _2);</span><br></pre></td></tr></table></figure><p>这里，<strong>_1</strong>和<strong>_2</strong>分别表示h的第一和第二个参数。我们可以这样调用h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myclass mc;</span><br><span class="line"><span class="built_in">h</span>(mc, <span class="number">5</span>); <span class="comment">// mc.fun(5)</span></span><br><span class="line"><span class="built_in">h</span>(mc, <span class="number">6</span>); <span class="comment">// mc.fun(6)</span></span><br></pre></td></tr></table></figure><p>Q: 定义的h有三个参数，但是我们只给他两个参数也是可以的对吗?</p><p>A: 定义的h只有两个参数，因为我们使用了boost::bind来绑定myclass的成员函数fun，它本身就是一个参数。所以h的第一个参数是一个myclass的对象，第二个参数是一个整数。我们给h两个参数就可以了，不需要再给fun传递参数。</p><h3 id="sensor-msgs-Image"><a href="#sensor-msgs-Image" class="headerlink" title="sensor_msgs::Image"></a>sensor_msgs::Image</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 这个消息包含了一个未压缩的图像</span><br><span class="line"># (<span class="number">0</span>, <span class="number">0</span>) 是图像的左上角</span><br><span class="line">#</span><br><span class="line"># Header header        # Header timestamp 应该是图像获取的时间</span><br><span class="line">#                      # Header frame_id 应该是相机的光学帧</span><br><span class="line">#                      # 帧的原点应该是相机的光学中心</span><br><span class="line">#                      # +x 指向图像的右边</span><br><span class="line">#                      # +y 指向图像的下边</span><br><span class="line">#                      # +z 指向图像的平面</span><br><span class="line">#                      # 如果这里的 frame_id 和与图像相关联的 CameraInfo 消息的 frame_id 冲突</span><br><span class="line">#                      # 行为是未定义的</span><br><span class="line">uint32 height         # 图像高度，也就是行数</span><br><span class="line">uint32 width          # 图像宽度，也就是列数</span><br><span class="line"># 合法的编码值在文件 src/image_encodings.cpp 中</span><br><span class="line"># 如果你想标准化一个新的字符串格式，加入</span><br><span class="line"><span class="meta"># ros-users@lists.sourceforge.net 并发送一封邮件提出一个新的编码。</span></span><br><span class="line">string encoding       # 像素的编码 -- 通道的含义，顺序，大小</span><br><span class="line">                      # 从 include/sensor_msgs/image_encodings.h 中的字符串列表中取得</span><br><span class="line">uint8 is_bigendian    # 这个数据是否为大端序</span><br><span class="line">uint32 step           # 每行的字节数</span><br><span class="line">uint8[] data          # 实际的矩阵数据，大小是 (step * rows)</span><br></pre></td></tr></table></figure><h3 id="外部参数获取"><a href="#外部参数获取" class="headerlink" title="外部参数获取"></a>外部参数获取</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string image_topic;</span><br><span class="line"><span class="function">ros::NodeHandle <span class="title">pnh</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line">pnh.<span class="built_in">param</span>&lt;std::string&gt;(<span class="string">&quot;image_topic&quot;</span>, image_topic, <span class="string">&quot;/camera/image_raw&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>param</strong>方法有三个参数</p><ul><li>参数的名字</li><li>参数的值</li><li>参数的默认值</li></ul><p>param方法会尝试从参数服务器或者命令行参数中获取指定名字的参数，如果成功，就将其赋值给第二个参数，如果失败，就使用第三个参数作为默认值。</p><p><strong>rosparam工具</strong></p><p>将image_topic参数的值设置为/camera/image</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam set image_topic /camera/image</span><br></pre></td></tr></table></figure><p>使用rosparam get命令来获取参数的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosparam get image_topic</span><br></pre></td></tr></table></figure><p>运行ROS节点的时候，通过命令行参数来设置参数的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun image_saver_node image_saver_node _image_topic:=/camera/image</span><br></pre></td></tr></table></figure><blockquote><p>注意，私有参数的名字前面要加一个下划线 <strong>_</strong></p></blockquote><h3 id="node命名空间"><a href="#node命名空间" class="headerlink" title="node命名空间"></a>node命名空间</h3><p>话题<code>/camera/image</code>中的<strong>camera</strong>和<strong>image</strong>分别是什么意思呢</p><p><a href="http://wiki.ros.org/ROS/Patterns/Conventions">话题/camera/image中的camera和image分别是话题的命名空间和基本名。话题的命名空间是用来组织和区分不同的话题的，它可以有多个层级，用斜杠/分隔。话题的基本名是用来描述话题的内容或者功能的，它不能包含斜杠/或者波浪线~。话题的命名空间和基本名都应该遵循一些命名规范1</a>，例如：</p><ul><li>话题的命名空间和基本名都应该使用小写字母，下划线_和数字。</li><li>话题的基本名应该尽量具有描述性，例如laser_scan而不是scan。</li><li>话题的命名空间应该尽量避免使用全局或者私有的前缀，例如/ros或者~。</li></ul><p>在这个例子中，camera是一个命名空间，表示这个话题是关于相机的。image是一个基本名，表示这个话题传输的是图像数据。你可以使用rosnode list命令来查看当前系统中所有的话题列表。</p><p>那么我在订阅的时候这两周写法效果是一样的吗</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ros::Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;image&quot;</span>, <span class="number">1</span>, imageCallback);</span><br><span class="line"></span><br><span class="line">ros::Subscriber sub = nh.<span class="built_in">subscribe</span>(<span class="string">&quot;/camera/image&quot;</span>, <span class="number">1</span>, imageCallback);</span><br></pre></td></tr></table></figure><p>不一定。这两种写法的效果取决于你的节点的命名空间。如果你的节点的命名空间是/，也就是全局命名空间，那么这两种写法的效果是一样的，都会订阅到/camera/image这个话题。但是如果你的节点的命名空间不是/，例如/wg，那么这两种写法的效果就不一样了。第一种写法会订阅到/wg/image这个话题，而第二种写法仍然会订阅到/camera/image这个话题。这是因为第一种写法使用了相对名称，而第二种写法使用了全局名称。相对名称会根据节点的命名空间进行解析，而全局名称不会。</p><p>请告诉我如何获取或者修改我的节点的命名空间。</p><p><a href="http://wiki.ros.org/Names">你可以使用rosnode命令来获取或者修改你的节点的命名空间。rosnode命令是一个用于显示和管理节点信息的命令行工具1</a>。你可以使用rosnode info命令来获取节点的详细信息，包括节点的命名空间，例如：</p><p>rosnode info /wg/node1</p><p>这样就会打印出/wg/node1节点的信息，其中第一行就是节点的命名空间，例如：</p><p>Node [/wg/node1] Publications:</p><ul><li>/wg/image [sensor_msgs/Image]</li><li>/rosout [rosgraph_msgs/Log]</li></ul><p>Subscriptions:</p><ul><li>/camera/image [sensor_msgs/Image]</li></ul><p>Services:</p><ul><li>/wg/node1/get_loggers</li><li>/wg/node1/set_logger_level</li></ul><p>你也可以在运行节点的时候，使用__ns参数来修改节点的命名空间，例如：</p><p>rosrun image_saver_node image_saver_node __ns:=/camera</p><p><a href="http://wiki.ros.org/Nodes">这样就会将image_saver_node节点的命名空间设置为/camera。你也可以在launch文件中使用ns属性来设置节点的命名空间2</a>，例如：</p><p>这样也会将image_saver_node节点的命名空间设置为/camera。</p><p>那么在默认情况下的节点都是在全局命名空间对吗，我是否能在代码的程序里面修改呢</p><p>不一定。在默认情况下，节点的命名空间是由ros::init函数的第二个参数决定的。这个参数是一个ros::NodeHandle类型的引用，它可以指定节点的命名空间和名称。如果你不提供这个参数，或者提供一个空的ros::NodeHandle，那么节点的命名空间就是/，也就是全局命名空间。但是如果你提供了一个非空的ros::NodeHandle，那么节点的命名空间就是由这个ros::NodeHandle指定的。例如：</p><p>ros::init(argc, argv, “image_saver_node”);</p><p>这样就会将节点的名称设置为image_saver_node，而节点的命名空间设置为/。</p><p>ros::NodeHandle nh(“/camera”); ros::init(argc, argv, “image_saver_node”, nh);</p><p>这样就会将节点的名称设置为image_saver_node，而节点的命名空间设置为/camera。</p><h3 id="std-stringstream"><a href="#std-stringstream" class="headerlink" title="std::stringstream"></a>std::stringstream</h3><blockquote><p>stringstream是一个C++中的类，它可以用来操作字符串。stringstream可以将字符串转换为其他类型，例如数值，也可以将其他类型转换为字符串。stringstream还可以对字符串进行格式化，例如添加空格或者0填充。stringstream的用法类似于输入输出流，可以使用&lt;&lt;和&gt;&gt;运算符来向其中插入或者提取数据。stringstream的内部有一个字符串缓冲区，可以使用str()方法来获取或者设置。</p></blockquote><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个stringstream对象</span></span><br><span class="line">std::stringstream ss;  </span><br><span class="line"><span class="comment">// 向其中插入字符串和数值 </span></span><br><span class="line">ss &lt;&lt; “Hello” &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">2021</span>; </span><br><span class="line"><span class="comment">// 输出缓冲区的内容，结果是Hello 2021 int n; </span></span><br><span class="line">std::cout &lt;&lt; ss.<span class="built_in">str</span>() &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>从缓冲区提取数值的时候，<strong>stringstream</strong> 会按照空格或者换行符来分隔数据，然后尝试将第一个分隔的数据转换为目标类型。如果转换成功，就返回这个数值，如果转换失败，就返回 <strong>0</strong>，并且设置错误状态标志。提取之后，ss内的缓冲区内容不会改变，::但是会有一个内部指针指向下一个要提取的数据的位置::。你可以使用<code>tellg()</code>方法来获取这个指针的位置，也可以使用<code>seekg()</code>方法来移动这个指针。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个stringstream对象 </span></span><br><span class="line">std::stringstream ss;</span><br><span class="line"><span class="comment">// 向其中插入字符串和数值 </span></span><br><span class="line">ss &lt;&lt; “Hello” &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">2021</span>; </span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line"><span class="comment">// 从缓冲区中提取一个数值 </span></span><br><span class="line">ss &gt;&gt; n; </span><br><span class="line"><span class="comment">// 输出提取的数值，结果是0，因为Hello不能转换为int</span></span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl;  </span><br><span class="line"><span class="comment">// 输出内部指针的位置，结果是5，表示下一个要提取的数据是空格 </span></span><br><span class="line">std::cout &lt;&lt; ss.<span class="built_in">tellg</span>() &lt;&lt; std::endl; </span><br><span class="line"><span class="comment">// 移动内部指针到位置6，表示下一个要提取的数据是2021 </span></span><br><span class="line">ss.<span class="built_in">seekg</span>(<span class="number">6</span>); </span><br><span class="line"><span class="comment">// 从缓冲区中提取一个数值 </span></span><br><span class="line">ss &gt;&gt; n; </span><br><span class="line"><span class="comment">// 输出提取的数值，结果是2021</span></span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><p>提取的时候，<code>::stringstream</code>会<strong>自动跳过</strong>空格或者换行符，直到遇到非空白字符为止。提取的顺序是<strong>从左往右</strong>的，也就是从缓冲区的开头到结尾的顺序。</p><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个stringstream对象</span></span><br><span class="line">std::stringstream ss;  </span><br><span class="line"><span class="comment">// 向其中插入一些数值，中间用空格分隔</span></span><br><span class="line">ss &lt;&lt; “<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span>”;  </span><br><span class="line"><span class="comment">// 从缓冲区中提取一个数值输出，结果是1 </span></span><br><span class="line"><span class="type">int</span> n; </span><br><span class="line">ss &gt;&gt; n;  </span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl; </span><br><span class="line"><span class="comment">// 从缓冲区中提取一个数值，输出,结果是2</span></span><br><span class="line">ss &gt;&gt; n;</span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl; </span><br><span class="line"><span class="comment">// 从缓冲区中提取一个数值，输出,结果是3</span></span><br><span class="line">ss &gt;&gt; n; </span><br><span class="line">std::cout &lt;&lt; n &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><h4 id="ostringstream-amp-istringstream"><a href="#ostringstream-amp-istringstream" class="headerlink" title="ostringstream &amp; istringstream"></a>ostringstream &amp; istringstream</h4><p>从前缀可以看出来，一个用作输出，一个只用作输入。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> 滤波器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高压线巡检机器人</title>
      <link href="/2023/04/17/%E9%AB%98%E5%8E%8B%E7%BA%BF%E5%B7%A1%E6%A3%80%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2023/04/17/%E9%AB%98%E5%8E%8B%E7%BA%BF%E5%B7%A1%E6%A3%80%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="设计说明书——高压线巡检机器人"><a href="#设计说明书——高压线巡检机器人" class="headerlink" title="设计说明书——高压线巡检机器人"></a>设计说明书——高压线巡检机器人</h1><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="一、选题的背景和要求"><a href="#一、选题的背景和要求" class="headerlink" title="一、选题的背景和要求"></a>一、选题的背景和要求</h2><h3 id="1-1-研究背景和意义"><a href="#1-1-研究背景和意义" class="headerlink" title="1.1 研究背景和意义"></a>1.1 研究背景和意义</h3><h3 id="1-2-巡检线路环境"><a href="#1-2-巡检线路环境" class="headerlink" title="1.2 巡检线路环境"></a>1.2 巡检线路环境</h3><h3 id="1-3-机构设计的具体要求"><a href="#1-3-机构设计的具体要求" class="headerlink" title="1.3 机构设计的具体要求"></a>1.3 机构设计的具体要求</h3><h2 id="二、整体方案的拟定及说明"><a href="#二、整体方案的拟定及说明" class="headerlink" title="二、整体方案的拟定及说明"></a>二、整体方案的拟定及说明</h2><h3 id="2-1-整体机构组成"><a href="#2-1-整体机构组成" class="headerlink" title="2.1 整体机构组成"></a>2.1 整体机构组成</h3><h3 id="2-2-整体方案分析"><a href="#2-2-整体方案分析" class="headerlink" title="2.2 整体方案分析"></a>2.2 整体方案分析</h3><h3 id="2-3-人员分工"><a href="#2-3-人员分工" class="headerlink" title="2.3 人员分工"></a>2.3 人员分工</h3><h2 id="三、行走机构综合设计"><a href="#三、行走机构综合设计" class="headerlink" title="三、行走机构综合设计"></a>三、行走机构综合设计</h2><h2 id="3-0-总体设计方案"><a href="#3-0-总体设计方案" class="headerlink" title="3.0 总体设计方案"></a>3.0 总体设计方案</h2><h2 id="3-1-运动结构设计方案"><a href="#3-1-运动结构设计方案" class="headerlink" title="3.1 运动结构设计方案"></a>3.1 运动结构设计方案</h2><h3 id="3-1-1-连杆机构"><a href="#3-1-1-连杆机构" class="headerlink" title="3.1.1 连杆机构"></a>3.1.1 连杆机构</h3><h3 id="3-1-2-高度补偿机构"><a href="#3-1-2-高度补偿机构" class="headerlink" title="3.1.2 高度补偿机构"></a>3.1.2 高度补偿机构</h3><h3 id="3-1-3-动力装置"><a href="#3-1-3-动力装置" class="headerlink" title="3.1.3 动力装置"></a>3.1.3 动力装置</h3><h3 id="3-1-4-整体运动流程"><a href="#3-1-4-整体运动流程" class="headerlink" title="3.1.4 整体运动流程"></a>3.1.4 整体运动流程</h3><h2 id="3-2-尺寸综合与应力分析"><a href="#3-2-尺寸综合与应力分析" class="headerlink" title="3.2 尺寸综合与应力分析"></a>3.2 尺寸综合与应力分析</h2><h3 id="3-2-1-机体尺寸与越障尺寸"><a href="#3-2-1-机体尺寸与越障尺寸" class="headerlink" title="3.2.1 机体尺寸与越障尺寸"></a>3.2.1 机体尺寸与越障尺寸</h3><h3 id="3-2-2-连杆机构应力优化"><a href="#3-2-2-连杆机构应力优化" class="headerlink" title="3.2.2 连杆机构应力优化"></a>3.2.2 连杆机构应力优化</h3><h2 id="3-3-动力分析与选型"><a href="#3-3-动力分析与选型" class="headerlink" title="3.3 动力分析与选型"></a>3.3 动力分析与选型</h2><h2 id="四、平衡机构具体设计方案"><a href="#四、平衡机构具体设计方案" class="headerlink" title="四、平衡机构具体设计方案"></a>四、平衡机构具体设计方案</h2><h3 id="4-1平衡机构设计要求及方案"><a href="#4-1平衡机构设计要求及方案" class="headerlink" title="4.1平衡机构设计要求及方案"></a>4.1平衡机构设计要求及方案</h3><h3 id="4-2齿轮齿条传动"><a href="#4-2齿轮齿条传动" class="headerlink" title="4.2齿轮齿条传动"></a>4.2齿轮齿条传动</h3><h3 id="4-3-齿轮齿条传动平衡机构与行走机构配合"><a href="#4-3-齿轮齿条传动平衡机构与行走机构配合" class="headerlink" title="4.3 齿轮齿条传动平衡机构与行走机构配合"></a>4.3 齿轮齿条传动平衡机构与行走机构配合</h3><h2 id="五、夹爪机构具体设计方案"><a href="#五、夹爪机构具体设计方案" class="headerlink" title="五、夹爪机构具体设计方案"></a>五、夹爪机构具体设计方案</h2><h3 id="5-1总体设计方案"><a href="#5-1总体设计方案" class="headerlink" title="5.1总体设计方案"></a>5.1总体设计方案</h3><h3 id="5-2夹爪机构爆炸图"><a href="#5-2夹爪机构爆炸图" class="headerlink" title="5.2夹爪机构爆炸图"></a>5.2夹爪机构爆炸图</h3><h3 id="5-3夹爪机构应力分析"><a href="#5-3夹爪机构应力分析" class="headerlink" title="5.3夹爪机构应力分析"></a>5.3夹爪机构应力分析</h3><h2 id="六、脱线控制机构具体设计方案"><a href="#六、脱线控制机构具体设计方案" class="headerlink" title="六、脱线控制机构具体设计方案"></a>六、脱线控制机构具体设计方案</h2><h3 id="6-1、总体设计方案"><a href="#6-1、总体设计方案" class="headerlink" title="6.1、总体设计方案"></a>6.1、总体设计方案</h3><h3 id="6-2、凸轮齿轮齿条机构"><a href="#6-2、凸轮齿轮齿条机构" class="headerlink" title="6.2、凸轮齿轮齿条机构"></a>6.2、凸轮齿轮齿条机构</h3><h3 id="6-3、不完全齿轮齿条机构"><a href="#6-3、不完全齿轮齿条机构" class="headerlink" title="6.3、不完全齿轮齿条机构"></a>6.3、不完全齿轮齿条机构</h3><h3 id="6-4、齿轮系机构"><a href="#6-4、齿轮系机构" class="headerlink" title="6.4、齿轮系机构"></a>6.4、齿轮系机构</h3><h3 id="6-5、总结"><a href="#6-5、总结" class="headerlink" title="6.5、总结"></a>6.5、总结</h3><h2 id="七、收获与感想"><a href="#七、收获与感想" class="headerlink" title="七、收获与感想"></a>七、收获与感想</h2><hr><h1 id="一、选题的背景和要求-1"><a href="#一、选题的背景和要求-1" class="headerlink" title="一、选题的背景和要求"></a>一、选题的背景和要求</h1><h2 id="1-1-研究背景和意义-1"><a href="#1-1-研究背景和意义-1" class="headerlink" title="1.1 研究背景和意义"></a>1.1 研究背景和意义</h2><p>电力传输过程中不可或缺的设备之一就是高压线路，其影响了电力传输系统的可靠性和安全性。传输系统中的杆塔或者电线由于长期暴露在野外或者受到环境和机械的作用会产生多种形式的故障和安全隐患,如: 导线机械破损、连接金具松脱及线路电气故障等，如不及时发现排除，最终可能将导致重大停电事故或人身安全事故，带来极大的社会影响和经济损失。</p><p>所以输电线路的巡检作业是高压线维护中最重要的作业之一，通过对输电线路周围环境和线路运行环境的检查，及时发现并消除隐患，实现对事故的提前预防，保证供电安全万无一失。然而当前阶段，我国多采取操作人员借助绝缘斗臂车带电作业方式，需要多名操作人员在高空和地面，在高压、强电磁场等极端危险环境下进行接线、解线、并线等手工操作，劳动强度大，精神高度紧张。这种带电作业方式不仅培训难度大，给操作人员带来人身危险，而且作业效率低下。</p><p>因此，我们想设计一款高压线巡检机器人，可沿输电线路行走的同时还需要能跨越障碍物，可以使用便携式仪器设备近距离检查，既能完成巡检，又能完成线路的简单维护。</p><h2 id="1-2-巡检线路环境-1"><a href="#1-2-巡检线路环境-1" class="headerlink" title="1.2 巡检线路环境"></a>1.2 巡检线路环境</h2><p>在我国的架空输电线路中 110kv 以上的超高压线路是主要的输电线路，其覆盖面广，一般的通过高度为 12-30 米，两耐张塔间隔为 200-600 米，线缆直径为。</p><p>高压输电线路的主要元器件导线、耐张塔以及包括绝缘子串、联结金具、保护金具等在内的线路上附属设备，这些元器件组合在一起，构成特殊的线路环境。</p><ul><li><p>典型障碍物</p><ul><li><p>防震锤：</p><p>防震锤常挂在靠近绝缘子两侧的线路上，来平衡因外力引起的振动，减轻对线路的损伤</p></li><li><p>悬垂线夹：</p><p>将导线固定在直线杆塔的绝缘子串上，或将避雷线（地线）悬挂在直线杆塔上，也可用于换位杆塔上支持换位导线以及耐张转角杆塔跳线的固定</p></li></ul></li></ul><p>依据悬垂线夹的悬垂角确定巡检机器人线上爬坡最大角度<strong>一般小于25°</strong></p><p><img src="https://s2.loli.net/2023/04/17/KVeCTBL5dyEIli1.png" alt="悬垂线夹.png"></p><p>悬垂线夹</p><p><img src="https://s2.loli.net/2023/04/17/QF74oR53SbZjaiL.png" alt="耐张绝缘子串.png"></p><p>耐张绝缘子串</p><p><img src="https://s2.loli.net/2023/04/17/KyLZUSu3sHPY1nR.png" alt="间隔棒.png"></p><p>间隔棒</p><h2 id="1-3-机构设计的具体要求-1"><a href="#1-3-机构设计的具体要求-1" class="headerlink" title="1.3 机构设计的具体要求"></a>1.3 机构设计的具体要求</h2><ol><li>线上行走，至少具有30°的爬坡能力；</li><li>为减轻高压线承重，整体机构尽量设计轻便；</li><li>能较为平稳地跨越障碍物；</li><li>具有足够的稳定性，能够抵抗高空环境下风力等外部因素的影响；</li><li>预留出合适的空间以加装控制箱及检修相关传感器。</li></ol><hr><h2 id="二、整体方案的拟定及说明-1"><a href="#二、整体方案的拟定及说明-1" class="headerlink" title="二、整体方案的拟定及说明"></a>二、整体方案的拟定及说明</h2><h2 id="2-1-整体机构组成-1"><a href="#2-1-整体机构组成-1" class="headerlink" title="2.1 整体机构组成"></a>2.1 整体机构组成</h2><ul><li>行走避障机构</li><li>机体平衡机构</li><li>夹爪机构</li><li>脱线控制机构</li></ul><h2 id="2-2-整体方案分析-1"><a href="#2-2-整体方案分析-1" class="headerlink" title="2.2 整体方案分析"></a>2.2 整体方案分析</h2><p>高压线直径一般为78mm左右；</p><p>根据常见障碍物尺寸，机器人在线上跨越障碍时应有几十公分的跨距。</p><p>常见的行走越障机构系统为轮臂组合式，设计行走轮和压紧轮，防止侧翻和打滑，实际中技术难点为：跨越式穿越障碍，轮臂会脱离输电线路，要使轮臂再次精准挂线，控制难度非常大；越障过程中存在单点挂线的情况，由机器人自重产生的力矩，会加大上震动的幅度，只能不断调节自身重心，保证线上姿态稳定，使控制系统更加繁杂；同时常见的轮臂式机器人往往具有较多的电机与自由度，控制难度较大。</p><p>因此，我们打算采用轮腿式行走避障机构，并且更多地将运动控制通过机械设计的方式实现。使用连杆实现行走，并通过夹爪旋转机构从此分出一部分动力根据行走机构的姿态实现夹爪的松紧控制与旋转，方便脱线与重新上线，配合完成行走。</p><h3 id="2-3-人员分工-1"><a href="#2-3-人员分工-1" class="headerlink" title="2.3 人员分工"></a>2.3 人员分工</h3><p>我们认为整体机构应该由行走避障机构、机体平衡机构、夹爪机构和夹爪旋转机构组成。组内每个成员负责各自机构的设计，包括结构设计、各部分的参数整定、仿真建模、应力分析、零部件选型等任务，最终整合汇总。</p><p>所有方案和设计的具体内容会在接下来的章节中有详细说明</p><ul><li>甲：行走避障机构、总体方案与分配</li><li>乙：机体平衡机构</li><li>丙：夹爪机构</li><li>丁：脱线控制机构</li></ul><h3 id="2-4总体效果预览"><a href="#2-4总体效果预览" class="headerlink" title="2.4总体效果预览"></a>2.4总体效果预览</h3><p><img src="https://s2.loli.net/2023/04/17/xLbi985KpD6Phqk.png" alt="总体预览.png"></p><hr><h1 id="三、行走机构综合设计-1"><a href="#三、行走机构综合设计-1" class="headerlink" title="三、行走机构综合设计"></a>三、行走机构综合设计</h1><h2 id="3-0-总体设计方案-1"><a href="#3-0-总体设计方案-1" class="headerlink" title="3.0 总体设计方案"></a>3.0 总体设计方案</h2><p>传统的轮式结构无法完成对障碍物的翻越，而灵活的轮臂是机器人往往具有复杂的控制方案，而且缺少稳定性。为了实现机体较为稳定地的跨越线上障碍物，我们为高压线巡检机器人设计了一个行走装置，能实现两只腿往复摆动，相互配合，交替承重，在维持机体的整体重心相对平稳的同时通过伸腿，行走机构末端的直线运动，收腿来跨过障碍物。</p><h2 id="3-1-运动结构设计方案-1"><a href="#3-1-运动结构设计方案-1" class="headerlink" title="3.1 运动结构设计方案"></a>3.1 运动结构设计方案</h2><p><strong>预期功能</strong>：</p><ol><li><strong>腿部主体往复摆动的运动方式：</strong>为了使行走机构能越过更大的障碍物，行走机构的尺寸不可避免的会设计的比较大。如果想获得较大的空间，则可以将腿架设在机体两侧，但这样一来为了保持平衡总共便需要四只腿和两根线缆才能使机器人悬挂作业，会带来较大的限制而且结构臃肿。因此考虑将其放在机体中间。为了减少行走机构与机器人主体之间的位置冲突，腿部机构主体应当尽量将杆件的工作角度限制在180°，采用往复摆动的方式实现前进和避障。</li><li><strong>腿部末端工作行程的运动轨迹为接近直线：</strong>高压线缆近似为一条直线，倘若腿部末端（不妨称之为足部）工作的运动轨迹不为一条直线，则其在支撑着机体前进时便会使整体重心上下移动，稳定性较低。故将足部工作轨迹尽可能拟合直线，在平稳机身的同时也可以便于夹爪对线缆的夹取和释放。</li><li><strong>足部回程运动轨迹具有较大的高度收缩：</strong>类似于人们行走时抬起脚跨过障碍物一样，行走机构也需要在回程时能使末端在竖直方向上有一定的收缩，以便于跨过障碍物。</li></ol><p><strong>行走机构效果图</strong></p><p><img src="https://s2.loli.net/2023/04/17/ysLJnwYQp7ej8aF.png" alt="行走机构渲染.png"></p><h3 id="3-1-1-连杆机构-1"><a href="#3-1-1-连杆机构-1" class="headerlink" title="3.1.1 连杆机构"></a>3.1.1 连杆机构</h3><p><strong>运动简图</strong></p><p><a href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a956a669-305b-4895-b1b6-5482bde1a871/SOLIDWORKS_Premium_2022_SP0.0_-_菱形腿3.SLDASM___2023-04-07_17-55-24_2.mp4">SOLIDWORKS Premium 2022 SP0.0 - [菱形腿3.SLDASM _] 2023-04-07 17-55-24_2.mp4</a></p><p><strong>杆长调节</strong></p><p><img src="https://s2.loli.net/2023/04/17/5ERUGySXxNL9FcD.png" alt="腿简图.png"></p><p>将整个机构大致分为上下两个部分。上半部分为一个曲柄摇杆机构，下半部分为一个五连杆机构。</p><ol><li><p>为了使行走机构具有尽可能大的步幅，我们希望上半部分的摇杆具有更大的摆动角。因此可以适当增加最上面两根杆件的长度</p></li><li><p>为了使下方的往复运动有更大的摆动角度范围，也是增加步幅，可以适当减小三角形构件的最大内角。该角不能太大，否则在运动过程中可能会出现内测两杆角度出现负值，末端轨迹会产生内折。</p></li><li><p>为了使末端具有更大的回程收缩高度，可以调节三角构件内侧边长度与最下方两杆长度关系，也可以调节上面的内角来增加内侧两边在运动过程中的最大张角。</p></li><li><p>为了使末端工作行程的轨迹中的水平部分占比更高，需要调节上方两个曲柄摇杆机构之间的关系，同时也需要调节下方机构的杆长，避免出现类似于碗装的轨迹，使整个机身尽可能平稳。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/fd041055-36e4-46e3-9da3-fc9cd0715079/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2023-04-06_175549.png" alt="屏幕截图 2023-04-06 175549.png"></p></li></ol><p>在调节杆长的过程中，杆件的轨迹往往很难通过我们直观的感觉去进行调节。因为可能只是某些杆长或者角度的微小变化，就会使最终的轨迹产生较大的变动；同时在杆件较多的时候，最终轨迹的影响因素也会大量增加。所以想要调节出一个比较理想的轨迹可能会比较困难。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/36e848ad-00e1-4670-89fc-d974da31dbb6/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2023-04-09_130202.png" alt="屏幕截图 2023-04-09 130202.png"></p><p>所以我想能不能让电脑帮我去寻找合适的参数呢？于是我就写了一段程序来计算出杆件机构在各种参数下的末端位置，进一步得到曲柄旋转一周过程中的末端轨迹。然后套用机器学习中的梯度下降算法，最后收敛得到较为不错的一组参数。右图即为进一步优化过后得到的曲线，可以看到水平方向上的范围没有太大的变化，但是竖直方向上的高度从二十多厘米增加到了四十多厘米。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0463f01c-3142-41c8-ad15-a8cb0ac45e82/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE_2023-04-09_130044.png" alt="屏幕截图 2023-04-09 130044.png"></p><p>另外，为了更充分的利用空间，避免连杆之间的碰撞，连杆设计为相互交错的层状分布</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/822a9bc4-a84c-44e3-877d-f2b9e7c3aef8/Untitled.png" alt="Untitled"></p><h3 id="3-1-2-高度补偿机构-1"><a href="#3-1-2-高度补偿机构-1" class="headerlink" title="3.1.2 高度补偿机构"></a>3.1.2 高度补偿机构</h3><p>因为行走机构的工作行程大概只占据整个流程一半的时间，两只腿在交接的时候就不太稳定。就像我们在正常行走的过程中，是一只脚先落地，另一只脚再抬起来，如果一直脚刚落地另一只就立马抬起来，整个人也会不太稳定。</p><p>所以我设计了一个高度补偿装置，在夹爪松开电线的前一刻装置是压缩的，在回程到离机体最近的地方被中间的摇杆顶起来；在夹爪夹住电线的前一刻使伸长的，这样便可以保证在另一只夹爪松开前便已经抓住电线，在腿将夹爪推向电线的时候重新压缩并卡住。</p><p><strong>模型展示</strong></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/cb276687-39df-4479-a221-665fa5439f54/%E9%A2%84%E8%A7%88.png" alt="预览.png"></p><p><a href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4d55d138-2319-4133-bdd9-52f2f4c42064/SOLIDWORKS_Premium_2022_SP0.0_-_脚踝.SLDASM___2023-04-10_22-34-26_Trim.mp4">SOLIDWORKS Premium 2022 SP0.0 - [脚踝.SLDASM _] 2023-04-10 22-34-26_Trim.mp4</a></p><p>这个结构的设计是类似于生活中常见的电风扇的按钮升降设计。当被压缩时，内部的卡槽横向移动，到最下方时弹簧将卡槽弹回，升降平台被卡在下面；当腿部连杆机构回程收缩时，提杆被中间的摇杆顶起，卡槽向左移动，平台被弹回到伸长的状态。</p><p><strong>配合连杆机构运动动画</strong></p><p><a href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/08d11488-adb9-47a3-ad95-f506964ffb70/SOLIDWORKS_Premium_2022_SP0.0_-_装机.SLDASM___2023-04-11_13-51-13_Trim_Trim.mp4">SOLIDWORKS Premium 2022 SP0.0 - [装机.SLDASM _] 2023-04-11 13-51-13_Trim_Trim.mp4</a></p><h3 id="3-1-3-动力装置-1"><a href="#3-1-3-动力装置-1" class="headerlink" title="3.1.3 动力装置"></a>3.1.3 动力装置</h3><p>将电机安装于箱体，通过皮带轮带动两个曲柄，两个腿部机构的曲柄保持180°的相位差同速运转。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a470e460-ec85-457d-ad80-bb32684a76eb/Untitled.png" alt="Untitled"></p><h3 id="3-1-4-整体运动流程-1"><a href="#3-1-4-整体运动流程-1" class="headerlink" title="3.1.4 整体运动流程"></a>3.1.4 整体运动流程</h3><p>没有遇到障碍时，通过末端轮子滚动，驱动机器人在线上移动。</p><p>机器靠近障碍</p><p>前腿收起越过障碍，后腿抓住电线并推动整体向前移动；</p><p>前腿末端接触电线，后腿仍然保持抓住电线；</p><p>前腿末端被压向电线，末端夹爪通过翻转卡住电线并夹紧，同时高度补偿机构被压缩并锁住；</p><p>前后夹爪均夹住高压线；</p><p>后腿末端夹爪翻转开始脱线，前腿拉动机体向前运动；</p><p>后腿收起越过障碍，前腿继续拉动机体向前运动；</p><p>后腿收至最低处时，摇杆推起高度补偿装置上的提杆，横板平移，高度补偿装置弹回伸长状态；</p><p>后腿夹爪回到线上，前腿夹爪也保持在线上</p><p>完成越障，回到通过末端轮子滚动，驱动机器人在线上移动的状态。</p><h2 id="3-2-尺寸综合与应力分析-1"><a href="#3-2-尺寸综合与应力分析-1" class="headerlink" title="3.2 尺寸综合与应力分析"></a>3.2 尺寸综合与应力分析</h2><h3 id="3-2-1-机体尺寸与越障尺寸-1"><a href="#3-2-1-机体尺寸与越障尺寸-1" class="headerlink" title="3.2.1 机体尺寸与越障尺寸"></a>3.2.1 机体尺寸与越障尺寸</h3><div class="table-container"><table><thead><tr><th>尺寸名称</th><th>参数大小</th></tr></thead><tbody><tr><td>机架长度</td><td>800mm</td></tr><tr><td>机架高度</td><td>450mm</td></tr><tr><td>机架宽度</td><td>350mm</td></tr><tr><td>水平方向步幅</td><td>700mm</td></tr><tr><td>竖直方向收腿距离</td><td>420mm</td></tr><tr><td>两腿中心间距</td><td>600mm</td></tr></tbody></table></div><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/402f21de-4f9d-420a-891a-b97386d5435a/Untitled.png" alt="Untitled"></p><p>可以看出，在保持一定机身尺寸的情况下该行走机构的越障能力较为不错。</p><h3 id="3-2-2-连杆机构应力优化-1"><a href="#3-2-2-连杆机构应力优化-1" class="headerlink" title="3.2.2 连杆机构应力优化"></a>3.2.2 连杆机构应力优化</h3><p>为了尽量减轻对高压线的负荷，机体应该设计的尽可能轻便，整体结构选择使用密度低强度高的铝合金。在整个机构中，负荷较大的为中间的三角形构件，主要受到剪切力的作用。</p><p>使用solidworks的simulation插件对该构件进行有限元分析，在下方两轴设置固定铰链约束，在末端施加剪切力与轴向力</p><p><strong>应力图</strong></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c31a9cac-0384-432a-9d2b-604c7e76abc3/Untitled.png" alt="Untitled"></p><p><strong>位移图</strong></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b7a035ef-91ee-4b1e-bf67-8662d0eb17a5/Untitled.png" alt="Untitled"></p><p>在中间凹陷处两侧均产生了很大的应力，最大应力达到了2.92 x 107N/m²，超过了屈服力（2.757 x 107N/m²），属于危险情况。在与固定铰支座接近的部位应力情况较为不错。在末端产生了较大的位移，相对于450mm的杆件产生了2mm左右的位移。</p><p>为了使应力分布更加均匀合理，但是同时也不过多的挤占两行走机构之间用于连接两侧箱体的空间，减小腿部机构整体的形变情况，尝试更充分利用连杆机构内侧空间，对连杆形状进行优化，重新进行分析，结果如下</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7dec4297-93c2-4de6-8b17-22d46d378ee8/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1c53ba80-5e8c-4658-a830-54c4ad8e4c44/Untitled.png" alt="Untitled"></p><p>相较于之前的情况，新机构的应力分布更为均匀，板材适量增加，所以变动是有价值的。</p><h2 id="3-3-动力分析与选型-1"><a href="#3-3-动力分析与选型-1" class="headerlink" title="3.3 动力分析与选型"></a>3.3 动力分析与选型</h2><h3 id="3-3-1-速度与位移分析"><a href="#3-3-1-速度与位移分析" class="headerlink" title="3.3.1 速度与位移分析"></a>3.3.1 速度与位移分析</h3><p><strong>水平方向速度</strong></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1816824c-9e36-4df5-ab54-46a423963618/Untitled.png" alt="Untitled"></p><p><strong>水平方向位移</strong></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b40a63af-36b4-44c4-9179-9f03be5759d0/Untitled.png" alt="Untitled"></p><p>由图可知，腿部机构末端在工作行程时基本保持匀速，可以保证在行进时机体尽可能的保持稳定；同时，机构稳定的匀速运动使得动力装置的负担减小，这让我们在选择主动力电机的时候有了更为广泛的选择，也大大降低了电控方案的复杂度。</p><h3 id="3-3-2-机架设计"><a href="#3-3-2-机架设计" class="headerlink" title="3.3.2 机架设计"></a>3.3.2 机架设计</h3><p>机架采用较为轻便的铝合金，在满足强度要求的情况下，选用欧标4040Q-1.3铝架。单位长度质量为0.9kg/m</p><p>在先前设计的基础上，可以设计出大致的基本框架。具体设计可根据实际测量设备的空间需求进一步细化设计。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0486aa9e-adfe-4553-8b1c-cff334fd10f1/Untitled.png" alt="Untitled"></p><p>总长度为0.8x4+0.45x4+0.35x2=5.7m，总质量为5.13kg</p><h3 id="3-3-3-电机选型"><a href="#3-3-3-电机选型" class="headerlink" title="3.3.3 电机选型"></a>3.3.3 电机选型</h3><p>在行走时由平衡机构的钢丝与夹爪机构共同提供拉力以平衡重力。同时，行走机构在维持机体平衡并且带动机体前进时，也需要提供足够的扭矩防止重力与上述拉力产生的残差力矩使机身倾斜。</p><p><strong>机箱大致由以下部分组成</strong></p><ul><li>电机质量 0.36kg</li><li>皮带质量 0.1kg</li><li>皮带轮质量 0.4kg</li><li>24v电池质量 1kg</li><li>机架质量 5.13kg</li><li>平衡机构质量 3kg</li><li>其他测量仪器</li></ul><p>动力轴与质心距离300mm，加上其它测量设备，整机质量保守估计为15kg，平衡机构可抵消90%力矩，设安全系数为1.5，则需求力矩为6.75NM</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/73e93010-a7da-4103-9159-0198f3dc51f6/Untitled.png" alt="Untitled"></p><p>选取F86-H114型号的步进电机即可</p><h3 id="3-3-3-控制补偿"><a href="#3-3-3-控制补偿" class="headerlink" title="3.3.3 控制补偿"></a>3.3.3 控制补偿</h3><p>步进电机通过脉冲信号控制。可以通过改变脉冲频率来调节电机转速。虽然整个行走机构在行走过程中有较为稳定的行走速度，但是仍然会有部分波动。因此，可以通过调节电机转速来对速度控制进行补偿。</p><p>电机保持转速</p><hr><h1 id="四、机体平衡机构设计"><a href="#四、机体平衡机构设计" class="headerlink" title="四、机体平衡机构设计"></a>四、机体平衡机构设计</h1><h3 id="4-1平衡机构设计要求及方案-1"><a href="#4-1平衡机构设计要求及方案-1" class="headerlink" title="4.1平衡机构设计要求及方案"></a>4.1平衡机构设计要求及方案</h3><p>机体平衡机构在避障时发挥作用，采用调整质心的方案使前爪在脱线-越障-搭线时机体能够保持平衡。</p><p>首先的想法是使用丝杠直线运动机构，电机驱动丝杠使后爪端滑块从端点滑动至机体中部附近，同时前爪端滑块保持不动，使整体质心位于中部，箱体保持水平。前爪完成越障后，后爪端滑块滑至端点，前爪端滑至中部，以使后爪完成越障。</p><p>滑块与行走避障机构间采用钢丝与弹簧连接。最终设计如下：（仅为一端）</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/835e2c1c-9eba-48e2-97f9-163a2dc0b7f1/Untitled.png" alt="Untitled"></p><h3 id="4-2齿轮齿条传动-1"><a href="#4-2齿轮齿条传动-1" class="headerlink" title="4.2齿轮齿条传动"></a>4.2齿轮齿条传动</h3><p>采用丝杠传动的不妥之处在于需要安排两条丝杠机构，这将会增加成本，于是采用齿轮齿条传动，为加强稳定性，前后爪各设两个弹簧。此机构将安装在箱体内部。</p><p>初次设计时，电机与齿轮间的传动零件太长，为增加稳定性应缩短。并且发现两齿条间距过短导致无法与避障机构配合，故增加了轴的长度。</p><p><a href="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f2dd8c65-fdbd-46e6-9239-adacf08158cc/11111.mp4">11111.mp4</a></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/dee970b7-866d-40db-a923-d3c52a5152a4/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/90750bfa-c6ef-434f-a990-4805fd6bc69f/Untitled.png" alt="Untitled"></p><h3 id="4-3-齿轮齿条传动平衡机构与行走机构配合-1"><a href="#4-3-齿轮齿条传动平衡机构与行走机构配合-1" class="headerlink" title="4.3 齿轮齿条传动平衡机构与行走机构配合"></a>4.3 齿轮齿条传动平衡机构与行走机构配合</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/77deec18-cb66-4b2a-b2a9-98565c3c9aba/Untitled.png" alt="Untitled"></p><hr><h1 id="五、夹爪机构具体设计方案-1"><a href="#五、夹爪机构具体设计方案-1" class="headerlink" title="五、夹爪机构具体设计方案"></a>五<strong>、</strong>夹爪机构具体设计方案</h1><h2 id="5-1总体设计方案-1"><a href="#5-1总体设计方案-1" class="headerlink" title="5.1总体设计方案"></a>5.1总体设计方案</h2><p>该结构由一大两小共三个轮子、底座和T形结构组成。T形结构插在底座的开孔中，孔中有弹簧，将T形结构连同两个小轮向上推，与大轮一起夹紧高压线，在底座背面有与丅形结构固连的齿条，通过齿轮转动可以将T型结构下压，从而松开高压线。考虑的高压线与地面可能并不水平，将T形结构设计为上下两部分，中间插入一根轴，使T形结构的上半部分可以进行顺时针或逆时针方向30度的转动，从而使三个轮子与高压线贴合更紧密。同时，在底座上方开槽，使大轮可以向上抬升和绕平行于高压线的轴转动。大轮为主动轮，由大轮后方电机驱动，从而实现机器人在高压线上的行进。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/06886a3a-7b69-49d0-9adb-c9271970956d/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/286c34ef-3541-4658-99bf-463aef33b237/Untitled.png" alt="Untitled"></p><h2 id="5-2夹爪机构爆炸图-1"><a href="#5-2夹爪机构爆炸图-1" class="headerlink" title="5.2夹爪机构爆炸图"></a>5.2夹爪机构爆炸图</h2><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/18b9354e-5c90-42b4-a04d-3ef3d56f1cc3/Untitled.png" alt="Untitled"></p><h2 id="5-3夹爪机构应力分析-1"><a href="#5-3夹爪机构应力分析-1" class="headerlink" title="5.3夹爪机构应力分析"></a>5.3夹爪机构应力分析</h2><p>对T形结构中间转轴进行应力分析</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6adca293-456f-423f-ad65-ccab14733087/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5c652dd2-ab1e-4321-9b23-739cb419df3e/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e2e69567-66d6-488d-9462-b2e299c57f80/Untitled.png" alt="Untitled"></p><hr><h1 id="六、脱线控制机构综合设计"><a href="#六、脱线控制机构综合设计" class="headerlink" title="六、脱线控制机构综合设计"></a><strong>六、脱线控制机构综合设计</strong></h1><h2 id="6-1-总体设计方案"><a href="#6-1-总体设计方案" class="headerlink" title="6.1 总体设计方案"></a>6.1 总体设计方案</h2><p>为实现遇到障碍时，夹持机构能够从线上脱离，分别设计了凸轮齿轮齿条机构控制大轮运动、不完全齿轮齿条机构控制小轮运动以及两套齿轮系整合大轮小轮同步运动。</p><h2 id="6-2-凸轮齿轮齿条机构"><a href="#6-2-凸轮齿轮齿条机构" class="headerlink" title="6.2 凸轮齿轮齿条机构"></a>6.2 凸轮齿轮齿条机构</h2><p>遇到障碍时，我们需要使夹持装置的大轮脱离高压线，若仅抬升大轮，在配合连杆机构向下运动时将被高压线阻挡，因此我们选择旋转大轮，又因为大轮结构问题，直接旋转会与高压线冲突，因此我们选择让大轮先抬升一部分，再进行旋转。为了尽量减少电控的使用，实现仅用一个原动件控制实现该运动，我们设计了一个凸轮与齿轮齿条的配合机构。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/1a50a135-a2fb-4936-baa7-fdea944a991f/Untitled.png" alt="Untitled"></p><p>其运动分为两部分完成：</p><h3 id="第一阶段：抬升阶段"><a href="#第一阶段：抬升阶段" class="headerlink" title="第一阶段：抬升阶段"></a>第一阶段：抬升阶段</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6267aeb2-f80a-4919-bb2a-f586056bb940/Untitled.png" alt="Untitled"></p><h3 id="第二阶段：旋转阶段"><a href="#第二阶段：旋转阶段" class="headerlink" title="第二阶段：旋转阶段"></a>第二阶段：旋转阶段</h3><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/65cf00e0-056c-4e62-b2a6-5048ad4e9c0d/Untitled.png" alt="Untitled"></p><h2 id="6-3-不完全齿轮齿条机构"><a href="#6-3-不完全齿轮齿条机构" class="headerlink" title="6.3 不完全齿轮齿条机构"></a>6.3 不完全齿轮齿条机构</h2><p>为了使夹持机构中小轮行走时能够通过弹簧控制夹紧高压线，在遇到障碍时能够由齿轮系控制向下松开高压线，我们设计一个不完全齿轮齿条机构。</p><h3 id="1、行走状态"><a href="#1、行走状态" class="headerlink" title="1、行走状态"></a>1、行走状态</h3><p>齿轮与齿条未啮合，小轮由弹簧控制与线夹紧。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/969a67f2-30fc-48d9-a6ce-b5a237ffb20f/Untitled.png" alt="Untitled"></p><h3 id="2、脱线状态"><a href="#2、脱线状态" class="headerlink" title="2、脱线状态"></a>2、脱线状态</h3><p>遇到障碍时，齿轮与齿条啮合，小轮由齿轮系控制向下运动松开线路。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/c3df8c31-d02c-424b-adb2-baac1a575661/Untitled.png" alt="Untitled"></p><h2 id="6-4-齿轮系机构"><a href="#6-4-齿轮系机构" class="headerlink" title="6.4 齿轮系机构"></a>6.4 齿轮系机构</h2><h3 id="1、连接凸轮机构部分"><a href="#1、连接凸轮机构部分" class="headerlink" title="1、连接凸轮机构部分"></a>1、连接凸轮机构部分</h3><p>根据凸轮机构尺寸，两凸轮转轴之间水平距离x=50mm，竖直距离可在一定范围内自主设计，为计算方便定为y=270mm，在此基础之上我们设计一个传动比为1：1的齿轮系。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8fb7d0a8-d7ba-4b34-a24d-faac4e3e8546/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5c2bb20e-390d-4d70-8889-ba68a5c3a8f5/Untitled.png" alt="Untitled"></p><h3 id="2、连接不完全齿轮机构部分"><a href="#2、连接不完全齿轮机构部分" class="headerlink" title="2、连接不完全齿轮机构部分"></a>2、连接不完全齿轮机构部分</h3><p>根据夹持装置和凸轮装置尺寸，可以得出齿条分度线与凸轮机构中的齿轮中心水平距离x=45mm，竖直高度可在一定范围内自主设计，我们选取一个较为合适的距离，使得不完全齿轮位于齿条槽靠近中点位置，取图1中的轮5到不完全齿轮中心竖直距离y=445mm。在此基础上我们设计一个传动比为3：2的齿轮系。</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/288d6cca-a7b3-4e9f-8977-46359287acf2/Untitled.png" alt="Untitled"></p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/eaf49a03-2ef3-4b7d-bc76-b4fa6141670c/Untitled.png" alt="Untitled"></p><h2 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h2><p>最终将三个机构与夹持装置安装配合好之后效果如图</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4dfef081-ed01-4533-8e64-af92ebb556c5/Untitled.png" alt="Untitled"></p><p>将各零件组装配合好之后，转动主动件齿轮2，大轮先抬升再旋转，小轮同时向下松开，与预期效果相符。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机械设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Balancebot&#39;s LQR controller &amp; Rhomberg observer</title>
      <link href="/2023/04/04/Balancebot-s-LQR-controller-Rhomberg-observer/"/>
      <url>/2023/04/04/Balancebot-s-LQR-controller-Rhomberg-observer/</url>
      
        <content type="html"><![CDATA[<h1 id="平衡小车的LQR控制器与Rhomberg观测器"><a href="#平衡小车的LQR控制器与Rhomberg观测器" class="headerlink" title="平衡小车的LQR控制器与Rhomberg观测器"></a>平衡小车的LQR控制器与Rhomberg观测器</h1><h2 id="动力学分析"><a href="#动力学分析" class="headerlink" title="动力学分析"></a>动力学分析</h2><p><img src="https://s2.loli.net/2023/04/04/KMY2DAwlgVj4FsW.jpg" alt="动力学分析.jpg"></p><h2 id="控制器设计"><a href="#控制器设计" class="headerlink" title="控制器设计"></a>控制器设计</h2><h3 id="状态空间方程"><a href="#状态空间方程" class="headerlink" title="状态空间方程"></a>状态空间方程</h3><p>令$\xi = [\theta,\dot{\theta},x,\dot{x}]$；且令$\theta\to 0; \dot{\theta} \to 0$，相当于在0处进行泰勒展开</p><p>化简得到</p><script type="math/tex; mode=display">\dot{\xi} = \begin{bmatrix}0 & 1 & 0 & 0 \\\frac{M+m}{Ml}g & 0 & 0 & 0 \\0 & 0 & 0 & 1 \\-\frac{mg}{M} & 0 & 0 & 0\end{bmatrix}\xi+\begin{bmatrix}0 \\-\frac{1}{Ml} \\0 \\\frac{1}{M}\end{bmatrix}u</script><p>取输出水平力 $u = -K_1X_1-K_2X_2-K_3X_3-K_4X_4$</p><h3 id="Simulink仿真"><a href="#Simulink仿真" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h3><p>取m=1kg, M=1kg, g=10m/s^2, l=1m</p><script type="math/tex; mode=display">Q=\begin{bmatrix}10&0&0&0 \\0&1&0&0 \\0&0&1&0 \\0&0&0&1\end{bmatrix},\quad R=0.1</script><p>取代价函数最小值，得到</p><script type="math/tex; mode=display">K = \begin{bmatrix}-70.7312  -18.9427   -3.1623   -6.4873\end{bmatrix}</script><p>使用Simulink进行仿真，设置初始Pithch角为5°</p><script type="math/tex; mode=display">\dot{x_1} = x_2 \\\dot{x_2} = 20x_1 - u \\\dot{x_3} = x_4 \\\dot{x_4} = -10x_1 + u \\u = -k_1x_1-k_2x_2-k_3x_3-k_4x_4</script><p><img src="https://s2.loli.net/2023/04/04/RuN3SLQ7ZcOwkei.png" alt="simulink-只有控制器.png"></p><p>运行得到结果</p><p><img src="https://s2.loli.net/2023/04/04/tpNQh3zaRqJCAr2.png" alt="曲线-controller only.png"></p><p><img src="https://s2.loli.net/2023/04/04/Q865WhwOrqkZfym.png" alt="曲线.png"></p><h2 id="观测器设计"><a href="#观测器设计" class="headerlink" title="观测器设计"></a>观测器设计</h2><p>观测器设计的初步学习可以参考下面这篇笔记</p><h3 id="不考虑机械中值"><a href="#不考虑机械中值" class="headerlink" title="不考虑机械中值"></a>不考虑机械中值</h3><h4 id="观测器方程"><a href="#观测器方程" class="headerlink" title="观测器方程"></a>观测器方程</h4><p>方便起见，状态变量暂时只取 $X_1,X_2$，即为 $\theta$ 和 $\dot{\theta}$ ；</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{X_1}\\\dot{X_2}\end{bmatrix} =\begin{bmatrix}0 & 1 \\ \frac{M+m}{Ml}g & 0\end{bmatrix}\begin{bmatrix}X_1 \\ X_2\end{bmatrix} +\begin{bmatrix}0 \\ -\frac{1}{Ml}\end{bmatrix} u</script><p>取输出$y=\begin{bmatrix}1&amp;0\end{bmatrix}\begin{bmatrix}X_1\\X_2\end{bmatrix}$, 则$C=\begin{bmatrix}1&amp;0\end{bmatrix}$</p><p><strong>可观测性检测</strong></p><script type="math/tex; mode=display">O=\begin{bmatrix}C\\CA\end{bmatrix}=\begin{bmatrix}1&0 \\ 0&1\end{bmatrix}</script><p>满秩，可观测</p><p><strong>观测方程</strong></p><script type="math/tex; mode=display">\begin{bmatrix}\dot{\hat{X_1}} \\ \hat{\dot{X_2}} \end{bmatrix} =\begin{bmatrix}0 & 1 \\ \frac{M+m}{Ml}g & 0\end{bmatrix}\begin{bmatrix}\hat{X_1} \\ \hat{X_2}\end{bmatrix} +\begin{bmatrix}0 \\ -\frac{1}{Ml}\end{bmatrix} u + L(y - \hat{y})</script><p><strong>由观测器和控制器分离原理</strong></p><p>令<strong>A-LC</strong>和<strong>A-BK</strong>的特征值实部分别小于<strong>0</strong>计算出<strong>L矩阵和K矩阵</strong>即可</p><h4 id="Simulink仿真-1"><a href="#Simulink仿真-1" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h4><p>直接令$(\lambda+1)^2=0$得到L矩阵和K矩阵</p><p><img src="https://s2.loli.net/2023/04/04/EjUtuBDpFL158Z3.png" alt="observer-without alpha.png"></p><p>​    左半部分为观测器系统，右半部分为理想情况下的现实物理系统。观测器能获得的数据只有角度值θ即$X_1$，由此估计出 $\hat{X_1},\hat{X_2}$，并依据这两个估计值给出控制量$u$，输入到物理系统中。</p><p>​    将物理系统中的角度初始值设为<strong>5°</strong>，将观测器中的角度初始值设置为<strong>0°</strong>，仿真运行结果如下。</p><p><img src="https://s2.loli.net/2023/04/04/m1oXUlVEHcb8vhB.png" alt="曲线3.png"></p><p><img src="https://s2.loli.net/2023/04/04/AWwOPh9sFSRDgfN.png" alt="曲线4.png"></p><p>最后观测器收敛至真实值，但是由于初始信息差的存在，导致控制效果受到了一定的影响。</p><h3 id="机械中值的收敛"><a href="#机械中值的收敛" class="headerlink" title="机械中值的收敛"></a>机械中值的收敛</h3><p>​    实际上的机械中值是没法精确测得的，并且也有可能随时间变化，所以需要设计观测器使系统可以得到真实的机械中值。</p><h4 id="不寻找机械中值的效果"><a href="#不寻找机械中值的效果" class="headerlink" title="不寻找机械中值的效果"></a>不寻找机械中值的效果</h4><p><img src="https://s2.loli.net/2023/04/04/RhmLETK2oQAtsOZ.png" alt="不寻找alpha.png"></p><p><img src="https://s2.loli.net/2023/04/04/f6Mn42WpNSoCx8r.png" alt="曲线5.png"></p><p>​    在之前的观测器系统中，直接添加 $\alpha$ 后控制系统失控，而且观测器也不再收敛。</p><p>​    如果是之前的没有观测器的模型的话，大致是这样的一个过程。平衡点在3°，当车子为0°时车子会向后倾，角度值减小；此时为了使车身回到0°，轮子也向后移动，最后角度不变，趋于匀加速移动。</p><p><img src="https://s2.loli.net/2023/04/04/vXYmMF5ySwtxTjo.png" alt="simulink.png"></p><h4 id="观测器设计-1"><a href="#观测器设计-1" class="headerlink" title="观测器设计"></a>观测器设计</h4><p>将真实的机械中值设为$\alpha$，则$\theta$应当变为$\theta - \alpha$，得到新的状态空间方程</p><script type="math/tex; mode=display">\begin{bmatrix}\dot{X_1}\\\dot{X_2}\end{bmatrix} =\begin{bmatrix}0 & 1 \\ \frac{M+m}{Ml}g & 0\end{bmatrix}\begin{bmatrix}X_1 \\ X_2\end{bmatrix} +\begin{bmatrix}0 \\ -\frac{1}{Ml}\end{bmatrix} u + \begin{bmatrix}0 \\ -\frac{M+m}{Ml}g\end{bmatrix}\alpha</script><p>状态空间取$\hat{X} = \begin{bmatrix}\hat{\theta} &amp; \dot{\hat{\theta}} &amp; \hat{\alpha}\end{bmatrix}^T$，输出 $y = \begin{bmatrix}1&amp;0&amp;0\end{bmatrix}\begin{bmatrix}\theta \\ \dot{\theta} \\ \alpha \end{bmatrix}$</p><p>可观测性检测得可观测</p><p><strong>观测器方程</strong></p><script type="math/tex; mode=display">\begin{bmatrix}\dot{\hat{X_1}} \\ \dot{\hat{X_2}} \\ \dot{\hat{X_3}}\end{bmatrix} =\begin{bmatrix}0 & 1 & 0 \\ \frac{M+m}{Ml}g & 0 & -\frac{M+m}{Ml}g \\ 0 & 0 & 0\end{bmatrix}\begin{bmatrix}\hat{X_1} \\ \hat{X_2} \\ \hat{X_3}\end{bmatrix} +\begin{bmatrix}0 \\ -\frac{1}{Ml} \\ 0\end{bmatrix} u + \begin{bmatrix}l_1 \\ l_2 \\ l_3\end{bmatrix}(y - \hat{y})</script><p>同样可令<strong>A-LC</strong>和<strong>A-BK</strong>的特征值实部分别小于<strong>0</strong>计算出<strong>L矩阵和K矩阵</strong>即</p><p><strong>输出</strong></p><p>$u = -K_1(X_1-X_3)-K_2X_2$</p><h4 id="Simulink仿真-2"><a href="#Simulink仿真-2" class="headerlink" title="Simulink仿真"></a>Simulink仿真</h4><p><img src="https://s2.loli.net/2023/04/04/t1fSoAO8WzYEdXj.png" alt="simulink observer.png"></p><p><img src="https://s2.loli.net/2023/04/04/kQoaeYtBSzlypbT.png" alt="曲线6.png"></p><p><img src="https://s2.loli.net/2023/04/04/ujckFSdrNGPTvHg.png" alt="曲线7.png"></p><p><img src="https://s2.loli.net/2023/04/04/wFgnhzqyjfK9c8W.png" alt="曲线8.png"></p><p>​    在观测器添加了 $\alpha$ 后，估计值 $\hat{\alpha}$ 确实可以收敛到 $\alpha$。但是在$\alpha$的估计值与真实值相差较大时，X1与X2的观测效果都不太好，导致控制效果也不太好。</p><h5 id="调整k"><a href="#调整k" class="headerlink" title="调整k"></a>调整k</h5><p>上面的控制中，为了加快收敛，我直接将输出u*5后给到系统中。u的峰值达到了580左右。</p><p>但是这样做显然是不合理的，这直接改变了系统的状态方程，虽然确实有一些用。可是更改了Q,R矩阵后依然没有太大改善。</p><h5 id="调整L矩阵"><a href="#调整L矩阵" class="headerlink" title="调整L矩阵"></a>调整L矩阵</h5><p>​    DR_CAN在课程中提到过，我们希望观测器的收敛速度大于控制器，所以尝试使<strong>A-LC</strong>矩阵的特征值更小一些。令$\lambda_1=\lambda_2=\lambda_3=-2$，得到新的$L=[6,32,-0.4]^T$</p><p><img src="https://s2.loli.net/2023/04/04/8TV97J2O5d4WLht.png" alt="曲线9.png"></p><p><img src="https://s2.loli.net/2023/04/04/4sgeKTIkS59ulL1.png" alt="曲线11.png"></p><p><img src="https://s2.loli.net/2023/04/04/CPOhJ5zEi6SB8rQ.png" alt="曲线10.png"></p><p>继续令$\lambda_1=\lambda_2=\lambda_3=-3$，得到的效果似乎更好，角度偏差峰值只有4°多一点</p><p>那$\lambda$是不是越小越好呢？令$\lambda=-100$后仿真出来的结果也不错，也没有很夸张。不过我也不太清楚，仿真并不能完全的模拟实际情况，也不能太相信仿真结果。</p><h5 id="添加初始误差"><a href="#添加初始误差" class="headerlink" title="添加初始误差"></a>添加初始误差</h5><p>令$X_1=5°,\hat{X_1}=0°$，得到的效果也不错。</p><p><img src="https://s2.loli.net/2023/04/04/4u8n63Lq5myTQAN.png" alt="曲线12.png"></p><p><img src="https://s2.loli.net/2023/04/04/Efs3J4dLxjgSAbn.png" alt="曲线13.png"></p><h2 id="STM32控制实现"><a href="#STM32控制实现" class="headerlink" title="STM32控制实现"></a>STM32控制实现</h2><h4 id="极性约定"><a href="#极性约定" class="headerlink" title="极性约定"></a>极性约定</h4><p>根据上面的模型，小车朝向右方：</p><ul><li><p>​    向右倾斜时倾斜角θ为正；</p></li><li><p>​    使小车向右运动，即轮子顺时针转为正</p></li></ul><h4 id="参数确定"><a href="#参数确定" class="headerlink" title="参数确定"></a>参数确定</h4><ul><li>m=0.55kg</li><li>M=0.4kg</li><li>l=0.05m</li></ul><p>得到</p><script type="math/tex; mode=display">A = \begin{bmatrix}0 & 1 & 0 & 0 \\465.5 & 0 & 0 & 0 \\0 & 0 & 0 & 1 \\-13.475 & 0 & 0 & 0 \\\end{bmatrix}, \quadB = \begin{bmatrix}0 \\-50 \\0 \\2.5\end{bmatrix}</script><p>仍然取</p><script type="math/tex; mode=display">Q=\begin{bmatrix}10&0&0&0 \\0&1&0&0 \\0&0&1&0 \\0&0&0&1\end{bmatrix},\quad R=0.1</script><p>使用MATLAB计算</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lqr(A,B,Q,R)</span><br></pre></td></tr></table></figure><p>得到</p><script type="math/tex; mode=display">K=\begin{bmatrix}-32.3606 & -3.6129 & -3.1623 & -4.9876\end{bmatrix}</script><p>则</p><script type="math/tex; mode=display">u = -KX \\Motor = -a*KX</script><p>其中u是水平外力，可以认为控制电机输出的信号正比于u</p><p>利用系统定时器可以得到控制函数的实际调用周期为0.01s</p>]]></content>
      
      
      
        <tags>
            
            <tag> 平衡小车 </tag>
            
            <tag> LQR controller </tag>
            
            <tag> Rhomberg observer </tag>
            
            <tag> 运动学分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>note of Tactile Sensor Papers</title>
      <link href="/2023/04/03/note-of-Tactile-Sensor-Papers/"/>
      <url>/2023/04/03/note-of-Tactile-Sensor-Papers/</url>
      
        <content type="html"><![CDATA[<h2 id="Soft-Bubble"><a href="#Soft-Bubble" class="headerlink" title="Soft Bubble"></a>Soft Bubble</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul><li>深度相机：尺寸小，帧率高，支持USB等</li><li>气囊外壳：顺应性强，摩擦力大，便于抓取</li></ul><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><h4 id="物体分类"><a href="#物体分类" class="headerlink" title="物体分类"></a>物体分类</h4><p>使用<strong>深度神经网络ResNet</strong>作为对象分拣器。</p><ul><li><p>输入</p><p>传感器受压时的深度图像</p></li><li><p>输出</p><p>施压物体属于某类别的概率</p><ul><li>具体种类<ul><li>Cube</li><li>Robot</li><li>Frustum</li><li>Triangular prism</li><li>Bridge</li><li>Hemisphere</li><li>none</li></ul></li></ul></li><li><p>算法</p><ul><li>lost function: cross-entropy loss（交叉熵损失？还没学到）</li><li>optimizer: stochastic gradient descent（随机梯度下降？也还没学到）</li></ul></li></ul><h4 id="纹理识别"><a href="#纹理识别" class="headerlink" title="纹理识别"></a>纹理识别</h4><p>在前一个实验的基础上添加三种具有不同表面纹理但具有同大小规格的立方体进行分类</p><p><strong>结论</strong></p><p>分辨成功率与图像分辨率正相关，但会有一些波动。</p><h4 id="姿态估计与跟踪"><a href="#姿态估计与跟踪" class="headerlink" title="姿态估计与跟踪"></a>姿态估计与跟踪</h4><ul><li><p>输入信息</p></li><li><p>算法：Iterative Closest Point (<strong>ICP</strong>) algorithm</p><p>将两组曲线、两组曲面或两组点云进行配准</p><ul><li><p>基本思想</p><p>输入为两组点和变换的初始估计，输出为两组点之间的最优变换。</p><p>（自己概括的，可能不全面）通过迭代的方式寻找初始点阵发生的变换矩阵，代入得出估计的变换后点阵，与真实点阵比较以寻找出误差足够小的变换。</p></li><li><p>基本流程</p><p>1）将当前估计的变换应用于第一组点；</p><p>2）对于第一组变换后的每个点，在第二组中找到最近的点；3）通过剔除异常值来更新点匹配；</p><p>4）使用更新后的点匹配计算变换，直到估计的变换收敛。</p></li><li><p>更多</p><p><a href="https://blog.csdn.net/kksc1099054857/article/details/80280964">ICP算法的原理与实现_酷小川的博客-CSDN博客</a></p></li></ul></li><li><p>姿态估计</p><p>物体的实际轮廓是已知的，作为<strong>目标点云</strong>；传感器得到的点云为<strong>初始点云</strong>，使用ICP算法找出两者之间的最优变换关系，便可得到物体的姿态。</p><p>从十二个不同方向分别匹配，寻找最合适的一个。</p></li><li><p>姿态跟踪</p><p>每一次处理中，深度图像即为传感器弹性膜的外表面的点云。使用ICP算法不断地迭代出各采样点的点云与上一个样本点云之间的变换矩阵，最终合并全部的变换矩阵，依此得出施压物体的轮廓与姿态。</p><p>以1-2Hz的频率运行，那么各个采样点之间由ICP迭代出的各个最优变换矩阵即为物体的运动轨迹</p></li></ul><hr><h2 id="TacTip"><a href="#TacTip" class="headerlink" title="TacTip"></a>TacTip</h2><h3 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h3><ul><li>仿生探针：在传感器内表面排列光学探针模仿生物皮肤下方的MCC（中间脊）</li><li>指纹：通过3D打印技术为传感器设计出特殊的指纹，一定程度上可以提高检测精度</li></ul><h3 id="Data-processing"><a href="#Data-processing" class="headerlink" title="Data processing"></a>Data processing</h3><p>每一个点位的数据包括时间与维度数据，每个针脚的X，Y方向的偏移各自独立。</p><p>通过数据训练推测出各个探针的位置状态对应的位置。（这一块基本看不懂）</p><hr><h2 id="Tokyo-University"><a href="#Tokyo-University" class="headerlink" title="Tokyo University"></a>Tokyo University</h2><p>这两篇文章所介绍的传感器大致框架不变，作者人员也有较多重合。但是二者也有所不同，第二篇文章更侧重于理论推导。</p><h3 id="Measurement-of-force-vector-field-of-robotic-finger-using-vision-based-haptic-sensor"><a href="#Measurement-of-force-vector-field-of-robotic-finger-using-vision-based-haptic-sensor" class="headerlink" title="Measurement of force vector field of robotic finger using vision-based haptic sensor"></a>Measurement of force vector field of robotic finger using vision-based haptic sensor</h3><h4 id="硬件结构-1"><a href="#硬件结构-1" class="headerlink" title="硬件结构"></a>硬件结构</h4><ul><li>透明硅胶：受力载体，同时提供有规律可循的形变</li><li>红蓝点阵：作为胶体形变参照物，由形变反推受力</li><li>摄像头：捕捉图像</li></ul><h4 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h4><ul><li>前提假设<ul><li>the sensor is a semi-infinite elastic body.</li><li>the deformation of the elastic body is linear.</li></ul></li></ul><p>u=hf</p><p>某一维度上的作用力会在另一维度产生分力；</p><p>某一维度上的力可使标记在另一维度上产生位移；</p><p>h则为作用力与标记位移之间的转换矩阵。</p><p>通过观测标记的位移与施加的已知力的关系得到h矩阵。</p><p>便可通过位移u和转换矩阵h反推出施加于传感器的外力。</p><hr><h3 id="Vision-Based-Sensor-for-RealTime-Measuring-of-Surface-Traction-Fields"><a href="#Vision-Based-Sensor-for-RealTime-Measuring-of-Surface-Traction-Fields" class="headerlink" title="Vision-Based Sensor for RealTime Measuring of Surface Traction Fields"></a>Vision-Based Sensor for RealTime Measuring of Surface Traction Fields</h3><h4 id="硬件结构-2"><a href="#硬件结构-2" class="headerlink" title="硬件结构"></a>硬件结构</h4><ul><li>Transparent elastic body：透明弹性介质</li><li>black layer：遮光层</li><li>Two layers of spherical markers：两层红蓝点阵标记物</li><li>CCD camera：相机</li></ul><h4 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h4><ul><li><p>前提假设</p><p>elastic medium is linear, isotropic, and homogeneous.（线性、各向同性、均匀性）</p></li><li><p>推导出表面法向力Fn使作用点在三个维度发生的位移公式</p></li><li><p>推导出表面切向力Ft使作用点在三个维度发生的位移公式</p></li><li><p>公式包含材料的杨氏模量E和泊松比R，可适用于多种材料</p></li><li><p>根据线性假设，可以认为各作用力对标记物产生的位移作用也可线性叠加，可用H变换矩阵表示</p></li></ul><h4 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h4><p>threshold：消除背景噪音的阈值，类似于提高水位以将丘陵分割为岛屿</p><p>精度：15微米</p><p>标记坐标的计算</p><p><img src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b63b31b9-1ddf-439a-b58f-164e7689b95a/Untitled.png" alt="Untitled"></p><p>这个P是pixels，这里是什么意思呢</p><hr><h2 id="GelSlim"><a href="#GelSlim" class="headerlink" title="GelSlim"></a>GelSlim</h2><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><ul><li><strong>incipient slip：</strong>初始滑移，指接触表面的一部分区域开始滑移（通常是外围区域）</li><li><strong>ICR：</strong>旋转中心（速度瞬心），类似于“<em>基点法</em>”求各点运动状态。</li></ul><p>在没有发生滑移时，将接区域理想化为二维刚性模型，以此来计算出传感器上的标记位移的估计值；当估计值与实际值相差较大时，则可认为初始滑移开始发生。</p><p>因为将接区域理想化为二维刚性模型，接触区域的运动就理想化为<strong>平面刚体运动，</strong>由此方便预估姿态与判断。</p><ul><li><p>具体步骤</p><ol><li><p>检测并滤波处理得到接触区域</p></li><li><p>利用opencv库得到标记点在区域内的坐标。选取一个参考坐标系，由此计算各个时刻接触区域的位移。</p><p><aside> 💡 当标记的位移接近标记间的间距时，更新参考坐标系，这样可以避免多个区域内各标记点错误匹配（因为选择离自己最近的一个点就可以认为是下一时刻的自己？）</p></li><li><p>去除接触区域的<strong>外部区域</strong>，使用内部区域的标记位移来代表刚体的位移，并计算速度。（因为外围更可能先发生初始滑移）</p></li><li><p>估计位移并由此计算或判断是否发生滑移</p></li></ol></li></ul><h3 id="拧瓶盖实验"><a href="#拧瓶盖实验" class="headerlink" title="拧瓶盖实验"></a>拧瓶盖实验</h3><ul><li>黄色箭头：真实位移</li><li>红色箭头：估计位移</li></ul><p>相当于在拧瓶盖的过程中通过触觉传感器的滑移信息形成闭环控制。</p><hr><h2 id="GelSlim-application"><a href="#GelSlim-application" class="headerlink" title="GelSlim-application"></a>GelSlim-application</h2><blockquote><p>Tactile-Based Insertion for Dense Box-Packing</p></blockquote><p>这篇文章主要是上一篇文章中介绍的<strong>GelSlim</strong>在实际应用中的尝试</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>在摄像机给出大致的空隙位置信息后，机械臂借助触觉传感器进行具有更高精度的物品放置。对周围物体与加持物体没有较多的了解，且机器人要在不破坏周围物体位置的情况下正确放置，允许试错与纠错。</p><ul><li>角度误差阈值：5°</li><li>位置误差阈值：2.5mm</li></ul><h3 id="误差获取"><a href="#误差获取" class="headerlink" title="误差获取"></a>误差获取</h3><ul><li><p>误差被分为八个种类</p><p>角度正负误差与位移正负误差排列组合</p></li><li><p>由GelSlim获取碰撞时的触觉信息</p><p>物体在碰撞或接触过程中产生的触觉信息（实际上是图像信息）被捕获并且有序存储</p></li></ul><h4 id="误差类型的判断"><a href="#误差类型的判断" class="headerlink" title="误差类型的判断"></a>误差类型的判断</h4><p><strong>卷积神经网络DirectionNN</strong></p><ul><li>输入：触觉传感器给出的接触信息</li><li>输出：属于各个误差类型的概率</li></ul><h4 id="误差大小的判断"><a href="#误差大小的判断" class="headerlink" title="误差大小的判断"></a>误差大小的判断</h4><p>即便是方向相同，误差大小的改变也会引起触觉信息的改变</p><p><strong>递归神经网络MagnitudeNN</strong></p><p>估计误差大小</p><h3 id="控制策略"><a href="#控制策略" class="headerlink" title="控制策略"></a>控制策略</h3><p>根据两个网络输出的结果一致性进行判断，更相信<strong>DirectionNN。</strong></p><ul><li>根据两个结果的差别大小制定不同的控制策略</li></ul><h4 id="迭代流程"><a href="#迭代流程" class="headerlink" title="迭代流程"></a>迭代流程</h4><ol><li>尝试放置物品</li><li>若失败，则捕获触觉信息</li><li>两个神经网络分别根据信息估计误差</li><li>控制器根据误差进行运动决策</li><li>若失败，则重复2~4，直到成功</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Tactile Sensor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/04/03/hello-world/"/>
      <url>/2023/04/03/hello-world/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="0858d2d5afc6e71fe61fde17e264b0ebd81b693504324bd451d5b9fe60576581">fa8b13601bdfbf35c816c536e1c943768052b894c07bef87cfe638eadf1a44fb1aca374ccee2eb92dae6b7862d437c4511b8689b401f36543ccb6ab66f72bf0286c6c052ef4e8c7a2ec491afed06f89a2c56b4c8675715f28bfe32cab7840fb26ae21f1cfad9201fc4ca976f5aa9b30b29f1d26800d88d671ada94dcd875d8b3edda1090b2911a1d9b0f465c5e9f8328c5cd48549be6f19403414d9688c6d62003ad856535e633eae2402819f2e0fc0bdf8686ed677e35bdac33f324558f92229db3f692da7bbac0d4cc6fe244237d3881e12c8f3413ef4e51a472e769d89c70bc4a1ae26a03a319d5b01811e30f63ee79c12b32110cdd2101b75c6de84c17f3be550357902045bf9f10615e4aa9f55c8e71d966ce60f9fed9ad627e1df8514777352c0054f33ed102972e4ca63e300ef09e350027436e85314696b7144fe22e8d4b9320a5ce45aca7f544bcbc99e60530d266d9835f87a6a0a07336f75ef08cbadda7e5b4d92dddf83aaaa1a2db7037efdfa3794b1b40d607fee759f6446124297bf0b0c1433f8089cf9f6bc53d63df6a398686aa826d1d784a5fe38e2b7abed2152e574dbd2a77b8f9bb28c18d34ee1915d33fd7092d81ef13ff30ae5ae174f042c7e083e83964e19562840a378af0c06d5ad47b8a740819d946e83b76d9e47e3b976708c03d087cb82be880643e23d138db94b4a4e7d64d0c03e5433d0dc7a95ccf86b3d1c11381f28a78d145297c943ae497edf7127d4a67bbaae900cd1f4b7237f62636f0080b07800702fd6023bb364450f4213fcbb06015f72d601d721e0fa5f9c65feefbddc6986cf86149c7018c45458bb7d201e63e3d475e9ee2c9643f0e36d3ba5b280f9d915ad8b88a5461af0a4e3a964d3fa4120340b848e62dd1682f6064e325d4abfef05e5b588920474cf8bf5da166c9d2f26a3177670d695aeba543ff6d4970a1cff53bb98490c6e1d7bf50eeb810306cd1919e2766e26ee66828b12168bc41b6fd3c6adb22cac57352a6b18a6dc68cca53ef0749db2b13480543a929b5e1a1439f22b7fe7b367c7088e3a6b9b3fbed26b1590eb01b493c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">举杯邀明月，对影成三人。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello,FreeRTOS!</title>
      <link href="/2023/01/06/Hello_FreeRTOS!/"/>
      <url>/2023/01/06/Hello_FreeRTOS!/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello，FreeRTOS！"><a href="#Hello，FreeRTOS！" class="headerlink" title="Hello，FreeRTOS！"></a>Hello，FreeRTOS！</h1><p><strong>官网链接</strong></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://www.freertos.org/zh-cn-cmn-s/">FreeRTOS - Market leading RTOS (Real Time Operating System) for embedded systems with Internet of Things extensions</a></p></div><p><strong>正点原子教程手册</strong></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://semitia.top/upload_flies/STM32F1_FreeRTOS_V1.1.pdf">https://semitia.top/upload_flies/STM32F1_FreeRTOS_V1.1.pdf</a></p></div><h1 id="DEMO1-Blink-LED移植"><a href="#DEMO1-Blink-LED移植" class="headerlink" title="DEMO1: Blink_LED移植"></a>DEMO1: Blink_LED移植</h1><p>按照教程移植的时候，编译出来会有报错</p><blockquote><p>..\OBJ\LED.axf: Error: L6200E: Symbol PendSV_Handler multiply defined (by port.o and stm32f10x_it.o).</p><p>..\OBJ\LED.axf: Error: L6200E: Symbol SVC_Handler multiply defined (by port.o and stm32f10x_it.o).</p></blockquote><p>报错信息显示 <strong>PendSV_Handler</strong>和<strong>SVC_Handler</strong>在<strong>port</strong>和<strong>stm32f10x_it</strong>里面重复定义了。网上查到了有人说要把配置文件<strong>FreeRTOSConfig.h</strong>里的宏定义注释掉</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> xPortPendSVHandler PendSV_Handler</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vPortSVCHandler SVC_Handler</span></span><br></pre></td></tr></table></figure><p>但是这两个是与与中断函数有关的配置，直接注释掉肯定不合适。在<strong>stm32法f10x_it.c</strong>里面找到这两个函数是这样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SVC_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PendSV_Handler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以选择将这两个函数给注释掉（实际上教程看到后面发现这几个函数早晚要注释掉的），这样这两个函数分别会指向<strong>port.c</strong>里面的函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">__asm <span class="type">void</span> <span class="title function_">vPortSVCHandler</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* *INDENT-OFF* */</span></span><br><span class="line">    PRESERVE8</span><br><span class="line"></span><br><span class="line">    ldr r3, = pxCurrentTCB   <span class="comment">/* Restore the context. */</span></span><br><span class="line">    ldr r1, [ r3 ] <span class="comment">/* Use pxCurrentTCBConst to get the pxCurrentTCB address. */</span></span><br><span class="line">    ldr r0, [ r1 ]           <span class="comment">/* The first item in pxCurrentTCB is the task top of stack. */</span></span><br><span class="line">    ldmia r0 !, &#123; r4 - r11 &#125; <span class="comment">/* Pop the registers that are not automatically saved on exception entry and the critical nesting count. */</span></span><br><span class="line">    msr psp, r0 <span class="comment">/* Restore the task stack pointer. */</span></span><br><span class="line">    isb</span><br><span class="line">    mov r0, # <span class="number">0</span></span><br><span class="line">    msr basepri, r0</span><br><span class="line">    orr r14, # <span class="number">0xd</span></span><br><span class="line">    bx r14</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__asm <span class="type">void</span> xPortPendSVHandler( <span class="type">void</span> )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> uxCriticalNesting;</span><br><span class="line">    <span class="keyword">extern</span> pxCurrentTCB;</span><br><span class="line">    <span class="keyword">extern</span> vTaskSwitchContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* *INDENT-OFF* */</span></span><br><span class="line">    PRESERVE8</span><br><span class="line"></span><br><span class="line">    mrs r0, psp</span><br><span class="line">    isb</span><br><span class="line"></span><br><span class="line">    ldr r3, =pxCurrentTCB <span class="comment">/* Get the location of the current TCB. */</span></span><br><span class="line">    ldr r2, [ r3 ]</span><br><span class="line"></span><br><span class="line">    stmdb r0 !, &#123; r4 - r11 &#125; <span class="comment">/* Save the remaining registers. */</span></span><br><span class="line">    str r0, [ r2 ] <span class="comment">/* Save the new top of stack into the first member of the TCB. */</span></span><br><span class="line"></span><br><span class="line">    stmdb sp !, &#123; r3, r14 &#125;</span><br><span class="line">    mov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><span class="line">    msr basepri, r0</span><br><span class="line">    dsb</span><br><span class="line">    isb</span><br><span class="line">    bl vTaskSwitchContext</span><br><span class="line">    mov r0, #<span class="number">0</span></span><br><span class="line">    msr basepri, r0</span><br><span class="line">    ldmia sp !, &#123; r3, r14 &#125;</span><br><span class="line"></span><br><span class="line">    ldr r1, [ r3 ]</span><br><span class="line">    ldr r0, [ r1 ] <span class="comment">/* The first item in pxCurrentTCB is the task top of stack. */</span></span><br><span class="line">    ldmia r0 !, &#123; r4 - r11 &#125; <span class="comment">/* Pop the registers and the critical nesting count. */</span></span><br><span class="line">    msr psp, r0</span><br><span class="line">    isb</span><br><span class="line">    bx r14</span><br><span class="line">    nop</span><br><span class="line"><span class="comment">/* *INDENT-ON* */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="FreeRTOSConfig-h"><a href="#FreeRTOSConfig-h" class="headerlink" title="FreeRTOSConfig.h"></a>FreeRTOSConfig.h</h1><p>​    这一部分在教程中有详细的讲解，在这里摘录过来，全部记住可能不太容易，主要是在具体使用的时候能方便具体查看就行了。</p><h2 id="INCLUDE"><a href="#INCLUDE" class="headerlink" title="INCLUDE_"></a>INCLUDE_</h2><h3 id="INCLUDE-xTaskGetSchedulerState"><a href="#INCLUDE-xTaskGetSchedulerState" class="headerlink" title="INCLUDE_xTaskGetSchedulerState"></a>INCLUDE_xTaskGetSchedulerState</h3><h3 id="INCLUDE-vTaskPrioritySet"><a href="#INCLUDE-vTaskPrioritySet" class="headerlink" title="INCLUDE_vTaskPrioritySet"></a>INCLUDE_vTaskPrioritySet</h3><h3 id="INCLUDE-uxTaskPriorityGet"><a href="#INCLUDE-uxTaskPriorityGet" class="headerlink" title="INCLUDE_uxTaskPriorityGet"></a>INCLUDE_uxTaskPriorityGet</h3><h3 id="INCLUDE-vTaskDelete"><a href="#INCLUDE-vTaskDelete" class="headerlink" title="INCLUDE_vTaskDelete"></a>INCLUDE_vTaskDelete</h3><h3 id="INCLUDE-vTaskCleanUpResources"><a href="#INCLUDE-vTaskCleanUpResources" class="headerlink" title="INCLUDE_vTaskCleanUpResources"></a>INCLUDE_vTaskCleanUpResources</h3><h3 id="INCLUDE-vTaskSuspend"><a href="#INCLUDE-vTaskSuspend" class="headerlink" title="INCLUDE_vTaskSuspend"></a>INCLUDE_vTaskSuspend</h3><h3 id="INCLUDE-vTaskDelayUntil"><a href="#INCLUDE-vTaskDelayUntil" class="headerlink" title="INCLUDE_vTaskDelayUntil"></a>INCLUDE_vTaskDelayUntil</h3><h3 id="INCLUDE-vTaskDelay"><a href="#INCLUDE-vTaskDelay" class="headerlink" title="INCLUDE_vTaskDelay"></a>INCLUDE_vTaskDelay</h3><h3 id="INCLUDE-eTaskGetState"><a href="#INCLUDE-eTaskGetState" class="headerlink" title="INCLUDE_eTaskGetState"></a>INCLUDE_eTaskGetState</h3><h3 id="INCLUDE-xTimerPendFunctionCall"><a href="#INCLUDE-xTimerPendFunctionCall" class="headerlink" title="INCLUDE_xTimerPendFunctionCall"></a>INCLUDE_xTimerPendFunctionCall</h3><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><h1 id="DEMO2：中断屏蔽"><a href="#DEMO2：中断屏蔽" class="headerlink" title="DEMO2：中断屏蔽"></a>DEMO2：中断屏蔽</h1><h2 id="中断屏蔽寄存器"><a href="#中断屏蔽寄存器" class="headerlink" title="中断屏蔽寄存器"></a>中断屏蔽寄存器</h2><ul><li>PRIMASK</li></ul><blockquote><p>PRIMASK 用于禁止除 NMI 和 HardFalut 外的所有异常和中断，清除后使能中断</p></blockquote><ul><li>FAULTMASK  </li></ul><blockquote><p>与 PRIMASK相比 ， FAULTMASK 可以连 HardFault 都屏蔽掉 ，它在退出时自动清零。</p></blockquote><ul><li>BASEPRI</li></ul><blockquote><p>在有些场合需要对中断屏蔽进行更细腻的控制， 比如只屏蔽优先级低于某<br>一个阈值的中断。那么这个作为阈值的优先级值存储在哪里呢？BASEPRI 寄存器中。如果向 BASEPRI 写 0 的话就会停止屏蔽中断。  </p></blockquote><h2 id="中断屏蔽的配置宏"><a href="#中断屏蔽的配置宏" class="headerlink" title="中断屏蔽的配置宏"></a>中断屏蔽的配置宏</h2><p>​    FreeRTOS 的开关中断是操作 BASEPRI 寄存器来实现的，它可以关闭低于某个阈值的中断，高于这个阈值的中断就不会被关闭 。</p><h3 id="configLIBRARY-MAX-SYSCALL-INTERRUPT-PRIORITY"><a href="#configLIBRARY-MAX-SYSCALL-INTERRUPT-PRIORITY" class="headerlink" title="configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY"></a>configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</h3><p>​    此宏用来设置 FreeRTOS 系统可管理的最大优先级，也就是<strong>BASEPRI</strong>寄存器说的那个阈值优先级，这个大家可以自由设置，这里我设置为了 5。也就是高于 5 的优先级(优先级数小于 5)不归 FreeRTOS 管理。</p><h3 id="configMAX-SYSCALL-INTERRUPT-PRIORITY"><a href="#configMAX-SYSCALL-INTERRUPT-PRIORITY" class="headerlink" title="configMAX_SYSCALL_INTERRUPT_PRIORITY"></a>configMAX_SYSCALL_INTERRUPT_PRIORITY</h3><p>​    此宏是 configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 左移 4 位而来的。<strong>此宏设置好以后，低于此优先级的中断可以安全的调用 FreeRTOS 的 API 函数，高于此优先级的中断 FreeRTOS 是不能禁止的，<emp>中断服务函数也不能调用 FreeRTOS 的 API 函数！</emp></strong> </p><h2 id="临界段代码："><a href="#临界段代码：" class="headerlink" title="临界段代码："></a>临界段代码：</h2><p>​    临界段代码也叫做临界区，是指那些必须完整运行，不能被打断的代码段，比如有的外设的初始化需要严格的时序，初始化过程中不能被打断。FreeRTOS 在进入临界段代码的时候需要关闭中断，当处理完临界段代码以后再打开中断。  </p><h2 id="任务级临界段代码保护函数"><a href="#任务级临界段代码保护函数" class="headerlink" title="任务级临界段代码保护函数"></a>任务级临界段代码保护函数</h2><p>对<strong>任务</strong>中的临界段代码语句使用的保护函数</p><ul><li>taskENTER_CRITICAL() </li><li>taskEXIT_CRITICAL()  </li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">taskcritical_test</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        taskENTER_CRITICAL();<span class="comment">//进入临界区</span></span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        taskEXIT_CRITICAL();<span class="comment">//退出临界区</span></span><br><span class="line">        vTaskDelay(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中断级临界段代码保护函数"><a href="#中断级临界段代码保护函数" class="headerlink" title="中断级临界段代码保护函数"></a>中断级临界段代码保护函数</h2><p>对<strong>中断函数</strong>中的临界段代码语句使用的保护函数</p><ul><li>taskENTER_CRITICAL_FROM_ISR()</li><li>taskEXIT_CRITICAL_FROM_ISR()</li></ul><p>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">TIM3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(TIM_GetITStatus(TIM3,TIM_IT_Update)==SET) <span class="comment">//溢出中断</span></span><br><span class="line">    &#123;</span><br><span class="line">        status_value=taskENTER_CRITICAL_FROM_ISR();</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">            </span><br><span class="line">        taskEXIT_CRITICAL_FROM_ISR(status_value);</span><br><span class="line">    &#125;</span><br><span class="line">    TIM_ClearITPendingBit(TIM3,TIM_IT_Update); <span class="comment">//清除中断标志位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> FreeRTOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello,esp32!</title>
      <link href="/2023/01/03/Hello-ESP32/"/>
      <url>/2023/01/03/Hello-ESP32/</url>
      
        <content type="html"><![CDATA[<h1 id="Hello，-esp32！"><a href="#Hello，-esp32！" class="headerlink" title="Hello， esp32！"></a>Hello， esp32！</h1><p>​    今天终于在windows上配置好了esp32的开发环境，感谢这个up主提供的方式。</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://www.bilibili.com/video/BV1QF411u72A/?spm_id_from=333.880.my_history.page.click&amp;vd_source=0f383e93e945bca07eaef9a9ee5d9db3">乐鑫ESP32官方开发环境 Espressif IDE 一键安装教程-无需插件和手动配置_哔哩哔哩_bilibili</a></p></div><p>​    我之前也试过其他的开发方式，platformIO开发呢局限性比较大，VScode上的ESpressif IDF呢一直下载失败，最后也没折腾出来。在这里总结一下这个配置方式，结合自己遇到的一些小问题。</p><h2 id="IDE安装"><a href="#IDE安装" class="headerlink" title="IDE安装"></a>IDE安装</h2><p>可以在乐鑫官方的Github下载，也可以在视频里的百度网盘下载。安装过程非常惬意，但还是有一点注意事项。</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/espressif/idf-installer#espressif-ide-offline-installer">espressif/idf-installer: ESP IDF Windows Installer (github.com)</a></p></div><p><img src="https://s2.loli.net/2023/01/04/8qiAbfNxI27vupz.png" alt="IDE.png"></p><h2 id="连接-amp-烧录"><a href="#连接-amp-烧录" class="headerlink" title="连接 &amp; 烧录"></a>连接 &amp; 烧录</h2><p>​    我这个板子直接用microUSB连接至电脑。但是数据线也要用稍微靠谱的，我一开始用的俩数据线不太行，插上去板子能取电，但是电脑识别不到串口。如果不是驱动的问题，估计就是线的问题。换了个线之后就好了。我这里是 <strong>com9</strong></p><p><img src="https://s2.loli.net/2023/01/04/PzNvTuql8oGcIB6.png" alt="esp串口.png" style="zoom:200%;" /></p><p>​    烧录的时候有一个小问题，就是connect不上板子，这个在之前用PlatformIO的时候也有类似的情况，只要按住 <strong>boot</strong> 键烧录就好了。</p><p><img src="https://s2.loli.net/2023/01/04/Cw9gNGEkP7l3piY.png" alt="connecting.png"></p><h2 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h2><p>​    打开终端，就可以看到板子发送的消息了。串口的波特率没有在代码里看到，但是实测是 <strong>115200</strong>，其他串口助手也可以接收消息。</p><p><img src="https://s2.loli.net/2023/01/04/tc2jYemq1WxQR87.png" alt="esp终端.png"></p><p><img src="https://s2.loli.net/2023/01/04/vSZ7y2fYiwIphgq.png" alt="esp串口2.png"></p><p>这位博主很厉害，在之前学习蓝牙协议栈的时候也是跟着这位博主学的，</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://wlink.blog.csdn.net/article/details/123952643">(15条消息) 一篇文章足够你学习ESP32，提供史上最全的ESP32教程(驱动/蓝牙/Wi-Fi/LVGL/Arduino…)_Wireless_Link的博客-CSDN博客_esp32</a></p></div>]]></content>
      
      
      
        <tags>
            
            <tag> ESP32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab logs</title>
      <link href="/2022/12/29/Matlab-logs/"/>
      <url>/2022/12/29/Matlab-logs/</url>
      
        <content type="html"><![CDATA[<p>​    MATLAB各功能使用的简单记录。</p><h2 id="lsqcurvefit参数拟合"><a href="#lsqcurvefit参数拟合" class="headerlink" title="lsqcurvefit参数拟合"></a>lsqcurvefit参数拟合</h2>]]></content>
      
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PID波形绘制及积分优化</title>
      <link href="/2022/11/26/PID%E6%B3%A2%E5%BD%A2%E7%BB%98%E5%88%B6%E5%8F%8A%E7%A7%AF%E5%88%86%E4%BC%98%E5%8C%96/"/>
      <url>/2022/11/26/PID%E6%B3%A2%E5%BD%A2%E7%BB%98%E5%88%B6%E5%8F%8A%E7%A7%AF%E5%88%86%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="MATLAB串口绘制波形"><a href="#MATLAB串口绘制波形" class="headerlink" title="MATLAB串口绘制波形"></a>MATLAB串口绘制波形</h2><p>​    对于<strong>MATLAB</strong>我也是久仰大名，最近安装了一个，感觉功能很丰富，也比较有意思。当然本人也是刚安装<strong>MABLAB</strong>不久，对其理解还是分浅薄，暂时也只是一些简单的使用。</p><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><h4 id="plot-二维绘图"><a href="#plot-二维绘图" class="headerlink" title="plot( ) 二维绘图"></a>plot( ) 二维绘图</h4><p><a href="https://ww2.mathworks.cn/help/matlab/ref/plot.html">二维线图 - MATLAB plot - MathWorks 中国</a></p><h4 id="axis-显示范围"><a href="#axis-显示范围" class="headerlink" title="axis( ) 显示范围"></a>axis( ) 显示范围</h4><p><a href="https://blog.csdn.net/youshijian99/article/details/80842218">(15条消息) Matlab axis函数_Geek猫的博客-CSDN博客_matlab axis</a></p><h4 id="grid-栅格"><a href="#grid-栅格" class="headerlink" title="grid 栅格"></a>grid 栅格</h4><p><a href="https://www.mathworks.com/help/matlab/ref/grid.html">Display or hide axes grid lines - MATLAB grid (mathworks.com)</a></p></div><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>新建函数文件——<strong>Serial.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Serial</span><span class="params">()</span>   %创建函数</span></span><br><span class="line">delete(instrfindall);   <span class="comment">%先关闭串口，否则可能导致出错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> x            <span class="comment">%全局变量，供串口中断函数使用</span></span><br><span class="line"><span class="keyword">global</span> t;<span class="comment">%全局变量，这里根据需要绘制图形的个人需要而设</span></span><br><span class="line"><span class="keyword">global</span> m;</span><br><span class="line"><span class="keyword">global</span> <span class="built_in">i</span>;</span><br><span class="line"></span><br><span class="line">t = [<span class="number">0</span>];      <span class="comment">%时间轴</span></span><br><span class="line">m = [<span class="number">0</span>];      <span class="comment">%数据轴</span></span><br><span class="line"><span class="built_in">i</span> = <span class="number">0</span>;        <span class="comment">%用于计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%串口参数配置</span></span><br><span class="line">x = serial(<span class="string">&#x27;com3&#x27;</span>);</span><br><span class="line">set(x,<span class="string">&#x27;BaudRate&#x27;</span>,<span class="number">115200</span>);</span><br><span class="line">set(x,<span class="string">&#x27;BytesAvailableFcnMode&#x27;</span>,<span class="string">&#x27;Terminator&#x27;</span>) <span class="comment">%ASCII触发，字符触发</span></span><br><span class="line">set(x,<span class="string">&#x27;Terminator&#x27;</span>,<span class="string">&#x27;CR/LF&#x27;</span>)         <span class="comment">%接收到\r\n后触发中断</span></span><br><span class="line">x.BytesAvailableFcn = @Callback  <span class="comment">%定义中断响应函数对象，类似于中断函数名</span></span><br><span class="line">fopen(x);</span><br><span class="line">pause</span><br><span class="line">fclose(x);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另建回调函数文件<strong>Callback.m</strong></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Callback</span><span class="params">(obj,event)</span>   %创建中断服务函数，绘制图像</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> t; <span class="comment">%时间</span></span><br><span class="line"><span class="keyword">global</span> m; <span class="comment">%纵坐标</span></span><br><span class="line"><span class="keyword">global</span> <span class="built_in">i</span>; <span class="comment">%时间变化值</span></span><br><span class="line"></span><br><span class="line">    out = fscanf(obj);</span><br><span class="line">    data = str2num(out)<span class="comment">%将接收到的字符转换为数值</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">%%----------------------以下根据需要自行编写-------------------------------</span></span><br><span class="line">    t = [t <span class="built_in">i</span>];</span><br><span class="line">    m = [m data];</span><br><span class="line">    <span class="built_in">plot</span>(t,m)</span><br><span class="line">    xlabel(<span class="string">&#x27;t&#x27;</span>);</span><br><span class="line">    ylabel(<span class="string">&#x27;data&#x27;</span>);</span><br><span class="line">    axis([<span class="built_in">i</span><span class="number">-50</span> <span class="built_in">i</span>+<span class="number">50</span> <span class="number">0</span> <span class="number">1000</span>]);</span><br><span class="line">    grid on;</span><br><span class="line">    <span class="built_in">i</span>=<span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="样式预览"><a href="#样式预览" class="headerlink" title="样式预览"></a>样式预览</h3><p>可以参考下文。</p><h2 id="积分优化"><a href="#积分优化" class="headerlink" title="积分优化"></a>积分优化</h2><h3 id="梯形积分PID"><a href="#梯形积分PID" class="headerlink" title="梯形积分PID"></a>梯形积分PID</h3><p>​    从微积分的角度来说，当微分到无限小时，矩形积分与梯形积分是没有区别的。但是实际上采样时间不可能无穷小，采样周期越大，偏差就越大。而梯形积分则是更加接近实际曲线，所以用梯形积分可以得到更高的精度。</p><script type="math/tex; mode=display">\int _0^t e(t) \mathrm{d} t = \sum_{i=0}^t \frac{e(i) + e(i-1)}{2}</script><h3 id="积分分离PID"><a href="#积分分离PID" class="headerlink" title="积分分离PID"></a>积分分离PID</h3><p>在普通的PID控制算法中，由于积分系数是常数，所以在整个控制过程中，积分增量不变。而系统对积分项的要求是：<emp>系统偏差大时积分减弱甚至全无，偏差小时积 分加强。</emp>积分系数大了会产生超调，小了又不能消除静差。变速积分PID可以根据<strong>系统偏差大小</strong>改变积分的速度。<br>    在普通的PID控制算法中，引入积分环节目的主要是为了消除静差。<emp>但在过程的启动、结束或大幅度增减设定时，短时间内系统输出有很大的偏差，</emp>会造成PID运算的积分积累，使控制量超过可能允许的最大动作范围对应的极限控制量，引起系统较大的超调，甚至引起较大的振荡。积分分离PID可以较好地解决这⼀问题。</p><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>​    思路是偏差值较大时，取消积分作用，以免超调量增大；而偏差值较小时，引入积分作用，以便消除静差，提⾼控制精度。<br>具体的实现步骤是：根据实际情况，设定⼀个阈值</p><ul><li>当偏差大于阈值时，消除积分仅用PD控制；</li><li>当偏差小于等于阈值时，引⼊积分采⽤PID控制。</li></ul><h4 id="积分项表达式"><a href="#积分项表达式" class="headerlink" title="积分项表达式"></a>积分项表达式</h4><script type="math/tex; mode=display">U_i(k) = \beta K_i\sum_{j=0}^{k-1}e(j)</script><p>其中<em>β</em>称为<strong>积分开关系数</strong></p><script type="math/tex; mode=display">\beta = \begin{cases}1, & |e(k)| \leq \varepsilon \\ 0, & |e(k)| > \varepsilon\end{cases}</script><p>由上述表述及公式我们可以知道，积分分离算法的效果其实与<strong>ε</strong>值的选取有很大的关系，所以ε值的选取是实现的难点</p><ul><li><p>ε值过大则达不到积分分离的效果</p></li><li><p>ε值过小则难以进入积分区。</p></li></ul><h3 id="变速积分PID"><a href="#变速积分PID" class="headerlink" title="变速积分PID"></a>变速积分PID</h3><h4 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h4><p>变速积分PID的基本思想是<emp>设法改变积分项的累加速度，使其与偏差大小相对应。</emp></p><ul><li>偏差越大，积分越慢；</li><li>偏差越小则越快。</li></ul><p>为此，设置系数<strong>f(e(k))</strong> ，它是<strong>e(k)</strong>的函数。当<strong>e(k)</strong>增大时， <strong>f</strong>减小，反之增大。</p><h4 id="积分项表达式-1"><a href="#积分项表达式-1" class="headerlink" title="积分项表达式"></a>积分项表达式</h4><script type="math/tex; mode=display">U_i(k) = K_i[\sum_{j=0}^{k-1} + f(e(k))*e(k) ]</script><p><strong>f(e(k))</strong>可根据具体情况设定，比较简单的设置为：</p><script type="math/tex; mode=display">f(e(k)) = \begin{cases}1, & |e(k)| \leq B \\\frac{A - |e(k)| + B}{A}, & B < |e(k)| \leq A + B \\0, & |e(k)| > A + B\end{cases}</script><p>由上述公式可知，<strong>f(e(k))</strong>的值在[0,1]区间变化。</p><ul><li><p>当偏差值<strong>e(k)</strong>大于分离区间<strong>A + B</strong>时，不对当前<strong>e(k)</strong>进行累加；</p></li><li><p>当偏差值<strong>e(k)</strong>小于<strong>B</strong>时，加入当前偏差<strong>e(k)</strong>进行累加；</p></li><li><p>介于<strong>B</strong>和<strong>A + B</strong>之间时，按一定函数关系变化。</p></li></ul><p>这种算法对A，B两个参数的要求不精确，参数整定较容易。 </p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">PID_t</span>&#123;</span></span><br><span class="line">    <span class="type">float</span> target;</span><br><span class="line">    <span class="type">float</span> actual;</span><br><span class="line">    <span class="type">float</span> dead_zone;</span><br><span class="line">    <span class="type">float</span> Kp, Ki, Kd;</span><br><span class="line">    <span class="type">float</span> last_error, pre_error, sum_error;</span><br><span class="line">    <span class="type">float</span> I_MAX;</span><br><span class="line">    <span class="type">float</span> P_out, I_out, D_out, D_last_out;</span><br><span class="line">    <span class="type">float</span> out_MAX, out, out_last;</span><br><span class="line">    <span class="type">float</span> I_up, I_low;</span><br><span class="line">    <span class="type">float</span> RC_DF;</span><br><span class="line">&#125;PID_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(ABS(p-&gt;pre_error) &lt; P-&gt;I_low)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;sum_error += (p-&gt;pre_error + p-&gt;last_error)/<span class="number">2</span>;</span><br><span class="line">    p-&gt;sum_error = limit(p-&gt;sum_error, p-&gt;I_MAX, -p-&gt;I_MAX);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ABS(p-&gt;pre_error) &lt; p-&gt;I_up)</span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;sum_error += ((ABS(p-&gt;pre_error) - p-&gt;I_low)/(p-&gt;I_up - p-&gt;I_low)) * ((p-&gt;last_error + p-&gt;pre_error)/<span class="number">2</span>);</span><br><span class="line">    p-&gt;sum_error = limit(p-&gt;sum_error, p-&gt;I_MAX, -p-&gt;I_MAX);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然定义的是<strong>I_up,I_low</strong>, 但是实际上这是与<strong>error</strong>相比较的</p><h2 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h2><p>Kp = 350<img src="https://s2.loli.net/2022/11/27/JFxsQNWeq4nuVEP.png" alt="Kp350.png"></p><p>ki = 120</p><p><img src="https://s2.loli.net/2022/11/27/zjaUvYJpVNBcbif.png" alt="Kp350Ki120.png"></p><p>Kd = 100</p><p><img src="https://s2.loli.net/2022/11/27/rZwV9psKjQ8toIJ.png" alt="Kd80.png"></p><p>Kd = 80, up = 80, low = 50</p><p><img src="https://s2.loli.net/2022/11/27/RsTAucIzvqlJtpk.png" alt="up80low50.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 控制方法 </tag>
            
            <tag> MATLAB </tag>
            
            <tag> PID </tag>
            
            <tag> USART </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>D-H参数法与机械臂正逆解</title>
      <link href="/2022/11/20/D-H%E5%8F%82%E6%95%B0%E6%B3%95%E6%9C%BA%E6%A2%B0%E8%87%82%E6%AD%A3%E9%80%86%E8%A7%A3/"/>
      <url>/2022/11/20/D-H%E5%8F%82%E6%95%B0%E6%B3%95%E6%9C%BA%E6%A2%B0%E8%87%82%E6%AD%A3%E9%80%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="D-H参数法"><a href="#D-H参数法" class="headerlink" title="D-H参数法"></a>D-H参数法</h1><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/maple_2014/article/details/105612912">(14条消息) 一文带你完全掌握机器人DH参数建模(详细步骤+实例+代码)_Marc Pony的博客-CSDN博客_dh建模</a></p></div><h2 id="坐标变换矩阵"><a href="#坐标变换矩阵" class="headerlink" title="坐标变换矩阵"></a>坐标变换矩阵</h2><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/weixin_44097528/article/details/122182393">(14条消息) 详解坐标变换矩阵_Akinaze的博客-CSDN博客_坐标变换矩阵</a></p></div><h2 id="D-H参数"><a href="#D-H参数" class="headerlink" title="D-H参数"></a>D-H参数</h2><p>​    一般来说，想要得到两个坐标系之间的变换矩阵，需要知道六个量。但是在使用<strong>D-H</strong>参数法时，需要按照特定方式建立坐标系，依托于这些<em>“前提约束”</em>，我们只需要4个参数便可以得出两坐标系之间的变换矩阵。</p><p>先要理解坐标系的<strong>建立规定</strong></p><blockquote><ul><li><p><strong>z轴</strong>的方向垂直于旋转面，即为<strong>转轴</strong>;</p></li><li><p><strong>x[i]</strong>方向的确定：同时垂直于z[i]与z[i-1];</p></li></ul></blockquote><p>依据这样的规定，可以发现：</p><blockquote><ul><li><p>z[i-1]<strong>同时垂直</strong>于x[i-1]与x[i];</p></li><li><p>x[i]<strong>同时垂直</strong>于z[i-1]与z[i];</p></li></ul></blockquote><p>由此，<strong>z[i-1]和x[i]</strong>便成了连接坐标系[i-1]和坐标系[i]的重要参考。再看四个参数的定义</p><div class="note blue icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><ul><li><strong>d[i]</strong>:坐标轴x[i-1]与坐标轴x[i]沿着<strong>z[i-1]</strong>的有向距离；</li><li><strong>θ[i]</strong>:坐标轴x[i-1]与坐标轴x[i]以<strong>z[i-1]</strong>为转轴的旋转角(逆时针，xi在前为正，或者说从x0转到x1的角度)；</li><li><strong>a[i]</strong>:坐标轴z[i-1]与坐标轴z[i]沿着<strong>x[i]</strong>的有向距离；</li><li><strong>α[i]</strong>:坐标轴z[i-1]与坐标轴z[i]以<strong>x[i]</strong>为转轴的旋转角；</li></ul></div><h2 id="正向求解"><a href="#正向求解" class="headerlink" title="正向求解"></a>正向求解</h2><p>在已知各关节角度的条件下，求出机械臂末端的坐标。</p><p>由<strong>D-H</strong>参数可以得到坐标系变换矩阵（将其记作<strong>$T_i$</strong>）：</p><script type="math/tex; mode=display">\begin{bmatrix}x_{i-1} \\ y_{i-1} \\ z_{i-1} \\ 1\end{bmatrix}= \begin{bmatrix} \cos{θ_i} & -\sin{θ_i} \cos{\alpha_i} & \sin{θ_i}\sin{\alpha_i} & a_i\cos{θ_i} \\\sin{θ_i} & \cos{θ_i} \cos{\alpha_i} & -\cos{θ_i}\sin{\alpha_i} & a_i\sin{θ_i} \\ 0 & \sin{\alpha_i} & \cos{\alpha_i} & d_i \\ 0 & 0 & 0 & 1\end{bmatrix}\begin{bmatrix}x_{i} \\ y_{i} \\z_{i} \\ 1\end{bmatrix}</script><p>​    代入<strong>i</strong>系的点$(x_i,y_i,z_i)$，左乘变换矩阵$T_i$，得到这个点在<strong>i-1</strong>系的坐标。由此，将末端坐标$C_n$不断左乘各变换矩阵，便可以递推出其在第一个坐标系的坐标$C_0$。</p><script type="math/tex; mode=display">C_0 = T_1 T_2 \cdots T_{n-1} T_n C_n</script><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>主要就是两个部分</p><blockquote><ul><li>矩阵<strong>Matrix</strong>的构建及其运算</li><li>机械臂<strong>robotic_arm</strong>的构建及基本功能</li></ul></blockquote><p>​    都是直接模拟手算过程，矩阵相乘的时间复杂度是<strong>O(mnk)</strong>，三次方量级的，好在矩阵规模都比较小。</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">Matrix_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">double</span> matrix[Matrix_MX][Matrix_MX];</span><br><span class="line">&#125;Matrix_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">robotic_arm_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> n;<span class="comment">//number of nodes</span></span><br><span class="line">    <span class="type">float</span> d[arm_MX_nodes],a[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> theta[arm_MX_nodes],alpha[arm_MX_nodes];</span><br><span class="line">    Matrix_t *T[arm_MX_nodes];</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">robotic_arm_t</span>;</span><br></pre></td></tr></table></figure><h4 id="机械臂初始化"><a href="#机械臂初始化" class="headerlink" title="机械臂初始化"></a>机械臂初始化</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param n the number of the nodes</span></span><br><span class="line"><span class="comment"> * @param d D-H parameters</span></span><br><span class="line"><span class="comment"> * @param a D-H parameters</span></span><br><span class="line"><span class="comment"> * @param theta D-H parameters</span></span><br><span class="line"><span class="comment"> * @param alpha D-H parameters</span></span><br><span class="line"><span class="comment"> * @return robotic_arm_t* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">robotic_arm_t</span> *<span class="title function_">robotic_arm_init</span><span class="params">(<span class="type">int</span> n, <span class="type">float</span> *d, <span class="type">float</span> *a, <span class="type">double</span> *theta, <span class="type">double</span> *alpha)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">robotic_arm_t</span> *arm;</span><br><span class="line">    arm = (<span class="type">robotic_arm_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">robotic_arm_t</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    arm-&gt;T[i] = (Matrix_t*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Matrix_t));</span><br><span class="line"></span><br><span class="line">    arm-&gt;n = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arm-&gt;d[i] = d[i];</span><br><span class="line">        arm-&gt;a[i] = a[i];</span><br><span class="line">        arm-&gt;alpha[i] = alpha[i];</span><br><span class="line">        arm-&gt;theta[i] = theta[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    get_Trans(arm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我这里构建的模型</p><p><img src="https://s2.loli.net/2022/11/23/FJehTzpxDroZPBg.jpg" alt="robotic_arm.jpg" style="zoom:50%;" /></p><div class="table-container"><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th></tr></thead><tbody><tr><td>d</td><td>0</td><td>1</td><td>0</td><td>0</td></tr><tr><td>θ</td><td>0</td><td>$\omega_0$</td><td>-$\omega_1$</td><td>$\frac{\Pi}{2} - \omega_2$</td></tr><tr><td>α</td><td>0</td><td>$-\frac{\Pi}{2}$</td><td>0</td><td>0</td></tr><tr><td>a</td><td>0</td><td>0</td><td>10</td><td>10</td></tr></tbody></table></div><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> test_d[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,test_a[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="type">double</span> test_theta[<span class="number">4</span>]=&#123;<span class="number">0</span>&#125;,test_alpha[<span class="number">4</span>]=&#123;<span class="number">0</span>,-PI/<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">test_arm = robotic_arm_init(<span class="number">3</span>,test_d,test_a,test_theta,test_alpha);</span><br></pre></td></tr></table></figure><p>$\omega$为关节（舵机）角度，以图中状态作为初始值，认为此时关节（舵机）角度为0。所以还有一个由关节角度到DH参数的转换函数，这个函数就是根据机械臂具体情况具体修改了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DH_update</span><span class="params">(<span class="type">robotic_arm_t</span> *arm, <span class="type">double</span> *servo)</span></span><br><span class="line">&#123;</span><br><span class="line">    arm-&gt;theta[<span class="number">1</span>] =  servo[<span class="number">0</span>];</span><br><span class="line">    arm-&gt;theta[<span class="number">2</span>] = -servo[<span class="number">1</span>];</span><br><span class="line">    arm-&gt;theta[<span class="number">3</span>] =  PI/<span class="number">2</span>-servo[<span class="number">2</span>];</span><br><span class="line">    get_Trans(arm);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="计算转移矩阵T"><a href="#计算转移矩阵T" class="headerlink" title="计算转移矩阵T"></a>计算转移矩阵T</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get the Transparent Matrix relay on the current arm state</span></span><br><span class="line"><span class="comment"> * @param arm </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_Trans</span><span class="params">(<span class="type">robotic_arm_t</span> *arm)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=arm-&gt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arm-&gt;T[i]-&gt;m=<span class="number">4</span>, arm-&gt;T[i]-&gt;n=<span class="number">4</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">0</span>] =  <span class="built_in">cos</span>(arm-&gt;theta[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">1</span>] = -<span class="built_in">sin</span>(arm-&gt;theta[i])*<span class="built_in">cos</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">2</span>] =  <span class="built_in">sin</span>(arm-&gt;theta[i])*<span class="built_in">sin</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">0</span>][<span class="number">3</span>] =  arm-&gt;a[i]*<span class="built_in">cos</span>(arm-&gt;theta[i]);</span><br><span class="line"></span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">0</span>] =  <span class="built_in">sin</span>(arm-&gt;theta[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">1</span>] =  <span class="built_in">cos</span>(arm-&gt;theta[i])*<span class="built_in">cos</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">2</span>] = -<span class="built_in">cos</span>(arm-&gt;theta[i])*<span class="built_in">sin</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">1</span>][<span class="number">3</span>] =  arm-&gt;a[i]*<span class="built_in">sin</span>(arm-&gt;theta[i]);</span><br><span class="line"></span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">0</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">1</span>] =  <span class="built_in">sin</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">2</span>] =  <span class="built_in">cos</span>(arm-&gt;alpha[i]);</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">2</span>][<span class="number">3</span>] =  arm-&gt;d[i];</span><br><span class="line"></span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">0</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">1</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">2</span>] =  <span class="number">0</span>;</span><br><span class="line">        arm-&gt;T[i]-&gt;matrix[<span class="number">3</span>][<span class="number">3</span>] =  <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="正向求解-1"><a href="#正向求解-1" class="headerlink" title="正向求解"></a>正向求解</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Get the coordinates of the point in the end coordinate system in the main coordinate system</span></span><br><span class="line"><span class="comment"> *        Suppose the main coordinate system&#x27;s number is 0</span></span><br><span class="line"><span class="comment"> *        得到末端坐标系中的一个点在主坐标系中的坐标,假设主坐标系编号为0</span></span><br><span class="line"><span class="comment"> * @param arm </span></span><br><span class="line"><span class="comment"> * @param point </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">foward_solve</span><span class="params">(<span class="type">robotic_arm_t</span> *arm, Matrix_t *point)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=arm-&gt;n; i&gt;<span class="number">0</span>; i--)</span><br><span class="line">    *point = multiply_matrix2(arm-&gt;T[i],point);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向求解"><a href="#逆向求解" class="headerlink" title="逆向求解"></a>逆向求解</h2><p>​    针对于我手上的机械臂，直接采用几何法分析。可是方程我解不出来😂，于是将其稍微变形，利用<strong>二分法</strong>也能迅速求得符合精度要求的解。</p><p><img src="https://s2.loli.net/2022/11/23/ksmLN1CvphgzIEj.jpg" alt="几何逆解.jpg" style="zoom:50%;" /></p><div class="note blue icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>具体二分的思路就是<strong>alpha</strong>越大，机械臂伸得越短，<strong>alpha</strong>越小，伸得越长。比较伸的长短是否到达</p></div><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Use the dichotomy method to find the angle of each joint according to the target coordinates </span></span><br><span class="line"><span class="comment"> *        用二分法根据目标坐标求出关节角度。（使用了几何法，仅适用于特定机械臂）</span></span><br><span class="line"><span class="comment"> *        根据末端机械手位姿求出最后一个关节的坐标(这一步还没实现)，由此计算其余关节角度。</span></span><br><span class="line"><span class="comment"> * @param arm 自己的机械臂，非通解</span></span><br><span class="line"><span class="comment"> * @param point 最后一个关节的坐标</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverse_solve_dichonomy</span><span class="params">(<span class="type">robotic_arm_t</span> *arm, Matrix_t point)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> angle0, angle1, angle2, alpha_l=<span class="number">0</span>, alpha_r=PI, alpha_mid, beta, theta, len_xy, x, y, z, l1, l2, d;</span><br><span class="line">    x = point.matrix[<span class="number">0</span>][<span class="number">0</span>], y = point.matrix[<span class="number">1</span>][<span class="number">0</span>], z = point.matrix[<span class="number">2</span>][<span class="number">0</span>] - arm-&gt;d[<span class="number">1</span>];</span><br><span class="line">    d = <span class="built_in">sqrt</span>(x*x + y*y + z*z);</span><br><span class="line">    l1 = arm-&gt;a[<span class="number">2</span>], l2 = arm-&gt;a[<span class="number">3</span>];</span><br><span class="line">    len_xy = <span class="built_in">sqrt</span>(x*x + y*y);</span><br><span class="line">    <span class="keyword">if</span>(len_xy == <span class="number">0</span>) &#123;theta = PI/<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;theta = <span class="built_in">atan</span>(z/len_xy);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(alpha_r-alpha_l &gt; <span class="number">0.00175</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        alpha_mid = (alpha_l+alpha_r)/<span class="number">2</span>;</span><br><span class="line">        beta = <span class="built_in">asin</span>(<span class="built_in">sin</span>(alpha_mid)*l1/l2);</span><br><span class="line">        <span class="keyword">if</span>(l1*<span class="built_in">cos</span>(alpha_mid) + l2*<span class="built_in">cos</span>(beta) &gt; d)</span><br><span class="line">        &#123;alpha_l = alpha_mid;&#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;alpha_r = alpha_mid;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span>) &#123;angle0 = PI/<span class="number">2</span>;&#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;angle0 = <span class="built_in">atan</span>(y/x);&#125;</span><br><span class="line">    angle1 = theta - alpha_mid;</span><br><span class="line">    angle2 = alpha_mid + beta + PI/<span class="number">2</span>;</span><br><span class="line">    arm-&gt;theta[<span class="number">1</span>] =  angle0;</span><br><span class="line">    arm-&gt;theta[<span class="number">2</span>] = -angle1;</span><br><span class="line">    arm-&gt;theta[<span class="number">3</span>] = PI/<span class="number">2</span> - angle2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我也尝试了使用MATLAB解方程，得出的结果十分的复杂，我觉得还是直接用二分法比较好。</p><p><img src="https://s2.loli.net/2022/11/24/EtFa9Bnypj4YwlZ.png" alt="MATLAB.png"></p><h1 id="粒子群优化算法"><a href="#粒子群优化算法" class="headerlink" title="粒子群优化算法"></a>粒子群优化算法</h1><p>​    在之前的逆解过程中，只能针对单个机械臂的几何特征单独求解，不具有泛用性。而且以我的数学水平也只能求解结构简单的机械臂🤣，当关节数增加甚至冗余时，无法直接用数学方法求解，或者说是多解。所以尝试采用<strong>粒子群优化算法(Particle Swarm Optimization, PSO)</strong>来实现一种通用的解法。</p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://zhuanlan.zhihu.com/p/346355572">粒子群优化算法(Particle Swarm Optimization, PSO)的详细解读 - 知乎 (zhihu.com)</a></p></div><p>这位大佬写得非常详细，我这里是使用c语言实现的，并将其用在了机械臂逆解上面。</p><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ul><li>粒子群初始化及各粒子随机初始化</li><li>开始迭代<ul><li>计算适应值</li><li>更新个体及群体最优解与最优适应值</li><li>更新w值，粒子速度，粒子位置</li></ul></li><li>结束迭代</li><li>返回寻得的最优解</li></ul><h3 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h3><p>看完上面的博客之后，想必这些定义是很容易理解的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param X current state 目前坐标（解）</span></span><br><span class="line"><span class="comment"> * @param V current velocity 目前速度</span></span><br><span class="line"><span class="comment"> * @param opt_X optimal solution of individual&#x27;s history 个体历史最优解</span></span><br><span class="line"><span class="comment"> * @param opt_A optimal adaptability of individual&#x27;s history 个体历史最优适应值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">bird_t</span>&#123;</span></span><br><span class="line">    <span class="type">double</span> X[arm_MX_nodes], V[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> opt_X[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> opt_A;</span><br><span class="line">&#125;<span class="type">bird_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief </span></span><br><span class="line"><span class="comment"> * @param N size of the bird population 种群规模</span></span><br><span class="line"><span class="comment"> * @param D 解的维度</span></span><br><span class="line"><span class="comment"> * @param K 迭代次数</span></span><br><span class="line"><span class="comment"> * @param W 惯性权重</span></span><br><span class="line"><span class="comment"> * @param C_ind 个体学习因子</span></span><br><span class="line"><span class="comment"> * @param C_pop 群体学习因子</span></span><br><span class="line"><span class="comment"> * @param opt_X_pop optimal solution of population&#x27;s history 群体历史最优解</span></span><br><span class="line"><span class="comment"> * @param opt_A_pop optimal adapatability of population&#x27;s history 群体历史最优解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">bird_population_t</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> N, D, K;</span><br><span class="line">    <span class="type">double</span> W, C_ind, C_pop;</span><br><span class="line">    <span class="type">double</span> opt_X_pop[arm_MX_nodes];</span><br><span class="line">    <span class="type">double</span> opt_A_pop;</span><br><span class="line">    <span class="type">bird_t</span> *bird[N_MX_SIZE];</span><br><span class="line"></span><br><span class="line">&#125;<span class="type">bird_population_t</span>;</span><br></pre></td></tr></table></figure><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>​    单个粒子的初始化，至于为什么要用 <em>‘bird’</em> 来命名呢，因为这个算法其实也算是一种仿生的思路，作者是受到鸟群觅食的启发发明了这个算法。我第一眼看到这个算法想到的就是遗传算法，其实感觉都是优化的搜索方法，不过相比于遗传算法此算法在求机械臂逆解的应用中更胜一筹，具体怎么个优势法还有待去研究研究。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 粒子随机初始化</span></span><br><span class="line"><span class="comment"> * 在这里面分配空间一定程度上也可以防止空间浪费</span></span><br><span class="line"><span class="comment"> * @param pop </span></span><br><span class="line"><span class="comment"> * @return bird_t* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bird_t</span> *<span class="title function_">bird_init</span><span class="params">(<span class="type">bird_population_t</span> *pop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">bird_t</span> *bird;</span><br><span class="line">    bird = (<span class="type">bird_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bird_t</span>));</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;pop-&gt;D; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bird-&gt;X[i] = PI*(rand()%<span class="number">180</span>)/<span class="number">180</span>;</span><br><span class="line">        bird-&gt;V[i] = PI*(rand()%<span class="number">20</span><span class="number">-10</span>)/<span class="number">180</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bird-&gt;opt_A = BADDEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bird;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 粒子群初始化</span></span><br><span class="line"><span class="comment"> * @param n </span></span><br><span class="line"><span class="comment"> * @param d </span></span><br><span class="line"><span class="comment"> * @param k </span></span><br><span class="line"><span class="comment"> * @param w </span></span><br><span class="line"><span class="comment"> * @param c_ind </span></span><br><span class="line"><span class="comment"> * @param c_pop </span></span><br><span class="line"><span class="comment"> * @return bird_population_t* </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">bird_population_t</span> *<span class="title function_">bird_population_init</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> d, <span class="type">int</span> k, <span class="type">double</span> w, <span class="type">double</span> c_ind, <span class="type">double</span> c_pop)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">bird_population_t</span> *bird_population;</span><br><span class="line">    bird_population = (<span class="type">bird_population_t</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">bird_population_t</span>));</span><br><span class="line"></span><br><span class="line">    bird_population-&gt;N = n, bird_population-&gt;D = d, bird_population-&gt;K = k;</span><br><span class="line">    bird_population-&gt;W = w, bird_population-&gt;C_ind = c_ind, bird_population-&gt;C_pop = c_pop;</span><br><span class="line"></span><br><span class="line">    srand((<span class="type">unsigned</span>)time( <span class="literal">NULL</span> ) );     </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bird_population-&gt;bird[i] = bird_init(bird_population);</span><br><span class="line">    &#125;</span><br><span class="line">    bird_population-&gt;opt_A_pop = BADDEST;</span><br><span class="line">    <span class="keyword">return</span> bird_population;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="迭代过程"><a href="#迭代过程" class="headerlink" title="迭代过程"></a>迭代过程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;bird_pop-&gt;K; i++)<span class="comment">//K</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;bird_pop-&gt;N;j++)<span class="comment">//N</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//计算适应值</span></span><br><span class="line">            Matrix_t *judge_point = point_init(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="type">double</span> ada=<span class="number">0</span>;<span class="comment">//适应值</span></span><br><span class="line">            DH_update(arm,bird_pop-&gt;bird[j]-&gt;X);</span><br><span class="line">            foward_solve(arm,judge_point);</span><br><span class="line">            ada += (point.matrix[<span class="number">0</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">0</span>][<span class="number">0</span>])*(point.matrix[<span class="number">0</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">            ada += (point.matrix[<span class="number">1</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">1</span>][<span class="number">0</span>])*(point.matrix[<span class="number">1</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">            ada += (point.matrix[<span class="number">2</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">2</span>][<span class="number">0</span>])*(point.matrix[<span class="number">2</span>][<span class="number">0</span>] - judge_point-&gt;matrix[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新个体与群体最优适应值与最优解</span></span><br><span class="line">            <span class="keyword">if</span>(ada &lt; bird_pop-&gt;bird[j]-&gt;opt_A)</span><br><span class="line">            &#123;</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;opt_A = ada;</span><br><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++)</span><br><span class="line">                &#123;bird_pop-&gt;bird[j]-&gt;opt_X[k] = bird_pop-&gt;bird[j]-&gt;X[k];&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ada &lt; bird_pop-&gt;opt_A_pop)</span><br><span class="line">            &#123;</span><br><span class="line">                bird_pop-&gt;opt_A_pop = ada;</span><br><span class="line">                <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++)</span><br><span class="line">                &#123;bird_pop-&gt;opt_X_pop[k] = bird_pop-&gt;bird[j]-&gt;X[k];&#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//更新w值，更新各维度速度与位置</span></span><br><span class="line">            w = W_MAX - (W_MAX - W_MIN)*((<span class="type">double</span>)i/bird_pop-&gt;K);</span><br><span class="line">            <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;V[k] = (w+(rand()/<span class="number">16384</span><span class="number">-1</span>)*<span class="number">0.15</span>)*(bird_pop-&gt;bird[j]-&gt;V[k]) + (rand()/<span class="number">16384</span>)*<span class="number">1.8</span>*(bird_pop-&gt;opt_X_pop[k] - bird_pop-&gt;bird[j]-&gt;X[k]) + (rand()/<span class="number">16384</span>)*<span class="number">1.6</span>*(bird_pop-&gt;bird[j]-&gt;opt_X[k] - bird_pop-&gt;bird[j]-&gt;X[k]);</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;V[k] = (bird_pop-&gt;bird[j]-&gt;V[k] &gt; V_MAX) ? V_MAX : bird_pop-&gt;bird[j]-&gt;V[k];</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;V[k] = (bird_pop-&gt;bird[j]-&gt;V[k] &lt; V_MIN) ? V_MIN : bird_pop-&gt;bird[j]-&gt;V[k];</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;X[k] += bird_pop-&gt;bird[j]-&gt;V[k]; </span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;X[k] = (bird_pop-&gt;bird[j]-&gt;X[k] &gt; X_MAX) ? X_MAX : bird_pop-&gt;bird[j]-&gt;X[k];</span><br><span class="line">                bird_pop-&gt;bird[j]-&gt;X[k] = (bird_pop-&gt;bird[j]-&gt;X[k] &lt; X_MIN) ? X_MIN : bird_pop-&gt;bird[j]-&gt;X[k];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//打印调试</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;    bird%d: \r\n        当前位置X: &quot;</span>,j);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;arm-&gt;n; m++) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%.3f|%.1f, &quot;</span>,bird_pop-&gt;bird[j]-&gt;X[m],rad_angle(bird_pop-&gt;bird[j]-&gt;X[m]));&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r\n        当前速度V: &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>; m&lt;arm-&gt;n; m++) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%.3f|%.1f, &quot;</span>,bird_pop-&gt;bird[j]-&gt;V[m],rad_angle(bird_pop-&gt;bird[j]-&gt;V[m]));&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">            <span class="built_in">free</span>(judge_point);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//打印调试</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 最适值: %.3f 惯性w: %.3f\r\n&quot;</span>,i,bird_pop-&gt;opt_A_pop,w);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;   角度X: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>; k &lt; arm-&gt;n; k++) &#123;<span class="built_in">printf</span>(<span class="string">&quot;%.2f|%.1f &quot;</span>,bird_pop-&gt;opt_X_pop[k],rad_angle(bird_pop-&gt;opt_X_pop[k]));&#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="一些小细节"><a href="#一些小细节" class="headerlink" title="一些小细节"></a>一些小细节</h3><p><img src="https://s2.loli.net/2022/11/23/2PGk5JcVnpuKwIq.png" alt="bug1.png"  /></p><p>​    可以看到，虽然我添加了时间随机数种子，但是生成的粒子仍然是全都一样的。这里要将<code>srand((insigned)time(NULL));</code>提前至初始化函数外。</p><p>​    </p><p><code>w = W_MAX - (W_MAX - W_MIN)*((double)i/bird_pop-&gt;K);</code> 在给<strong>w</strong>加权的时候别忘了<code>double</code>，不然后面算出来一直是0。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>感谢大家耐心看完了本篇博客，如果觉得不错的话欢迎分享给他人。由于本人水平有限，难免有错误的地方，也欢迎在评论区批评指正。完整的代码可以在我的代码仓库找到，后续也会将其移植到STM32上。在这里贴上主要代码方便随时查看，思路与代码相互对照也更容易理解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 运动学分析 </tag>
            
            <tag> 机械臂 </tag>
            
            <tag> D-H参数法 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 粒子群优化算法 </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIY平衡小车(上位机)</title>
      <link href="/2022/11/12/DIY%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6(%E4%B8%8A%E4%BD%8D%E6%9C%BA)/"/>
      <url>/2022/11/12/DIY%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6(%E4%B8%8A%E4%BD%8D%E6%9C%BA)/</url>
      
        <content type="html"><![CDATA[<h1 id="LattePanda"><a href="#LattePanda" class="headerlink" title="LattePanda"></a>LattePanda</h1><h2 id="前言与Ubuntu18-04安装"><a href="#前言与Ubuntu18-04安装" class="headerlink" title="前言与Ubuntu18.04安装"></a>前言与Ubuntu18.04安装</h2><p>​    原本用的是树莓派3B，官方的desktop版本只有22.04版的，装上之后奇卡无比，浏览器都会闪退。但是这样也能用，之后装上了ROS2，惨痛的发现在终端编译都会闪退，所以尝试换成18.04（感觉对性能要求会低一些），正好18.04也与厂家代码更适配，所以尝试装了server版本，因为没有图形化界面，需要自己联网，安装图形化界面，过程比较曲折。可以参考这一篇博客</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://zhuanlan.zhihu.com/p/372861457">树莓派4B安装Ubuntu18.04+ROS Melodic终极教程 - 知乎 (zhihu.com)</a></p></div><p>安装ROS的话我发现了一个神仙博主提供的一键安装命令，非常方便。</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/qq_27865227/article/details/120191557?ops_request_misc=%7B%22request%5Fid%22%3A%22166141462416782391868234%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&amp;request_id=166141462416782391868234&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-120191557-null-null.nonecase&amp;utm_term=如何一行代码&amp;spm=1018.2226.3001.4450">(15条消息) 如何一行代码安装ROS|2022最新版|一行代码安装ROS2|一行代码解决rosdep|一行代码配置多ROS环境_鱼香ROS的博客-CSDN博客_ros安装脚本</a></p></div><p>可是安装完了之后我悲惨的发现，就是树莓派性能不够，图形化界面装完了之后直接显示花屏。</p><p>​    所以我干脆一鼓作气买了个<strong>LattePanda2</strong>，性能据说约等于两个树莓派4B，八个树莓派3B。是X86架构的，自带Win10，还附带了一个Leonardo型号的Arduino，真不错。</p><h3 id="安装Ubuntu18-04"><a href="#安装Ubuntu18-04" class="headerlink" title="安装Ubuntu18.04"></a>安装Ubuntu18.04</h3><p>​    Tips：</p><ul><li>供电需要一个手机充电头和一个质量不错的数据线，至少2A。(之前树莓派先是随便找了一根线，结果一直显示供电不足)</li><li>用作启动盘的U盘质量也要好一点，不然会一直刻录失败（一开始用的送的U盘，结果折腾半天）</li></ul><p>可以参考这一篇文章（虽然是英文的，但是也可以看懂，而且说的很详细）</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation/blob/master/README_UBUNTU.md">LattePanda-Ubuntu18.04-Spinnaker-Installation/README_UBUNTU.md at master · imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation (github.com)</a></p></div><p>镜像下载链接</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://releases.ubuntu.com/18.04/">Ubuntu 18.04.6 LTS (Bionic Beaver)</a></p></div><p>​    接下来就是安装系统，具体可以参考上面的博客。有一点需要额外提一嘴，就是安装到后面发现一直是一个橙黄色背景，没有显示任何其他窗口，但是会发现能拖出鼠标，按键盘也有反应。其实是因为LattePanda内置一个屏幕，但是如果直接只用HDMI连显示屏的话这个是看不到的，相当于在左上角有一个看不见主屏幕，系统安装的操作窗口在那边。所以只能尝试用鼠标把那边的窗口拖过来，多试几次总能抓过来的😂。</p><h3 id="远程桌面"><a href="#远程桌面" class="headerlink" title="远程桌面"></a>远程桌面</h3><ul><li>使用软件：No machine</li></ul><p>​    在同一个局域网下，主机上的客户端可以搜索到Ubuntu，双击连接。接下来需要输入用户和密码，就是对应Ubuntu上的用户名和密码。我设置的用户名是<strong>Anya</strong>，计算机名是<strong>Bonder</strong>，所以输入 <strong>anya</strong> 和 <strong>密码</strong>。</p><emp>注意这里的用户名是不用输入大写的，区分了大小写反而会连接不上。</emp><h2 id="ROS1"><a href="#ROS1" class="headerlink" title="ROS1"></a>ROS1</h2><h3 id="安装melodic"><a href="#安装melodic" class="headerlink" title="安装melodic"></a>安装melodic</h3><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://github.com/imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation/blob/master/README_UBUNTU.md">LattePanda-Ubuntu18.04-Spinnaker-Installation/README_UBUNTU.md at master · imranmatin23/LattePanda-Ubuntu18.04-Spinnaker-Installation (github.com)</a></p></div><h3 id="工作空间配置"><a href="#工作空间配置" class="headerlink" title="工作空间配置"></a>工作空间配置</h3><p>按照准备工作手册配置，不过还是会碰到不少问题。</p><p>手册链接</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i></div><h4 id="还要先安装一大堆包"><a href="#还要先安装一大堆包" class="headerlink" title="还要先安装一大堆包"></a>还要先安装一大堆包</h4><ul><li>geographic-msgs</li><li>moveit-core</li><li>world-canvas-msgs</li><li>moveit-visual-tools</li><li>moveit-ros-move-group</li><li>moveit-ros-planning-interface</li></ul><h4 id="中间出现了一些问题"><a href="#中间出现了一些问题" class="headerlink" title="中间出现了一些问题"></a>中间出现了一些问题</h4><blockquote><p>E: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用)<br>E: 无法获取 dpkg 前端锁 (/var/lib/dpkg/lock-frontend)，是否有其他进程正占用它？</p></blockquote><p>可以参考这一篇文章</p><div class="note orange icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><a href="https://blog.csdn.net/zhang33565417/article/details/105164356">(17条消息) 解决 Ubuntu中 ‘E: 无法获得锁 /var/lib/dpkg/lock-frontend - open (11: 资源暂时不可用) ’ 问题_程序猿秃头之路的博客-CSDN博客</a></p></div><p>里面的一些命令的解释：</p><blockquote><p>无法定位软件包 ros-melodic-world-canvas-msgs</p></blockquote><p>这样的话干脆直接在<strong>Github</strong>下载，然后粘贴到 <em>/工作空间/src</em> 下面，重命名为 <strong>world_canvas_msgs</strong>。</p><p><a href="https://github.com/corot/world_canvas_msgs">corot/world_canvas_msgs: Messages and services for the semantic maps framework (github.com)</a></p><p>​    但是编译出来报错，不知道是不是包不对，其他地方也找不到这个包了。这个包实际上也不是 <strong>melodic</strong> 版本的，不知道这个商家咋搞的。</p><p>​    那这样一直卡着也不是个办法，所谓<strong>断臂求生</strong>，干脆直接把 <strong>/src</strong>里面的包都删掉，只留个驱动包，总算是成功编译。</p><blockquote><p>RVIZ不显示图形化界面</p></blockquote><p>​    不管我怎么试，RVIZ只是显示应用图标，不显示图形化界面。最后当我想不管这个的时候，我右键了一下这个软件图标，发现可以看到这个小窗口，而且是动态的。我静默片刻，赫然一惊，又如触电一般想起来LattePanda内置有一个虚拟屏幕，我颤抖着将鼠标拽向左上角的虚空，试探性的拖着什么，还真拖出来了个窗口……哈哈哈哈！</p><p>​    虽然我更改了主屏幕，但是我还是毅然决然的停用了这个内置屏幕，太害人了。</p><h4 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h4><pre><code>因为每次新打开一个终端就要source运行一下功能包的启动脚本，比较麻烦，所以干脆直接添加到环境变量当中，这样每次新开终端就会自动运行。</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;source ~/[工作空间]/devel/setup.bash&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><h4 id="启动雷达"><a href="#启动雷达" class="headerlink" title="启动雷达"></a>启动雷达</h4><p>运行<strong>launch文件</strong>，雷达总算是可以正常工作了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">roslaunch ydlidar_ros_driver X2.launch</span><br></pre></td></tr></table></figure><h3 id="订阅雷达报文"><a href="#订阅雷达报文" class="headerlink" title="订阅雷达报文"></a>订阅雷达报文</h3><pre><code>可以通过`rostopic type [topic]`查看话题消息类型，雷达返回的报文类型是`&lt;sensor_msgs::LaserScan&gt;`，话题是`scan`要注意的一点是在新终端使用`rostopic echo`的时候也要先`source [工作空间]/devel/setup.bash`，不然是会报错的。如果事先添加过环境变量的话就没有关系了。</code></pre><blockquote><p>ERROR:Cannot load message class foe [message]. Are your messages built?</p></blockquote><h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><ul><li>seq 是消息的顺序标识发布节点在发布消息时，会自动累加</li><li>stamp 是消息中与数据相关联的时间戳</li><li>frame_id 是消息中与数据相关联的参考系id</li><li>angle_min 起始角度（rad）</li><li>angle_max 结束角度（rad）</li><li>angle_increment 角度分辨率（rad）</li><li>time_increment 每个角度扫描时间</li><li>scan_time 扫描间隔</li><li>range_min 测量的最小距离</li><li>range_max 测量的最大距离</li><li>ranges 各个角度的测量距离</li><li>intensities 各个角度的强度值</li></ul><p><img src="https://s2.loli.net/2023/01/09/A53aZ4CfiVo6TRr.png" alt="雷达报文.png"></p><h4 id="报文解析"><a href="#报文解析" class="headerlink" title="报文解析"></a>报文解析</h4><pre><code>从0到n，均匀分为8组。假设雷达三角指向的方向为前方，那么这8组可以依次划分为 **back, back_right, right, front_right, front, front_left, left, back_left**</code></pre><h3 id="避障实现"><a href="#避障实现" class="headerlink" title="避障实现"></a>避障实现</h3><pre><code>大致知道雷达报文的意思之后，就可以写一个很简单的避障思路了。根据八个方向的**ranges[]** 判断是否离障碍物过近，过近则将`unsigned char warn`的相应位置一，最后只需要用串口传输一个 **8字节**的数就可以帮助32进行避障了。自己写呢主要是实现起来相对简单，而且自己用起来也比较方便，所以没有去研究使用更厉害的避障算法。不过还是先收集一个看起来很不错的博客</code></pre><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>]</p><p><a href="https://blog.csdn.net/ben_xiao_hai_123/article/details/119541384">激光雷达SLAM建图导航相关算法（gmapping DWA teb）及原理（Costmap）资料收录_kay880的博客-CSDN博客_gmapping 获取costmap</a></p></div><h3 id="串口通讯"><a href="#串口通讯" class="headerlink" title="串口通讯"></a>串口通讯</h3><pre><code>  可以先用cutecom测试一下串口功能，不过好像要设置为**CR/LF**才能正常通讯。**CR**表示回车，**LF**表示换行，也就是分别对应着**\r\n**，stm32上串口消息接收的结束标志是**\r\n**</code></pre><p>​    我这里使用的串口是<strong>/dev/ttyUSB0</strong></p><h4 id="自定义msg"><a href="#自定义msg" class="headerlink" title="自定义msg"></a>自定义msg</h4><blockquote><p>find_package(</p><p>)</p><p>catkin_package(</p><p>)</p></blockquote><p>​    find_package里面的是编译我们这个功能包时所依赖的包。而catkin_pckage里面的又是依赖的这些包所依赖的包。前者配置没问题而后者配置有问题时，可能导致编译无误但是运行时出错。所以又可以将这两个分别记为 <em>编译时依赖</em> 与 <em>运行时依赖</em>。</p><p>(按照autolabor官方手册配置)</p><p>功能包下新建msg目录，添加<strong>UART.msg</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> warn_msg</span><br></pre></td></tr></table></figure><p><strong>package.xml</strong>添加包依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>CmakeLists.txt</strong>添加msg配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">find_package(catkin REQUIRED COMPONENTS</span><br><span class="line">  roscpp</span><br><span class="line">  rospy</span><br><span class="line">  std_msgs</span><br><span class="line">  message_generation</span><br><span class="line">)</span><br><span class="line">## 配置 msg 源文件</span><br><span class="line">add_message_files(</span><br><span class="line">  FILES</span><br><span class="line">  Person.msg</span><br><span class="line">)</span><br><span class="line"># 生成消息时依赖于 std_msgs</span><br><span class="line">generate_messages(</span><br><span class="line">  DEPENDENCIES</span><br><span class="line">  std_msgs</span><br><span class="line">)</span><br><span class="line">#执行时依赖</span><br><span class="line">catkin_package(</span><br><span class="line">#  INCLUDE_DIRS include</span><br><span class="line">#  LIBRARIES demo02_talker_listener</span><br><span class="line">  CATKIN_DEPENDS roscpp rospy std_msgs message_runtime</span><br><span class="line">#  DEPENDS system_lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2023/01/10/4doaeZhf9W6TPlz.png" alt="debug_msg2.png"></p><p><img src="https://s2.loli.net/2023/01/10/MWpUkriCHITc7wK.png" alt="debug_msg1.png"></p><p>需要在<strong>.xml</strong>里添加<strong>std_msg</strong>包；<strong>CmakeLists</strong>里 <em>generate_messages</em> 重复定义，需要删掉。</p><h4 id="串口调用"><a href="#串口调用" class="headerlink" title="串口调用"></a>串口调用</h4><p>因为是<strong>melodic</strong>版本，有对应的<strong>serial</strong>包，所以配置起来就比在<strong>noetic</strong>上面要方便不少。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-melodic-serial</span><br></pre></td></tr></table></figure><h5 id="调用自定义头文件serial-head-h"><a href="#调用自定义头文件serial-head-h" class="headerlink" title="调用自定义头文件serial_head.h"></a>调用自定义头文件serial_head.h</h5><p>​    为了方便在各个文件里调用串口，干脆直接写一个封装串口各个功能的头文件，供其他源文件调用。</p><p>​    需要在<code>/功能包/include/功能包名</code>下创建<strong>头文件</strong>，为了方便在vscode编写代码，需要添加路径。</p><p><code>&quot;/home/用户/工作空间/src/功能包/include/**&quot;</code></p><p>​    源文件里调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;[包名]/[头文件].h&quot;</span></span></span><br></pre></td></tr></table></figure><p>​    配置<strong>CmakeLists</strong></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span></span><br><span class="line">  <span class="variable">$&#123;catkin_INCLUDE_DIRS&#125;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><p>​    串口包发送的数据需要是<code>string</code>类型。</p><p>​    如果直接发送固定的字符串倒是没有什么问题，可以直接与32通讯。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string msgs = <span class="string">&quot;123456\r\n&quot;</span>;</span><br><span class="line">ser.<span class="built_in">SendMsgs</span>(msgs);</span><br></pre></td></tr></table></figure><p>​    但是实际上需要将<code>u8</code>类型的数据转化为<code>string</code>类型然后发送。</p><p>​    但是不能直接像这样把数据转化为字符串类型。一开始的时候我就是这样做的，但是让ROS自己发送自己接收测试发现根本显示不出字符串，如果直接发送给32的话，32会直接停止运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string msgs;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> number=<span class="number">123</span>;</span><br><span class="line">msgs[<span class="number">0</span>] = number/<span class="number">100</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">number%=<span class="number">100</span>;</span><br><span class="line">msgs[<span class="number">1</span>] = number/<span class="number">10</span> + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">number%=<span class="number">10</span>;</span><br><span class="line">msgs[<span class="number">2</span>] = number + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">msgs[<span class="number">3</span>] = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">msgs[<span class="number">4</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">msgs[<span class="number">5</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">SendMsgs</span>(msgs);</span><br></pre></td></tr></table></figure><p>但是如果直接输入字符串就没有任何问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string msgs = <span class="string">&quot;123\r\n&quot;</span>;</span><br><span class="line"><span class="built_in">SendMsgs</span>(msgs);</span><br></pre></td></tr></table></figure><p>​    很奇怪的是如果将两者的元素都分别打印出来的话明明是没有任何区别的，包括字符串结束符。</p><p>​    不得不说用这玩意儿DEBUG是真心难受，卡得不得了。下次尽量要现在自己电脑上调好，直接移植过去。</p><p>​    最后实现通过串口发送周围障碍情况给stm32,32依此完成运动规划。终于不用再碰这个鬼东西了，┭┮﹏┭┮</p><p>​    当然如果想进一步发挥上位机功能，实现更高级的避障，建图等功能的话还是要碰┭┮﹏┭┮</p><h2 id="ROS2"><a href="#ROS2" class="headerlink" title="ROS2"></a>ROS2</h2><p>​    直接跟着教程走基本没什么问题，可以得到雷达的报文，话题名为<strong>scan</strong>。当然前提是板子不能太卡，我之前用的树莓派3B直接编译到一半闪退，卡的不行，压根用不了。</p><h2 id="通信协议"><a href="#通信协议" class="headerlink" title="通信协议"></a>通信协议</h2><h2 id="避障算法"><a href="#避障算法" class="headerlink" title="避障算法"></a>避障算法</h2><h2 id="cartographer"><a href="#cartographer" class="headerlink" title="cartographer"></a>cartographer</h2><p>参考教程</p><p><a href="https://www.ncnynl.com/archives/201810/2776.html">cartographer ros使用指南-安装 - 创客智造</a></p><p> <a href="https://blog.csdn.net/yqziqian2/article/details/118100338">最新cartographer安装：使用ubuntu20.04 + ROS Noetic_yqziqian2的博客-CSDN博客</a></p><p>怎么感觉一步一个坑呀，几乎每句命令都伴随着报错，我真的拴Q了😢</p><h3 id="git-clone失败"><a href="#git-clone失败" class="headerlink" title="git clone失败"></a>git clone失败</h3><blockquote><p>fatal: 无法访问 ‘<a href="https://github.com/google/protobuf.git/&#39;：GnuTLS">https://github.com/google/protobuf.git/&#39;：GnuTLS</a> recv error (-110): The TLS connection was non-properly terminated.</p></blockquote><p>明明有科学上网，而且git仓库的链接可以直接打开，为什么还是会显示无法访问呢?</p><p><a href="https://blog.csdn.net/qq_31267769/article/details/107017322">解决git克隆项目出现fatal无法访问‘https://github.com/xxx/xxx‘Unsupported proxy syntax in‘127.0.0.1:8118‘_我对算法一无所知的博客-CSDN博客</a></p><pre><code>通过这个博客可以解决（但是还是不太清楚为啥😢），虽然我list后没有显示作者说的两句话，但是运行之后确实可以正常运行了。而且我后来重新安装了一次cartography，发现好像新建的工作空间需要再这样操作一次</code></pre><h3 id="rosdep-初始化失败"><a href="#rosdep-初始化失败" class="headerlink" title="rosdep 初始化失败"></a>rosdep 初始化失败</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosdep init</span><br><span class="line">rosdep update</span><br></pre></td></tr></table></figure><blockquote><p>ERROR: cannot download default sources list from:<br><a href="https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list">https://raw.githubusercontent.com/ros/rosdistro/master/rosdep/sources.list.d/20-default.list</a><br>Website may be down.</p></blockquote><p>小鱼，我的超人😍（小鱼的一键安装ros也非常的nice）</p><p><a href="https://mp.weixin.qq.com/s/VGs8oWdhHH6XsHcx21lN4Q">https://mp.weixin.qq.com/s/VGs8oWdhHH6XsHcx21lN4Q</a></p><h3 id="不知道什么错误"><a href="#不知道什么错误" class="headerlink" title="不知道什么错误"></a>不知道什么错误</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosdepc install --from-paths src --ignore-src --rosdistro=noetic -y</span><br></pre></td></tr></table></figure><blockquote><p>ERROR: the following packages/stacks could not have their rosdep keys resolved<br>to system dependencies:<br>cartographer: [libabsl-dev] defined as “not available” for OS version [focal]</p></blockquote><p><a href="https://github.com/cartographer-project/cartographer_ros/issues/1726">Error while installing dependencies: libabsl-dev not available · Issue #1726 · cartographer-project/cartographer_ros · GitHub</a></p><pre><code>将`catkin_ws/src/cartography/package.xml`中第**46**行的`&lt;depend&gt;libabsl-dev&lt;/depend&gt;`删除</code></pre><h3 id="节点配置与使用"><a href="#节点配置与使用" class="headerlink" title="节点配置与使用"></a>节点配置与使用</h3><pre><code>安装完了包，Google官方的demo也能成功运行，接下来就是尝试使用自己的雷达数据进行见图。</code></pre><p><img src="/home/stonewu/图片/2023-01-18 00-00-27 的屏幕截图.png" alt="2023-01-18 00-00-27 的屏幕截图.png"></p><pre><code>在一开始，不太清楚该怎么表达**如何调用这个包**，找了一些教程，反正是失败了。可能还有一个原因，我使用`touch`和`vim`创建文件，创建出来的文件虽然后缀一样，但是图标不一样，不知道最后编译错误会不会与这个有关。还有一个教程，上来就说是因为cartography没有装好，建议重装。然后推荐了一个声称**百分百成功**的方法，我试了他的报错解决方法，报错更多了；然后又尝试他的**百分百成功**安装方法，结果第一个命令就给了我当头一棒。不得已，我重装了这个包，按照下面教程走一边后依然会报错。</code></pre><p><a href="https://www.guyuehome.com/25696">https://www.guyuehome.com/25696</a></p><p>报错的内容好像是与之前一样的，难道要重蹈覆辙吗，已经倒腾一天了。其实这个报错的重点不是下面的两段，而是上面的</p><blockquote><p>CMake Error: The following variables are used in this project, but they are set to NOTFOUND.(2021.02.22)</p></blockquote><p>缺少了Google-mock，解决方法的话如下</p><p><a href="https://blog.csdn.net/xiaokai1999/article/details/113937073">编译 cartographer_ros 出现 CMake Error: The following variables are used in this project, but they are.._锡城筱凯的博客-CSDN博客</a></p><p>成功编译之后尝试运行</p><blockquote><p>[FATAL] [1674008037.110688039]: F0118 10:13:57.000000 24832 lua_parameter_dictionary.cc:83] Check failed: status == 0 (2 vs. 0) [string “— Copyright 2016 The Cartographer Authors…”]:49: attempt to index global ‘SPARSE_POSE_GRAPH’ (a nil value)</p></blockquote><p><a href="https://blog.csdn.net/qq_45401419/article/details/109351198">cartographer attempt to index global ‘SPARSE_POSE_GRAPH‘ (a nil value)_憨憨2号的博客-CSDN博客</a></p><p>POSE_GRAPH.optimization_problem.huber_scale = 1e2</p><p>POSE_GRAPH.optimize_every_n_scans = 35</p><p>POSE_GRAPH.constraint_builder.min_score = 0.65</p><blockquote><p>[FATAL] [1674008655.614286059]: F0118 10:24:15.000000 29610 lua_parameter_dictionary.cc:399] Check failed: HasKey(key) Key ‘use_nav_sat’ not in dictionary:</p><p>[FATAL] [1674008934.975178862]: F0118 10:28:54.000000 31121 lua_parameter_dictionary.cc:399] Check failed: HasKey(key) Key ‘use_landmarks’ not in dictionary:</p><p>[FATAL] [1674009242.870707094]: F0118 10:34:02.000000 31954 lua_parameter_dictionary.cc:399] Check failed: HasKey(key) Key ‘publish_frame_projected_to_2d’ not in dictionary:</p></blockquote><pre><code>有很多像这样类似的报错，都是因为**lua**配置文件里缺少了相关参数，对照**revo_lds.lua**这个demo文件补齐即可。</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">catkin_make_isolated --install --use-ninja</span><br><span class="line">source install_isolated/setup.bash</span><br><span class="line">roslaunch cartographer_ros cartographer_demo_delta_lidar.launch</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/qleelq/article/details/112237663">cartographer建图参数配置详细说明_非晚非晚的博客-CSDN博客_cartographer参数配置</a></p><p>这个博客介绍了各个配置参数的含义</p><blockquote><p>  map_frame = “map”,—生成的地图坐标系<br>  tracking_frame = “base_link”,—跟踪的坐标系，可以是imu、小车、雷达<br>  published_frame = “base_link”,—cartographer正在发布pose的坐标，一般就是小车<br>  odom_frame = “odom”,—cartographer的里程计坐标系<br>  provide_odom_frame = false,— cartographer是否发布里程计坐标<br>  publish_frame_projected_to_2d = true,—是否无滚动、俯仰或z偏移<br>  use_odometry = false,—订阅里程计<br>  use_nav_sat = false,—订阅GPS<br>  use_landmarks = false,—订阅路标<br>  num_laser_scans = 1,—订阅雷达格式以及数量<br>  num_multi_echo_laser_scans = 0,— 订阅雷达格式以及数量<br>  num_subdivisions_per_laser_scan = 1,—分割扫描点云<br>  num_point_clouds = 0,— 订阅雷达格式以及数量<br>  lookup_transform_timeout_sec = 0.2,—tf2查找变换超时（s）<br>  submap_publish_period_sec = 0.3,—发布子图实时间间隔（s）<br>  pose_publish_period_sec = 5e-3,—发布pose时间间隔（s）<br>  trajectory_publish_period_sec = 30e-3,—发布轨迹标记间隔（s，这里为30ms）<br>  rangefinder_sampling_ratio = 1.,—以下5个参数为传感器采样比例<br>  odometry_sampling_ratio = 1.,<br>  fixed_frame_pose_sampling_ratio = 1.,<br>  imu_sampling_ratio = 1.,<br>  landmarks_sampling_ratio = 1.,</p></blockquote><p>[ WARN] [1674485462.194546450]: W0123 22:51:02.000000 40556 range_data_collator.cc:82] Dropped 1 earlier points.</p><h3 id="发布里程计信息"><a href="#发布里程计信息" class="headerlink" title="发布里程计信息"></a>发布里程计信息</h3><p><a href="https://zhuanlan.zhihu.com/p/158077889">https://zhuanlan.zhihu.com/p/158077889</a></p><h3 id="启动文件"><a href="#启动文件" class="headerlink" title="启动文件"></a>启动文件</h3><ul><li>hello_plus_ws</li><li>balance_tf里tf2P_pub_sub；</li><li>nav_demo里send_goal；</li><li>nav_demo里(amcl)</li><li>nav_demo里map_server</li><li>ydlidar_ws</li><li>ydlidar_ros_driver里X2.launch</li><li>ydlidar_ros_driver里anya_trans：里程计，目标点</li><li>cartography_ws</li><li>cartographer_ros cartographer_demo_delta_lidar.launch</li><li>No transform from [base_link] to frame [map]</li><li>No transform from [laser] to frame [map]</li></ul><h3 id="Cartographer保存地图"><a href="#Cartographer保存地图" class="headerlink" title="Cartographer保存地图"></a>Cartographer保存地图</h3><p><a href="https://blog.csdn.net/m0_37964922/article/details/90636892">cartographer 保存地图_菜鸟&amp;攻城狮的博客-CSDN博客</a></p><p>先进入工作空间下：source install_isolated/setup.bash</p><p>以下步骤保存地图：</p><p>完成轨迹, 不接受进一步的数据：</p><p>rosservice call /finish_trajectory 0</p><p>序列化保存其当前状态：</p><p>rosservice call /write_state “{filename: ‘${HOME}/Downloads/mymap.pbstream’}”</p><pre><code>将pbstream转换为pgm和yaml</code></pre><p>rosrun cartographer_ros cartographer_pbstream_to_ros_map -map_filestem=${HOME}/Downloads/mymap -pbstream_filename=${HOME}/Downloads/mymap.pbstream -resolution=0.05</p><p>地图文件所在的目录：与工作空间同目录下的Downloads目录下。</p><h2 id="anya-sub"><a href="#anya-sub" class="headerlink" title="anya_sub"></a>anya_sub</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> open_flag[pos_x][pos_y] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(p-&gt;next != <span class="literal">NULL</span>) &#123;p-&gt;next-&gt;last = p;&#125;</span><br></pre></td></tr></table></figure><h3 id="多机共享话题"><a href="#多机共享话题" class="headerlink" title="多机共享话题"></a>多机共享话题</h3><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code>车载计算机和地面站连接至同一个局域网，利用ifconfig查看各自的IP地址，在各自的`~/.bashrc`添加配置。需要在两个计算机里选择一个作为Master，这里我选择地面站。</code></pre><p>车载计算机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ROS_HOSTNAME=[车载计算机IP]</span><br><span class="line">export ROS_MASTER_URI=[MasterURI]</span><br></pre></td></tr></table></figure><p>  地面站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ROS_NAME=[地面站IP]</span><br><span class="line">export ROS_MASTER_URI=[MasterURI]</span><br></pre></td></tr></table></figure><pre><code>比方说地面站是**192.168.0.102**，车载计算机是**192.168.0.105**，所以这样添加</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">地面站</span><br><span class="line">export ROS_HOSTNAME=192.168.0.102</span><br><span class="line">export ROS_MASTER_URI=http://192.168.0.102:11311</span><br><span class="line">车载计算机</span><br><span class="line">export ROS_HOSTNAME=192.168.0.105</span><br><span class="line">export ROS_MASTER_URI=http://192.168.0.102:11311</span><br></pre></td></tr></table></figure><p>最后还要各自运行一下新配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bashrc</span><br></pre></td></tr></table></figure><blockquote><p>bash: export: “=”: 不是有效的标识符<br>bash: export: “192.168.0.102”: 不是有效的标识符</p></blockquote><p>出现这样的报错是因为习惯性的在等号两边加了空格，删掉即可。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code>只需要在选择的**Master**上运行roscore，两个节点分在两个机器上运行</code></pre><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br><span class="line">rosrun turtlesim turtle_teleop_key</span><br></pre></td></tr></table></figure><p>我的ros版本一个是<strong>noetic</strong>，一个是<strong>melodic</strong>，双向均可正常控制。</p><h3 id="给-home扩容"><a href="#给-home扩容" class="headerlink" title="给/home扩容"></a>给/home扩容</h3><pre><code>**cartography**和它的示例包内存太大了，当然也因为当时装双系统的时候没经验，给ubuntu分的空间太少了，总之现在就是home仅剩几兆内存了，示例包直接下载失败。大致有两种方法，一种是将空闲磁盘挂载到**home**下，但是这个需要新建一个文件夹作为新空间。我cartography装了半天才装上，谁知道如果直接移动过去又会不会出什么坑人的问题，所以只能选择第二种。第二种用到的工具是ubuntu下的**gparted**，不幸的是一般情况下只能将磁盘分区左右拓展，可是我的根目录左右并没有可用空闲空间，而且还有很多分区是上锁的，无法操作，但是也不是没有办法。</code></pre><ul><li><p>首先需要制作一个<strong>ubuntu启动盘</strong>，我这个是<strong>20.04</strong>，我的启动盘装的是<strong>22.04</strong>，这都没有什么关系。</p></li><li><p>在电脑开机时进入BIOS界面（我的是F2或FN+F2，反正我都按了）</p></li><li><p>将开机首选项设置为<strong>U盘</strong>，之后进入U盘里的系统</p></li><li><p>选择 <strong>try Ubuntu</strong>，进入试用系统。</p></li><li><p>打开<strong>gparted</strong>，在这种情况下，分区是没有上锁的，可以重新分配分区的大小，左右移动分区。将别的地方分一点空闲空间，一步步挪到<strong>home</strong>旁边，然后就可以拓展了。</p></li></ul><h3 id="TF配置与使用"><a href="#TF配置与使用" class="headerlink" title="TF配置与使用"></a>TF配置与使用</h3><p>先要安装一些包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-noetic-tf</span><br><span class="line">sudo apt-get install ros-noetic-geometry-msgs</span><br><span class="line">sudo apt-get install ros-noetic-tf2</span><br><span class="line">sudo apt-get install ros-noetic-tf2-ros</span><br><span class="line">sudo apt-get install ros-noetic-tf2-geometry-msgs</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/Savage888777/article/details/105311613">ROS TF原理和使用方法_月光下的向日葵的博客-CSDN博客_ros tf</a></p><p>这个比较的简洁，可惜的是编译出来报错，从报错信息也看不出来是因为啥，先放一放好了</p><p><a href="http://www.autolabor.com.cn/book/ROSTutorials/di-5-zhang-ji-qi-ren-dao-hang/51-tfzuo-biao-bian-huan/512-jing-tai-zuo-biao-bian-huan.html">5.1.2 静态坐标变换 · Autolabor-ROS机器人入门课程《ROS理论与实践》零基础教程</a></p><p><strong>奥特学园</strong>我的超人😍</p><p>最开始学ros的时候也是跟的这个教程，我感觉这里面肯定有TF的使用教程，果然找到了。</p><pre><code>基本上没啥问题，不过**5.1.2**里面给的**订阅方**的代码里面**46**行INFO那里少了个`%s`，补上即可。还有一点需要注意的是，程序写完了，在**CMakeLists**里面添加可执行文件和link library的时候，不能随意摆放代码块的位置，什么地方放什么配置注释里都有写。应该是因为我把它们放在了`catkin_package&#123;&#125;`和`include_directories&#123;&#125;`前面，虽然编译出来没有报错，但是运行的时候会显示找不到可执行文件。</code></pre><blockquote><p>[rosrun] Couldn’t find executable named tf2_pub below /home/stonewu/hello_plus_ws/src/balance_tf</p></blockquote><pre><code>将一切准备就绪后，启动最终的launch文件，rviz却依然显示不出东西。然后**tf2_sub**的终端的**INFO**显示*程序异常*后来发现，只要运行雷达的**launch**文件就会导致这个问题。打开雷达的**launch**文件，发现在最后添加了关于TF的配置。将其注释掉之后，就不会导致这个问题了。</code></pre><h3 id="键盘控制"><a href="#键盘控制" class="headerlink" title="键盘控制"></a>键盘控制</h3><h4 id="ros发布不同类型的消息"><a href="#ros发布不同类型的消息" class="headerlink" title="ros发布不同类型的消息"></a>ros发布不同类型的消息</h4><pre><code>我以前一直以为pub一个消息是比较随意的一件事，可是实际上还是有些不方便的。</code></pre><p><a href="https://www.guyuehome.com/14319#:~:text=%E9%A6%96%E5%85%88%E6%98%AF%E5%8F%91%E5%B8%83%E5%99%A8%E7%A8%8B%E5%BA%8F%201%3A%20%23include%20%22std_msgs%2FInt8.h%22%20%E4%BB%A3%E6%9B%BF%E4%BA%86%20%23include%20%22std_msgs%2FString.h%22%20%EF%BC%8E%E8%BF%99%E8%A1%A8%E6%98%8E%E4%BA%86%EF%BC%8C%E6%AF%8F%E4%B8%80%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%B6%88%E6%81%AF%E9%83%BD%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%B6%88%E6%81%AF%EF%BC%8C%E5%B0%B1%E9%A6%96%E5%85%88%E8%A6%81%E5%8C%85%E5%90%AB%E5%AE%83%E6%89%80%E5%9C%A8%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%8E%E5%83%8F,std_msgs%3A%3AString%20%EF%BC%8C%E5%AE%9A%E4%B9%89publisher%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%AE%83%E9%9C%80%E8%A6%81%E5%8F%91%E5%B8%83%E4%BB%80%E4%B9%88%E6%B6%88%E6%81%AF%E6%98%AF%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9A%E6%98%8E%E7%A1%AE%E7%9A%84%EF%BC%8C%E4%B9%8B%E5%89%8D%E6%98%AFros%E4%B8%AD%E7%9A%84string%E9%82%A3%E4%B9%88%E7%8E%B0%E5%9C%A8%E5%B0%B1%E8%87%AA%E7%84%B6%E6%8D%A2%E6%88%90ros%E4%B8%AD%E7%9A%84int8%E4%BA%86%203%3A%20std_msgs%3A%3AInt8%20msg%20%E6%9B%BF%E6%8D%A2%E4%BA%86%20std_msgs%3A%3AString%20msg">https://www.guyuehome.com/14319#:~:text=%E9%A6%96%E5%85%88%E6%98%AF%E5%8F%91%E5%B8%83%E5%99%A8%E7%A8%8B%E5%BA%8F%201%3A%20%23include%20%22std_msgs%2FInt8.h%22%20%E4%BB%A3%E6%9B%BF%E4%BA%86%20%23include%20%22std_msgs%2FString.h%22%20%EF%BC%8E%E8%BF%99%E8%A1%A8%E6%98%8E%E4%BA%86%EF%BC%8C%E6%AF%8F%E4%B8%80%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%B6%88%E6%81%AF%E9%83%BD%E6%9C%89%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%A6%81%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%9A%84%E6%B6%88%E6%81%AF%EF%BC%8C%E5%B0%B1%E9%A6%96%E5%85%88%E8%A6%81%E5%8C%85%E5%90%AB%E5%AE%83%E6%89%80%E5%9C%A8%E7%9A%84%E5%A4%B4%E6%96%87%E4%BB%B6%EF%BC%8E%E5%83%8F,std_msgs%3A%3AString%20%EF%BC%8C%E5%AE%9A%E4%B9%89publisher%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E5%AE%83%E9%9C%80%E8%A6%81%E5%8F%91%E5%B8%83%E4%BB%80%E4%B9%88%E6%B6%88%E6%81%AF%E6%98%AF%E9%9C%80%E8%A6%81%E6%8C%87%E5%AE%9A%E6%98%8E%E7%A1%AE%E7%9A%84%EF%BC%8C%E4%B9%8B%E5%89%8D%E6%98%AFros%E4%B8%AD%E7%9A%84string%E9%82%A3%E4%B9%88%E7%8E%B0%E5%9C%A8%E5%B0%B1%E8%87%AA%E7%84%B6%E6%8D%A2%E6%88%90ros%E4%B8%AD%E7%9A%84int8%E4%BA%86%203%3A%20std_msgs%3A%3AInt8%20msg%20%E6%9B%BF%E6%8D%A2%E4%BA%86%20std_msgs%3A%3AString%20msg</a>.</p><p>别忘了要引入消息类型的头文件，还要专门使用头文件里的<strong>typedef</strong>去定义变量。</p><p>运行后发现方向<strong>上下左右</strong>每个按键对应着三个ascii字符。</p><ul><li><p>☝：27 91 65</p></li><li><p>👇：27 91 66</p></li><li><p>右：27 91 67</p></li><li><p>左：27 91 68</p></li></ul><h2 id="Navigation——move-base"><a href="#Navigation——move-base" class="headerlink" title="Navigation——move_base"></a>Navigation——move_base</h2><h3 id="map-server"><a href="#map-server" class="headerlink" title="map_server"></a>map_server</h3><h4 id="简单测试"><a href="#简单测试" class="headerlink" title="简单测试"></a>简单测试</h4>]]></content>
      
      
      
        <tags>
            
            <tag> 平衡小车 </tag>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIY平衡小车</title>
      <link href="/2022/11/12/DIY%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6/"/>
      <url>/2022/11/12/DIY%E5%B9%B3%E8%A1%A1%E5%B0%8F%E8%BD%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="前期基本方案"><a href="#前期基本方案" class="headerlink" title="前期基本方案"></a>前期基本方案</h1><h2 id="预期效果"><a href="#预期效果" class="headerlink" title="预期效果"></a>预期效果</h2><h3 id="基本目标"><a href="#基本目标" class="headerlink" title="基本目标"></a>基本目标</h3><ul><li>根据指令实现精准的速度控制</li><li>自身坐标和姿态的解算</li><li>与上位机传输数据</li></ul><h3 id="更有意思的目标"><a href="#更有意思的目标" class="headerlink" title="更有意思的目标"></a>更有意思的目标</h3><ul><li>双轮平衡车</li><li>控制雷达平稳</li></ul><h2 id="电机驱动"><a href="#电机驱动" class="headerlink" title="电机驱动"></a>电机驱动</h2><p>​    电机使用<strong>12V</strong>供电，可以直接由电源模块供电。使用<strong>TB6612驱动模块</strong>可以满足两个电机的驱动需求。</p><h2 id="位姿测量"><a href="#位姿测量" class="headerlink" title="位姿测量"></a>位姿测量</h2><p>​    使用<strong>MPU6050</strong>可以获取角速度和加速度值（但是之前试用的时候发现其自带的库位姿解算会有不少时间的初始化延迟）。</p><p>​    MPU6050使用<strong>IIC</strong>通信，在获得了新的测量之后会在<strong>INT</strong>脚输出高电平，为了保证数据的即时性，将一个GPIO配置为外部中断，在中断函数里更新数据。</p><h2 id="轮速获取"><a href="#轮速获取" class="headerlink" title="轮速获取"></a>轮速获取</h2><p>​    将两个定时器配置为<strong>编码器接口模式</strong>，分别接收两个电机对应的编码器数据。我们使用的是AB双相输入的编码器，参考手册：</p><blockquote><p>如果计数器只在TI2的边沿计数，则置TIMx_SMCR寄存器中的SMS=001；如果只在TI1边沿计数，则置SMS=010；如果计数器同时在TI1和TI2边沿计数，则置SMS=011。  </p></blockquote><p>对寄存器的配置已经被封装在库函数<strong>TIM_EncoderInterfaceConfig（ ）</strong>里了，只需要选择配置<strong>模式3</strong>即可，在这个情况下，TI1和TI2分别对应TIMx的<strong>channel1</strong>和<strong>channel2</strong>的引脚，默认情况下TIM2就是<strong>PA0 PA1</strong>,TIM3是<strong>PA6 PA7</strong>。</p><p>也可以与MPU6050传感器数据融合。</p><h2 id="运动控制"><a href="#运动控制" class="headerlink" title="运动控制"></a>运动控制</h2><h3 id="直立环"><a href="#直立环" class="headerlink" title="直立环"></a>直立环</h3><p>直立环使小车保持直立，即保持在<strong>机械中值θ</strong>的位置，理想情况下是保持0°。</p><script type="math/tex; mode=display">$PWM_{balance} = KP * θ + KD * \Delta θ</script><h3 id="速度环"><a href="#速度环" class="headerlink" title="速度环"></a>速度环</h3><p>​    根据上位机发布的速度指令或者由<strong>位置环</strong>计算出的目标速度计算出输出力矩。</p><script type="math/tex; mode=display">PWM_{speed} = KP_s * Error + KD_s * \Delta Error</script><h3 id="速度环（平衡车）"><a href="#速度环（平衡车）" class="headerlink" title="速度环（平衡车）"></a>速度环（平衡车）</h3><p>​    但是由于安装等外界因素影响，小车以为的<strong>0°</strong>并非真正的平衡态，于是我们引入了<strong>速度环</strong>。当小车速度稳定时，便可以认为小车进入平衡态。速度环的输出可以看作是一个<strong>角度</strong>，作为直立环的输入，直立环便演变成了使小车保持一定角度，在保持角度的时候便会产生速度。</p><script type="math/tex; mode=display">balance \_ IN \_ speed = KP_S * Error + KD_S * \Delta Error</script><script type="math/tex; mode=display">PWM \_ balance \_ speed=KP * (θ + balance \_ IN \_ speed) + KD * \Delta θ</script><p>合并整理后便可得到</p><script type="math/tex; mode=display">PWM \_ balance \_ speed = KP * θ + KD * \Delta θ + KP（ KP_S * Error + KD_S * \Delta Error）</script><p>两者其实是线性相加的，直接将KP <em> KP_S合并为KP_S，KP </em> KD_S合并为KD_S，最终简化为</p><script type="math/tex; mode=display">PWM_{balance} = KP * \theta + KD * \Delta \theta</script><script type="math/tex; mode=display">PWM_{speed} = KP_s *Error + KD_s * \Delta Error</script><script type="math/tex; mode=display">PWM = PWM_{speed} + PWM_{balance}</script><h3 id="转向环"><a href="#转向环" class="headerlink" title="转向环"></a>转向环</h3><p>​    转向环比较简单，直接根据<strong>角度</strong>输出一个速度差，用<strong>PD</strong>控制即可。</p><h2 id="控制雷达平稳"><a href="#控制雷达平稳" class="headerlink" title="控制雷达平稳"></a>控制雷达平稳</h2><p>​    根据车子姿态控制舵机角度以尽可能保证雷达平稳。</p><h2 id="运动模型"><a href="#运动模型" class="headerlink" title="运动模型"></a>运动模型</h2><p>​    设：车子速度为<strong>v</strong> ； 两轮速度分别为<strong>v1，v2</strong> ；两轮间距为<strong>d</strong> ；速度瞬心为点 <strong>P</strong> ； 速度瞬心离两轮距离分别为 <strong>r1 , r2</strong> ；车身角速度为 <strong>w</strong> ； 车子运动轨迹半径为<strong>R</strong> ；<strong>逆时针</strong>转为正方向</p><p>​    可以算得：</p><script type="math/tex; mode=display">v =\frac{1}{2} ( v_1 + v_2 )</script><script type="math/tex; mode=display">\omega = \frac{v_2 - v_1}{d}</script><p>​    </p><script type="math/tex; mode=display">R = d\frac{v_1 + v_2}{2(v_2 - v_1)}</script><p>目前的想法是建立一个<strong>世界坐标系</strong>和一个<strong>车子坐标系</strong>。</p><ul><li>在<strong>车子坐标系</strong>中可以轻松地计算出<strong>下一时刻</strong>车子的位置和姿态 ；</li><li>而通过<strong>这一时刻</strong>车子的位置和姿态又可以得到此时车子坐标系与世界坐标系的<strong>变换矩阵</strong>；</li><li>利用<strong>变换矩阵</strong>可以将<strong>车子坐标系中</strong>下一时刻的位姿转换到<strong>世界坐标系</strong>。</li></ul><p>​    如此便可以完成状态递推。</p><script type="math/tex; mode=display">\Delta \theta_k = \frac{v_{k-1}}{R_{k-1}} \Delta t</script><script type="math/tex; mode=display">\Delta x_k = R_{k-1} (1 - \cos {\Delta \theta_k})</script><script type="math/tex; mode=display">\Delta y_k = R_{k-1} \sin{\Delta \theta_k}</script><script type="math/tex; mode=display">x_k = x_{k-1} + \Delta x_k \sin{\theta_{k-1}} + \Delta y_k \cos{\theta_{k-1}}</script><script type="math/tex; mode=display">y_k = y_{k-1} - \Delta x_k \cos{\theta_{k-1}} + \Delta y_k \sin{\theta_{k-1}}</script><script type="math/tex; mode=display">\theta_k = \theta_{k-1} + \Delta \theta_k</script><h1 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h1><h1 id="STM32代码"><a href="#STM32代码" class="headerlink" title="STM32代码"></a>STM32代码</h1><h2 id="运动控制调试"><a href="#运动控制调试" class="headerlink" title="运动控制调试"></a>运动控制调试</h2><p>​    调试里<strong>程计正解出位姿</strong>的时候，由于方向不一致，所以需要修改<strong>读取速度</strong>的极性。不过改完之后一定要记得把几个控制函数里的极性也做修改。比如角度控制环可能变成正反馈，速度环又可能变成逆反馈。</p><h2 id="串口调试"><a href="#串口调试" class="headerlink" title="串口调试"></a>串口调试</h2><p>​    DEBUG或者远程控制的时候选择使用串口外设。其中用到了三个串口，可以根据情况选择使用。</p><h3 id="接收中断问题"><a href="#接收中断问题" class="headerlink" title="接收中断问题"></a>接收中断问题</h3><p>​    程序主要由一个核心中断函数构成，在调试的过程中我发现由于这个中断函数的存在，串口通讯会经常出现通讯错误。显然是因为串口中断函数和这个核心中断函数冲突了，不过是中断优先级配置的问题。</p><p>​    可是我发现了这样一个问题，USART_IRQn配置为0x00,0x00，EXTI9_5_IRQn配置为0x00,0x01会严重影响串口数据接收的正确性，但是将后者配置为0x01,0x01就不会。<u>同样是优先级低于串口，为什么改变了后者的**抢断优先级**就会产生这样的区别呢？</u></p><p>​    当中断优先级配置完成后，若多个中断同时发生则先比较抢占优先级谁的值小谁先进行，若抢占优先级相同则比较子优先级谁的值小谁先进行，若两者都相同，就比较硬件中断编号（该编号由硬件自身决定），值得注意的是当一中断正在进行时又一中断发生若后者的抢占优先级的值比前者小则后者可以打断正在发生的中断执行后者的中断进程，需要注意 <emp>若后者的抢占优先级与前者相等但子优先级的值比前者小此时后者不能打断正在发生的中断, 必须等其完成后才能进行，</emp> 至于后者的优先级比正在发生的中断优先级低的情况，那就肯定是等待正在进行的中断完成后再进行。</p><p>​    所以说<em>“抢占”</em>一词，还是比较生动的。</p><p>​    <em>当然，如果直接用DMA的话就没这些问题了。</em></p><h3 id="USART2-DMA"><a href="#USART2-DMA" class="headerlink" title="USART2_DMA"></a>USART2_DMA</h3><p>​    在DMA初始化函数的最后，设置的<strong>TX</strong>与<strong>RX</strong>的开闭状态是不一样的，为什么呢？在理顺了具体的DMA收发过程之后便很容易理解了。</p><h4 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h4><blockquote><p>判断DMA是否处于发送完毕的空闲状态。flag=1，正在发送</p><p>设置发送数据的地址与大小</p><p>CMD使能开始发送</p><p>（可执行其他操作）</p><p>DMA发送完成中断</p><p>清除标志位（包括flag）</p><p>CMD失能关闭通道</p></blockquote><h4 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h4><blockquote><p>（DMA事先保持开启）</p><p>串口输入，DMA同时转运数据</p><p>传输完毕，串口空闲中断</p><p>清除标志位</p><p>CMD失能关闭DMA通道</p><p>获取DMA缓存中数据长度与数据</p><p>（切换接收缓冲器）</p><p>更新DMA剩余缓存（CNDTR）</p><p>CMD使能开启通道等待接收  </p></blockquote><p>sendbyte(u8 t)，串口会以对应的字符显示</p><h3 id="USART1-DMA"><a href="#USART1-DMA" class="headerlink" title="USART1_DMA"></a>USART1_DMA</h3><p>​    因为usart2的引脚可能要拿去做别的，给USART1也配个DMA。</p><p>给usart1配置DMA，想用这些控制代码编译的,这样只用改一个宏定义就可以选择配置或不配置DMA，但是出现了莫名其妙的错误，先不用了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> USART1_DMA 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>​    配置了DMA后，串口1的printf就不能用了，会卡死循环。不过可以根据自己的通讯需求写几个函数，用起来反而更加方便。</p><h4 id=""><a href="#" class="headerlink" title=" "></a> </h4><h5 id="sizeof"><a href="#sizeof" class="headerlink" title="sizeof( )"></a>sizeof( )</h5><p>返回的是不算结束符的字节数，而不是位数。如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">则</span><br><span class="line"><span class="comment">//printf_s(char *s, u8 newline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(s) == <span class="number">4</span>;</span><br></pre></td></tr></table></figure><p>​    我天真的以为这是字符串的大小，我是后来我发现这个size一直是4，我愕然，这其实是指针的大小。</p><h5 id="malloc-n"><a href="#malloc-n" class="headerlink" title="malloc(n)"></a>malloc(n)</h5><p>n也是分配的<strong>字节数</strong>，所以也常常会看到</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">something_t</span> *p = (something *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">something_t</span>));</span><br></pre></td></tr></table></figure><h5 id="sprintf"><a href="#sprintf" class="headerlink" title="sprintf( )"></a>sprintf( )</h5><p>会直接覆盖原字符串，而不是向末尾添加，如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(s,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">则</span><br><span class="line">s[<span class="number">0</span>]=<span class="string">&#x27;\r&#x27;</span>, s[<span class="number">1</span>]=<span class="string">&#x27;\n&#x27;</span>, s[<span class="number">2</span>]=<span class="string">&#x27;\0&#x27;</span>, s[<span class="number">3</span>]=<span class="string">&#x27;4&#x27;</span>;</span><br></pre></td></tr></table></figure><h5 id="strcat-amp-strncat"><a href="#strcat-amp-strncat" class="headerlink" title="strcat( ) &amp; strncat( )"></a>strcat( ) &amp; strncat( )</h5><h5 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其它位调用</span></span><br><span class="line"><span class="type">char</span> str[<span class="number">5</span>] = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">printf_s(str,<span class="number">1</span>);<span class="comment">//方法一</span></span><br><span class="line">printf_s(<span class="string">&quot;1234&quot;</span>,<span class="number">1</span>);<span class="comment">//方法二</span></span><br><span class="line"><span class="comment">//printf_s(char *s, u8 newline)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(s);</span><br><span class="line">    ......</span><br><span class="line">    <span class="built_in">strcat</span>(s,<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    <span class="built_in">sprintf</span>(s,<span class="string">&quot;1234\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    方法一可以正常运行，但是太麻烦；方法二会让32停止运行，个人认为是因为传递过去的是一个常量，不能够修改。但是size能正常返回，如果不尝试对数据进行修改，也可以正常打印。</p><p>​    想换行的话，如果<code>printf_s(&quot;1234\r\n&quot;)</code>，sizeof(s)返回的值依然是4，比较奇怪。为了调用起来方便，干脆直接新建一个字符串指针算了。</p><p><img src="C:\Users\Semitia\AppData\Roaming\Typora\typora-user-images\image-20230115153411523.png" alt="image-20230115153411523"></p><p>我在debug里面一步步进行就没有问题，结果全速运行的时候就出问题，我真的栓q了。</p><p><img src="C:\Users\Semitia\AppData\Roaming\Typora\typora-user-images\image-20230115154538616.png" alt="image-20230115154538616"></p><p>​    </p><p>​    发送字符串的时候计算len的时候别忘了多算一个，是留给结束符的空间。如果没有算上的话，串口打印出来会有一些乱码，加上之后就没有了，应该是这个原因吧。</p><h3 id="蓝牙SPP"><a href="#蓝牙SPP" class="headerlink" title="蓝牙SPP"></a>蓝牙SPP</h3><h4 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h4><p>手机发消息的时候别忘了加回车</p><h4 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h4><p>​    之前UART2，UART3都是没问题的，但是今天调试的时候发现插在UART3上面，连接到蓝牙的时候单片机就会停止运行。</p><p>​    DEBUG发现竟然卡在15_10的中断函数里面，查询手册发现UART3的RX是PB11，而这个代码正好把PB11配置为了超声波模块的中断引脚，中断函数里会等待超声波模块回复的高电平，导致一直在等待。一般这两个功能是没有一起使用的必要的，所以直接关闭其中一个即可。</p><p>​    但是还有一个问题，就是串口接收到的数据解析出现错误。结果是因为USART3_RX_BUF写成了复制的USART_RX_BUF没改过来😂。</p><h3 id="通讯协议"><a href="#通讯协议" class="headerlink" title="通讯协议"></a>通讯协议</h3><h4 id="USART1——STM32与ROS"><a href="#USART1——STM32与ROS" class="headerlink" title="USART1——STM32与ROS"></a>USART1——STM32与ROS</h4><p><strong>消息类型</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> WARN_MSG 1 <span class="comment">//warn</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPD_MSG  2 <span class="comment">//speed</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POS_MSG  3 <span class="comment">//position</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PARA_MSG 4 <span class="comment">// param</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DES_MSG  5 <span class="comment">//destination</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACK_MSG  6 <span class="comment">//ACK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INFO_MSG 7 <span class="comment">//</span></span></span><br></pre></td></tr></table></figure><h5 id="DES-MSG"><a href="#DES-MSG" class="headerlink" title="DES_MSG"></a>DES_MSG</h5><p>stm32发送目的地及当前位置</p><p><strong>示例：”5+1234-4321+1111-2222+3333”</strong></p><ul><li>帧头：5</li><li>目的地横坐标+1234：1.234m</li><li>目的地纵坐标-4321：4.321m</li><li>当前横坐标+1111：1111mm</li><li>当前纵坐标-2222：2222mm</li><li>当前朝向+3333：弧度制3.333(不会超过±π)</li><li>结束符：\r\n</li></ul><h5 id="POS-MSG"><a href="#POS-MSG" class="headerlink" title="POS_MSG"></a>POS_MSG</h5><h6 id="stm32发送当前坐标与朝向角度"><a href="#stm32发送当前坐标与朝向角度" class="headerlink" title="stm32发送当前坐标与朝向角度"></a>stm32发送当前坐标与朝向角度</h6><p><strong>示例</strong>：<strong>“3+0282+9999+0000”</strong></p><ul><li>帧头</li></ul><h6 id="ROS发送需要到达的位置"><a href="#ROS发送需要到达的位置" class="headerlink" title="ROS发送需要到达的位置"></a>ROS发送需要到达的位置</h6><h5 id="SPD-MSG"><a href="#SPD-MSG" class="headerlink" title="SPD_MSG"></a>SPD_MSG</h5><p>ROS发送小车运动指令</p><p><strong>运动消息类型</strong></p><ul><li>for_bac=1：前后</li><li>turn=2：转向</li></ul><p><strong>示例：”21+1325\r\n”</strong></p><ul><li>帧头：2</li><li>运动类型1：直线速度为13.25</li><li>value+1325：</li></ul><h5 id="ACK"><a href="#ACK" class="headerlink" title="ACK"></a>ACK</h5><p>ROS发送ACK表示已经接收DES_MSG</p><p><strong>示例：”6\r\n”</strong></p><ul><li>帧头：6</li><li>结束符：\r\n</li></ul><h4 id="USART3——STM32与蓝牙模块"><a href="#USART3——STM32与蓝牙模块" class="headerlink" title="USART3——STM32与蓝牙模块"></a>USART3——STM32与蓝牙模块</h4><p>帧头不能用简单的字符，因为蓝牙模块在初始化的时候会发送大量的信息。</p><h5 id="DES-MSG-1"><a href="#DES-MSG-1" class="headerlink" title="DES_MSG"></a>DES_MSG</h5><p><em>手机通过蓝牙SPP发送小车目的地</em></p><p>示例：<strong>66612344321\r\n</strong></p><ul><li>帧头：666</li><li>目的地横坐标：1234——1.234m</li><li>目的地纵坐标：4321——4.321m</li><li>结束符：\r\n</li></ul><h5 id="SPD-MSG-1"><a href="#SPD-MSG-1" class="headerlink" title="SPD_MSG"></a>SPD_MSG</h5><p>示例：<strong>“668 +1673 +1293\r\n”</strong></p><ul><li>帧头：668</li><li>间隔：<strong>‘ ‘</strong></li><li>直线速度+1673：16.73</li><li>角速度+1293：12.93</li><li>结束符：\r\n</li></ul><h5 id="PARAM-MSG"><a href="#PARAM-MSG" class="headerlink" title="PARAM_MSG"></a>PARAM_MSG</h5><p><strong>参数消息类型：</strong></p><ul><li>1：</li><li>2：</li><li>3：</li><li>4：</li><li>5:</li><li>6:</li><li>7：转向环KP，倍率3</li><li>8：转向环KI，倍率2</li></ul><p>示例：<strong>“667 8 +1000\r\n”</strong></p><ul><li><p>帧头：668</p></li><li><p>间隔：<strong>‘ ‘</strong></p></li><li><p>参数类型8：转向环KI</p></li><li><p>value+1000：KI=10</p></li><li></li></ul><h2 id="控制代码"><a href="#控制代码" class="headerlink" title="控制代码"></a>控制代码</h2><h3 id="-1"><a href="#-1" class="headerlink" title="#"></a>#</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 平衡小车 </tag>
            
            <tag> 运动学分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>卡尔曼滤波学习笔记</title>
      <link href="/2022/11/04/Kalman%20filter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/04/Kalman%20filter%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="卡尔曼滤波"><a href="#卡尔曼滤波" class="headerlink" title="卡尔曼滤波"></a>卡尔曼滤波</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    最近在学习卡尔曼滤波算法，这其中用到了一些数学和现代控制理论的知识。由于我在学习之前没有啥知识储备，在网上看了很多博客、花了很多时间之后依然是一种似懂非懂的感觉。终于找到了一些很棒的教程，感觉算是稍微理解了一些，整理了一些学习笔记，梳理思路，也方便日后查阅。</p><p><strong>教程链接</strong></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><ul><li><a href="https://www.bilibili.com/video/BV1ez4y1X7eR/?spm_id_from=333.788&amp;vd_source=0f383e93e945bca07eaef9a9ee5d9db3">【卡尔曼滤波器】1_递归算法_Recursive Processing_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1Rh41117MT/?spm_id_from=333.337.search-card.all.click&amp;vd_source=0f383e93e945bca07eaef9a9ee5d9db3">从放弃到精通！卡尔曼滤波从理论到实践~_哔哩哔哩_bilibili</a></li><li><a href="https://blog.csdn.net/Yemiekai/article/details/116372288">https://blog.csdn.net/Yemiekai/article/details/116372288</a></li></ul></div><h2 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h2><h3 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h3><blockquote><p>将<strong>方差、协方差</strong>在一个矩阵中表现出来，体现变量间的<strong>联动关系</strong></p></blockquote><p>假设有<strong>X,Y,Z</strong>三组数据，每组数据有<strong>n</strong>个</p><h4 id="方差："><a href="#方差：" class="headerlink" title="方差："></a>方差：</h4><script type="math/tex; mode=display">\sigma_x^2 = \frac{1}{n}\sum(x_i - \bar{x})^2</script><p>方差越大，数据波动越大</p><h4 id="协方差："><a href="#协方差：" class="headerlink" title="协方差："></a>协方差：</h4><script type="math/tex; mode=display">\sigma_x\sigma_y = \sigma_y\sigma_x = \frac{1}{n}\sum(x_i - \bar{}x)(y_i - \bar{y})</script><p>协方差越小，X,Y相关性越低</p><h4 id="协方差矩阵："><a href="#协方差矩阵：" class="headerlink" title="协方差矩阵："></a>协方差矩阵：</h4><script type="math/tex; mode=display">\begin{bmatrix}\sigma_x^2 & \sigma_x\sigma_y & \sigma_x\sigma_z \\ \sigma_y\sigma_x & \sigma_y^2 & \sigma_y\sigma_z \\ \sigma_z\sigma_x & \sigma_z\sigma_y & \sigma_z^2\\ \end{bmatrix}</script><h4 id="过渡矩阵"><a href="#过渡矩阵" class="headerlink" title="过渡矩阵"></a>过渡矩阵</h4><p>过渡矩阵<strong>a</strong>用以计算协方差矩阵<strong>P</strong>：</p><script type="math/tex; mode=display">P = \frac{1}{n}a^Ta</script><p>结合公式容易理解：(此处为3x3矩阵)</p><script type="math/tex; mode=display">a = \begin{bmatrix}x1 & y1 & z1 \\ x2 & y2 & z2 \\ x3 & y3 & z3 \\ \end{bmatrix} - \frac{1}{3}\begin{bmatrix}1 & 1 & 1 \\ 1 & 1 & 1 \\ 1 & 1 & 1 \\ \end{bmatrix}\begin{bmatrix}x1 & y1 & z1 \\ x2 & y2 & z2 \\ x3 & y3 & z3 \\ \end{bmatrix}</script><p>被减数即为<strong>原矩阵</strong>，而减数则为<strong>平均值矩阵</strong></p><h3 id="状态空间方程"><a href="#状态空间方程" class="headerlink" title="状态空间方程"></a>状态空间方程</h3><script type="math/tex; mode=display">\hat{X}_k = A\hat{X}_{k-1} + Bu_{k-1} + W_{k-1}</script><script type="math/tex; mode=display">Z_k = HX_k + V_k</script><p><strong>变量说明：</strong></p><ul><li><script type="math/tex">\hat{X}_k</script>：实际状态值</li><li><script type="math/tex">\hat{X}_{k-1}</script>：上一时刻状态值</li><li>$u_k-1$：控制输入量</li><li><em>A、H、B</em>：转换矩阵</li><li>$Z_k$：测量值</li><li>$W_{k-1}$：过程噪声</li><li>$V_k$：测量噪声</li></ul><p><strong>关于传递方程：</strong></p><p>​    如果我们掌握了一个物体的运动规律，那么这个时刻的状态可以通过上一个时刻的状态计算出来。但是也不能保证完全精准，所以添加了<strong>过程噪声——W</strong></p><p>​    举个例子——经典的阻尼弹簧振子模型：</p><p><img src="https://s2.loli.net/2022/11/05/njC8ubrIcYQRiF9.jpg" alt="阻尼弹簧.jpg"></p><p>弹簧恢复力 = kX，阻力 = Bv。将X的导数v记作$\dot{X}$，X的二阶导a记作$\ddot{X}$，便可以得到：</p><script type="math/tex; mode=display">m\ddot{X} + B\dot{X} + kX = F</script><p>取状态变量<strong>X1为位移</strong>，<strong>X2为速度</strong>，F记为控制输入<strong>u</strong>，根据之前公式可得：</p><script type="math/tex; mode=display">\dot{X_1} = X_2</script><script type="math/tex; mode=display">\dot{X_2} = \ddot{X} = \frac{1}{m}u - \frac{B}{m}X_2 - \frac{k}{m}X_1</script><p>写成矩阵的形式就是：</p><script type="math/tex; mode=display">\begin{bmatrix} \dot{X_1} \\ \dot{X_2} \end{bmatrix} = \begin{bmatrix} 0 & 1 \\ -\frac{k}{m} & -\frac{B}{m} \end{bmatrix}\begin{bmatrix} X_1 \\ X_2 \end{bmatrix} + \begin{bmatrix} 0 \\ \frac{1}{m} \end{bmatrix}u</script><p>对应着状态趋势矩阵与状态的关系：</p><script type="math/tex; mode=display">\dot{X_t} = AX_t + Bu_t</script><p>写成离散的形式就是：</p><script type="math/tex; mode=display">X_k = AX_{k-1} + Bu_{k}</script><p>当然最后加上不确定因素W</p><p><strong>关于测量方程：</strong></p><p>​    一般而言我们可能会习惯把<strong>待求量</strong>放在等式左边，已知量放在等式右边。但是在这里$Z_k$才是我们实际获得的数据。</p><p>​    关于转换矩阵H，一般我们无法直接测得需要的待测量，所以会测量其他量计算出待测量。举个例子</p><blockquote><p>激光测距仪测距：发射激光，根据返回用时计算距离。直接获得的物理量是 <strong>时间($Z_n$)</strong>，而我们想获得的 <strong>距离($X_n$)</strong>，于是有了转换矩阵 <strong>H($ \begin{bmatrix}\frac{2}{c}\end{bmatrix}$)</strong></p><script type="math/tex; mode=display">Z_n = \begin{bmatrix}\frac{2}{c}\end{bmatrix}X_n + V_n</script></blockquote><h2 id="整体介绍"><a href="#整体介绍" class="headerlink" title="整体介绍"></a>整体介绍</h2><h3 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h3><p><strong>先验估计方程：</strong></p><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1}</script><p><strong>先验误差协方差矩阵：</strong></p><script type="math/tex; mode=display">P_k^{-} = AP_{k-1}A^T + Q</script><h3 id="矫正"><a href="#矫正" class="headerlink" title="矫正"></a>矫正</h3><p><strong>卡尔曼增益：</strong></p><script type="math/tex; mode=display">K_k = \frac{P_k^- H^T}{HP_k^- H^T + R}</script><p><strong>后验估计：</strong></p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + K_k( Z_k - H\hat{X}_k^-)</script><p><strong>后验误差协方差矩阵：</strong></p><script type="math/tex; mode=display">P_k = ( I - K_kH)P_k^-</script><h3 id="变量说明"><a href="#变量说明" class="headerlink" title="变量说明"></a>变量说明</h3><ul><li><script type="math/tex">\hat{X}_k^-</script>：k时刻先验估计值——<strong>算出来的</strong></li><li>$\hat{X}_k$：最优估计值</li><li>$\hat{X}_{k-1}$：k-1时刻最优估计值</li><li>$u_k-1$：控制输入量</li><li>$K_k$：卡尔曼增益</li><li>$Z_k$：测量值——<strong>测出来的</strong></li><li>$W_{k-1}$：过程噪声</li><li>$V_k$：测量噪声</li><li>H：由状态量向测量量转换的矩阵</li></ul><p>变量<strong>带个帽子</strong>一般是<strong>估计值</strong>；变量右上角<strong>有个”-“</strong>一般是<strong>先验值</strong>。</p><h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><ol><li>由上一时刻<strong>最优估计值 $\hat{X}_{k-1}$</strong>计算<strong>先验估计值 $\hat{X}_k^-$</strong></li><li>获取<strong>测量值 $Z_k$</strong></li><li>由上一时刻<strong>误差协方差矩阵 $P_{k-1}$</strong>计算<strong>先验误差协方差矩阵 $P_K^-$</strong></li><li>计算<strong>卡尔曼增益$K_k$</strong></li><li>计算<strong>最优估计值<script type="math/tex">\hat{X}_k</script></strong></li><li>更新<strong>后验误差协方差矩阵 $P_k$</strong></li><li>不断更新迭代</li></ol><h2 id="公式说明与推导"><a href="#公式说明与推导" class="headerlink" title="公式说明与推导"></a>公式说明与推导</h2><h3 id="先验估计方程"><a href="#先验估计方程" class="headerlink" title="先验估计方程"></a>先验估计方程</h3><blockquote><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1}</script></blockquote><p>​    由上一时刻的<strong>最优估计值</strong>，根据运动模型推测这一时刻的状态值，即<strong>先验估计值</strong>。和<strong>传递方程</strong>类似。</p><h3 id="后验估计方程"><a href="#后验估计方程" class="headerlink" title="后验估计方程"></a>后验估计方程</h3><blockquote><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + K_k( Z_k - H\hat{X}_k^-)</script></blockquote><p>​    想要得到<strong>最优估计值</strong>，概括来说是根据数据的可靠性将<strong>测量值</strong>和<strong>计算值</strong>加权叠加起来，得到的就是<strong>后验估计值</strong>，也就是滤波过后得到的这一时刻的<strong>最优估计值</strong>。根据<strong>数据融合</strong>原理得到公式：</p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_k^- + G( H^-Z_k - \hat{X}_k^-)</script><p>但是我们经常看到的都是令 $G = K_kH$ 变换后的形式，即：</p><script type="math/tex; mode=display">\hat{X}_k = \hat{X}_{k}^- + K_k ( Z_k - H\hat{X}_{k}^- )</script><p>其中 $K_k$∈[0, $H^-$]</p><ul><li>当$K_k$ == 0 时，测量误差很大，信任计算出来的值，即 $\hat{X}_{k} == \hat{X}_{k}^-$;</li><li>当$K_k == H^-$时，无测量误差，信任测量值，即$\hat{X}_{k} == H^-Z_k$；</li></ul><h3 id="卡尔曼增益"><a href="#卡尔曼增益" class="headerlink" title="卡尔曼增益"></a>卡尔曼增益</h3><blockquote><script type="math/tex; mode=display">K_k = \frac{P_k^- H^T}{HP_k^- H^T + R}</script></blockquote><p>要计算卡尔曼增益，即求出使误差协方差最小的 $k_k$，在求出其关于$K_k$ 的表达式后再求导得到极值点。</p><h3 id="状态空间方程："><a href="#状态空间方程：" class="headerlink" title="状态空间方程："></a><strong>状态空间方程：</strong></h3><blockquote><script type="math/tex; mode=display">\hat{X}_k^- = A\hat{X}_{k-1} + Bu_{k-1} + W_{k-1}</script><script type="math/tex; mode=display">Z_k = HX_k + V_k</script></blockquote><p><img src="https://s2.loli.net/2022/11/03/hviNkZWEIeG39sw.jpg" alt="note1.jpg"></p><p><img src="https://s2.loli.net/2022/11/03/iwQRzfS7FlnPmZM.jpg" alt="note2.jpg"></p><h3 id="先后验误差协方差矩阵"><a href="#先后验误差协方差矩阵" class="headerlink" title="先后验误差协方差矩阵"></a>先后验误差协方差矩阵</h3><blockquote><script type="math/tex; mode=display">P_k^{-} = AP_{k-1}A^T + Q</script><script type="math/tex; mode=display">P_k = ( I - K_kH)P_k^-</script></blockquote><p><img src="https://s2.loli.net/2022/11/03/8bS1wKNJ3EoAOy2.jpg" alt="note.jpg"></p><h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><h4 id="kalman-filter"><a href="#kalman-filter" class="headerlink" title="kalman_filter"></a>kalman_filter</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">filter</span><span class="params">(Matrix_t Z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    count++;</span><br><span class="line">    pre_angle1 += Z.matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    pre_angle2 += Z.matrix[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    pre_angle3 = (pre_angle1 + pre_angle2)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    _X = <span class="built_in">mul_matrix</span>(F,X);</span><br><span class="line">    _P = <span class="built_in">add_matrix</span>(<span class="built_in">mul_matrix</span>(<span class="built_in">mul_matrix</span>(F, P), <span class="built_in">tran_matrix</span>(F)), Q);</span><br><span class="line">    K  = <span class="built_in">mul_matrix</span>(<span class="built_in">mul_matrix</span>(_P,<span class="built_in">tran_matrix</span>(H)), <span class="built_in">inv_matrix</span>(<span class="built_in">add_matrix</span>(<span class="built_in">mul_matrix</span>(<span class="built_in">mul_matrix</span>(H,_P),<span class="built_in">tran_matrix</span>(H)),R)));</span><br><span class="line">    X  = <span class="built_in">add_matrix</span>(_X,<span class="built_in">mul_matrix</span>(K,<span class="built_in">sub_matrix</span>(Z,<span class="built_in">mul_matrix</span>(H,_X) ) ) );</span><br><span class="line">    P  = <span class="built_in">mul_matrix</span>(<span class="built_in">sub_matrix</span>(<span class="built_in">get_I</span>(<span class="number">2</span>),<span class="built_in">mul_matrix</span>(K,H)),_P); </span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%d\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\t%.2f\n&quot;</span>,count, pre_angle1, pre_angle2, pre_angle3, X.matrix[<span class="number">0</span>][<span class="number">0</span>], X.matrix[<span class="number">1</span>][<span class="number">0</span>], Z.matrix[<span class="number">0</span>][<span class="number">0</span>], Z.matrix[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行一次<strong>filter( )</strong>就是进行了一次迭代。</p><p>这里使用<strong>fprintf</strong>将数据打印至excel文件，绘出波形。</p><p>当然，这里还用到了一些矩阵运算函数，我写在<strong>Matrix.h</strong>里面，下次想运算矩阵就直接调用啦，非常方便。不过更多的运算函数有待进一步的完善。</p><ul><li>add_matrix：矩阵加法</li><li>sub_matrix：矩阵减法</li><li>mul_matrix：矩阵乘法</li><li>inv_matrix：矩阵求逆</li><li>tran_matrix：矩阵转置</li></ul><h3 id="MPU6050滤波"><a href="#MPU6050滤波" class="headerlink" title="MPU6050滤波"></a>MPU6050滤波</h3><h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><script type="math/tex; mode=display">X = \begin{bmatrix}angle \\ bias\end{bmatrix}</script><p>​    选择<strong>angle</strong>和<strong>bias</strong>作为状态变量，其中angle为角度，bias为陀螺仪的零漂。bias就是在传感器静止时也会有的输出的角速度值，这个只是不确定的，而且会变化。但是即使我们随便给它一个初值，最终也会随着迭代次数的增加收敛到真实值附近</p><p><img src="https://s2.loli.net/2022/12/12/i3baZ5zcTdPnUXV.png" alt="零漂收敛.png"></p><h4 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h4><script type="math/tex; mode=display">X^-_k = \begin{bmatrix}angle \\bias\end{bmatrix}=\begin{bmatrix}1 & -dt \\0 & 1 \\\end{bmatrix}X_{k-1}+\begin{bmatrix}gyro*dt \\0\end{bmatrix}</script><h4 id="先验协方差矩阵"><a href="#先验协方差矩阵" class="headerlink" title="先验协方差矩阵"></a>先验协方差矩阵</h4><script type="math/tex; mode=display">P^-_k = \begin{bmatrix}1 & -dt \\ 0 & 1\\\end{bmatrix}P^-_{k-1}\begin{bmatrix}1 & 0 \\-dt & 1 \\\end{bmatrix}+\begin{bmatrix}Q_{angle} & 0 \\0 & Q_{bias} \\\end{bmatrix}</script><h4 id="测量方程"><a href="#测量方程" class="headerlink" title="测量方程"></a>测量方程</h4><p>传入的只有滤波之前的角度值，故有</p><script type="math/tex; mode=display">Z = HX + V \\H = \begin{bmatrix}1 & 0\end{bmatrix}</script><p>这里的原始角度值是由IMU的<strong>三轴加速度值</strong>直接解算而来。</p><p>后面的几个方程就没什么变化了。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>​    感谢大家耐心看完了本篇博客，欢迎大家分享；由于我自己也是初学者，对卡尔曼滤波的理解还不算深入，难免会有不完善之处，这篇文章作为一篇笔记由于大家分享，也欢迎大家批评指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kalman Filter </tag>
            
            <tag> 滤波器 </tag>
            
            <tag> 控制方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IIC &amp; PCA9685</title>
      <link href="/2022/11/01/%E8%88%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/01/%E8%88%B5%E6%9C%BA%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E8%B0%83%E8%AF%95%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>​    有些时候需要同时驱动多个舵机，需要为每一个舵机调制出对应的<strong>PWM</strong>脉冲信号；如果舵机很多的话，会占用主控的很多资源。幸运的是有这样一款模块，只需要<strong>两个GPIO口</strong>，便可以通过<strong>I^2^C通信协议</strong>控制<strong>16</strong>路舵机（事实上可以串联多个模块，控制更多舵机）。在这里记录一下其使用方法和代码实现方法。</p><h1 id="I-2-C通讯协议"><a href="#I-2-C通讯协议" class="headerlink" title="I^2^C通讯协议"></a>I^2^C通讯协议</h1><p>一篇介绍的很详细的文章：<a href="https://zhuanlan.zhihu.com/p/362287272">一文看懂I2C协议 - 知乎 (zhihu.com)</a></p><div class="note pink icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>这里附上较为权威的文件链接</p><ul><li><a href="https://semitia.top/upload_flies/TI_I2C_slva704.pdf">https://semitia.top/upload_flies/TI_I2C_slva704.pdf</a></li><li><a href="https://semitia.top/upload_flies/NXP_I2C_UM10204.pdf">https://semitia.top/upload_flies/NXP_I2C_UM10204.pdf</a></li><li><a href="https://semitia.top/upload_flies/ZLG_I2C.pdf">https://semitia.top/upload_flies/ZLG_I2C.pdf</a></li></ul></div><p>此篇笔记则是结合<strong>《TI_I2C_slva704》</strong>和<strong>代码</strong>简单记录一些基本功能。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    <strong>IIC</strong>使用两个接口<strong>(SCL和SDA)</strong>进行<strong>半双工通信</strong>。分为<strong>主机（Master)</strong>和<strong>从机（Slave device）</strong>，每个设备有自己特定的<strong>地址</strong>，一个设备有一个或多个寄存器储存数据，主机通过IIC总线对设备及其寄存器进行读写和配置。</p><h2 id="主机访问从机的一般流程"><a href="#主机访问从机的一般流程" class="headerlink" title="主机访问从机的一般流程"></a>主机访问从机的一般流程</h2><h3 id="发送数据："><a href="#发送数据：" class="headerlink" title="发送数据："></a>发送数据：</h3><ol><li>主机发送<strong>START</strong>信号和<strong>设备地址</strong>来指定一个设备</li><li>主机发送数据</li><li>主机发送<strong>STOP</strong>信号</li></ol><h3 id="接收数据："><a href="#接收数据：" class="headerlink" title="接收数据："></a>接收数据：</h3><ol><li>主机发送<strong>START</strong>信号和<strong>设备地址</strong>来指定一个设备</li><li>主机指定要读取的<strong>寄存器</strong></li><li>主机读取数据</li><li>主机发送<strong>STOP</strong>信号</li></ol><h2 id="START和STOP信号"><a href="#START和STOP信号" class="headerlink" title="START和STOP信号"></a>START和STOP信号</h2><ul><li><strong>STATRT</strong>：在<strong>SCL</strong>拉高的情况下，<strong>SDA</strong>电平由高变低，即<strong>下降沿</strong></li><li><strong>STOP</strong>：在<strong>SCL</strong>拉高的情况下，<strong>SDA</strong>电平由低变高，即<strong>上升沿</strong></li></ul><p><img src="https://s2.loli.net/2022/11/02/Rkjp2zrVq8NGIy9.png" alt="IIC_1.png"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><h4 id="START"><a href="#START" class="headerlink" title="START"></a>START</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();     </span><br><span class="line">IIC_SDA=<span class="number">1</span>;    </span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SDA=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><ul><li><code>SDA_OUT();</code>：将<strong>SDA</strong>端口设置为输出模式；在切换读写状态的时候，也要修改IO口配置</li><li><code>IIC_SCL=0;</code>：IIC总线接上拉电阻，故默认<strong>高电平</strong>状态为<strong>总线空闲</strong>状态；主机接下来要发送指令，所以要拉低电平，主机控制住总线。</li></ul><h4 id="STOP"><a href="#STOP" class="headerlink" title="STOP"></a>STOP</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">SDA_OUT();<span class="comment">//sdaÏßÊä³ö</span></span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">IIC_SDA=<span class="number">0</span>;<span class="comment">//STOP:when CLK is high DATA change form low to high</span></span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>; </span><br><span class="line">IIC_SDA=<span class="number">1</span>;<span class="comment">//·¢ËÍI2C×ÜÏß½áÊøÐÅºÅ</span></span><br><span class="line">delay_us(<span class="number">4</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ACK-NACK-有无应答"><a href="#ACK-NACK-有无应答" class="headerlink" title="ACK/NACK 有无应答"></a>ACK/NACK 有无应答</h2><p>​    在完成一个字节的信息传输后，<strong>接收方</strong>可以发送<strong>ACK</strong>以告知发送方数据被成功接收；也可以选择不发送。在接收方发送ACK之前，发送方必须释放SDA线；接收方<strong>拉低SDA</strong>以发送ACK。</p><p>​    倘若在ACK位SDA仍然为高电位，则认为是<strong>NACK——无应答</strong>，无应答的一些情况：</p><ul><li>接收方没有做好接收的准备</li><li>接收方无法理解接收到的数据</li><li>接收方无法再接收更多数据</li><li>主机作为接收方完成了数据接收</li></ul><p>​    在这样的规定下，如果出现了主机数据接收失败的情况的话该如何判定呢？是不是冲突了呢？或许主机可以通过编程判定接受失败，进而选择是否重新请求数据。</p><p><img src="https://s2.loli.net/2022/11/02/4eo2YpZhjNr7V5s.png" alt="IIC_2.png"></p><h2 id="WRITE写操作"><a href="#WRITE写操作" class="headerlink" title="WRITE写操作"></a>WRITE写操作</h2><ul><li><p>数据传输以<strong>一个字(8bits)</strong>节为单位，最先发送<strong>MSB</strong>；</p></li><li><p>在<strong>STOP和START</strong>信号外需保证<strong>SDA</strong>只在<strong>SCL</strong>为<strong>低电平</strong>时发生跳变；<strong>SCL高</strong>时保证<strong>SDA</strong>稳定以读取数据。</p></li></ul><p>注：</p><p><strong>MSB &amp; LSB</strong>：</p><blockquote><p>MSB stands for most significant bit, while LSB is least significant bit. In binary terms, the MSB is the bit that has the greatest effect on the number, and it is the left-most bit. For example, for a binary number 0011 0101, the Most Significant 4 bits would be 0011. The Least Significant 4 bits would be 0101.</p></blockquote><h3 id="协议流程"><a href="#协议流程" class="headerlink" title="协议流程"></a>协议流程</h3><ol><li>主机发送<strong>START</strong>信号</li><li>主机发送<strong>7bits设备地址</strong></li><li><strong>R/W</strong>位置0——写0，读1</li><li>等待应答</li><li>主机发送<strong>从设备寄存器地址</strong></li><li>等待应答</li><li>写入数据</li><li>等待应答</li><li>主机发送<strong>STOP</strong>信号，操作结束。</li></ol><p><img src="https://s2.loli.net/2022/11/02/zMwCgD3Qt1vx5cy.png" alt="IIC_3.png"></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>此处仅为发送一个字节的流程，完整流程请参考下方PCA9685实战代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Send_Byte</span><span class="params">(u8 txd)</span></span><br><span class="line">&#123;                        </span><br><span class="line">    u8 t;   </span><br><span class="line">SDA_OUT();     </span><br><span class="line">    IIC_SCL=<span class="number">0</span>;<span class="comment">//À­µÍÊ±ÖÓ¿ªÊ¼Êý¾Ý´«Êä</span></span><br><span class="line">    <span class="keyword">for</span>(t=<span class="number">0</span>;t&lt;<span class="number">8</span>;t++)</span><br><span class="line">    &#123;              </span><br><span class="line">        IIC_SDA=(txd&amp;<span class="number">0x80</span>)&gt;&gt;<span class="number">7</span>;</span><br><span class="line">        txd&lt;&lt;=<span class="number">1</span>;   </span><br><span class="line">delay_us(<span class="number">2</span>); </span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>); </span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="READ读操作"><a href="#READ读操作" class="headerlink" title="READ读操作"></a>READ读操作</h2><h3 id="协议流程-1"><a href="#协议流程-1" class="headerlink" title="协议流程"></a>协议流程</h3><ol><li>前两个字节与写操作相同</li><li>主机重复发送一次<strong>START</strong>信号</li><li>主机发送从设备地址</li><li><strong>R/W置</strong><span class='p red'>1</span>——读操作</li><li>等待应答</li><li>主机读取数据</li><li>主机<strong>不发送</strong>应答信号</li><li>主机发送<strong>STOP</strong>信号</li></ol><p><img src="https://s2.loli.net/2022/11/02/hQueywRLE3xf4v5.png" alt="IIC_4.png"></p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>同样是只读取一个字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">IIC_Read_Byte</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> ack)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i,receive=<span class="number">0</span>;</span><br><span class="line">SDA_IN();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++ )</span><br><span class="line">&#123;</span><br><span class="line">        IIC_SCL=<span class="number">0</span>; </span><br><span class="line">        delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">        receive&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(READ_SDA)receive++;   </span><br><span class="line">delay_us(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> (!ack)</span><br><span class="line">        IIC_NAck();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        IIC_Ack();</span><br><span class="line">    <span class="keyword">return</span> receive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="PCA9685芯片"><a href="#PCA9685芯片" class="headerlink" title="PCA9685芯片"></a>PCA9685芯片</h1><p>芯片手册：<a href="https://semitia.top/upload_flies/PCA9685.pdf">https://semitia.top/upload_flies/PCA9685.pdf</a></p><p>芯片手册的内容比较多，所以在这里只记录一些使用指导性相对更高的一些内容（主要参考第七小节）。</p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><h3 id="设备地址"><a href="#设备地址" class="headerlink" title="设备地址"></a>设备地址</h3><p><img src="https://s2.loli.net/2022/11/02/zYo4QDi6RUrBw1L.png" alt="IIC_5.png"></p><p>在默认情况下设备地址是<strong>0x40</strong>，如果算上最后<strong>R/W</strong>位的话就是<strong>0x80</strong>。</p><p>在模块上能够看到六个留空的焊点，可以选择把部分焊点焊上，设备的地址对应位就会被<strong>置一</strong>。比如把<strong>第0位</strong>焊上，地址就变为了<strong>1000001</strong>。</p><h3 id="寄存器地址"><a href="#寄存器地址" class="headerlink" title="寄存器地址"></a>寄存器地址</h3><p>这是部分寄存器总览表，一共有16个led。各个寄存器的地址也都很清楚地列了出来</p><p><img src="https://s2.loli.net/2022/11/02/mXtORuGvFCWUkNr.png" alt="IIC_6.png"></p><h2 id="部分寄存器介绍"><a href="#部分寄存器介绍" class="headerlink" title="部分寄存器介绍"></a>部分寄存器介绍</h2><h3 id="MODE1寄存器"><a href="#MODE1寄存器" class="headerlink" title="MODE1寄存器"></a>MODE1寄存器</h3><p><img src="https://s2.loli.net/2022/11/02/oJsCdm8rMcOBLFj.png" alt="IIC_7.png"></p><p>比较常用的是<strong>第四位</strong>，即<strong>SLEEP</strong>位，因为在读写其他寄存器的时候会需要将芯片休眠，待会在原码介绍中也会见到。</p><p><img src="https://s2.loli.net/2022/11/02/KA7VLulbwsmYzqn.png" alt="IIC_8.png"></p><h3 id="LED-ON-OFF-H-L"><a href="#LED-ON-OFF-H-L" class="headerlink" title="LED_ON_OFF_H_L"></a>LED_ON_OFF_H_L</h3><p>每个PWM(led)输出端口的配置对应四个寄存器</p><ul><li>LEDn_ON_H</li><li>LEDn_ON_L</li><li>LEDn_OFF_H</li><li>LED_OFF_L</li></ul><p>每个寄存器是<strong>8位</strong>寄存器，但是<strong>ON</strong>或<strong>OFF</strong>只会分别储存<strong>十二位</strong>的数据，也就是<em>L</em>存8位，<em>H</em>存4位</p><p><img src="https://s2.loli.net/2022/11/02/lFafpNvyibHqVjo.png" alt="IIC_9.png"></p><p>具体的寄存器数据和PWM波形的关系如下</p><blockquote><p>​    <strong>ON</strong>和<strong>OFF</strong>分别存储着范围<strong>0~4096</strong>的值(确实是4096而非4095)，我们把两个值记作<strong>cnt_on, cnt_off</strong>吧。有一个计数器从0计数到<strong>4095</strong>，我们把计数器的值记作<strong>CNT</strong>。</p><p>一般情况下，都是<code>cnt_on &lt; cnt_off</code>：</p><ul><li>当<code>CNT == cnt_on</code>时，PWM波<strong>由低变高</strong>；</li><li>当<code>CNT == cnt_off</code>时，PWM波<strong>由高变低</strong>；</li></ul><p>当<code>cnt_off &lt; cnt_on</code>时，在第一个周期内<code>CNT == cnt_off</code>不做变化。</p><p>可以看出，控制精度是<strong>1/4096</strong>周期。</p></blockquote><p>具体的PWM调制方法我们结合官方手册里面给出的两个例子就很容易理解了：</p><p><img src="https://s2.loli.net/2022/11/02/e9yZhwCiX5AImpc.png" alt="IIC_10.png"></p><p>（这里我感觉 <em>Fig 7</em> 图里的<strong>819</strong>是不是应该是<strong>410</strong>）</p><p><img src="https://s2.loli.net/2022/11/02/82lKZfsdSYL9EnW.png" alt="IIC_11.png"></p><h3 id="PRE-SCALE"><a href="#PRE-SCALE" class="headerlink" title="PRE_SCALE"></a>PRE_SCALE</h3><p><img src="https://s2.loli.net/2022/11/02/Y9Ch54OApUxLM8e.png" alt="IIC_12.png"></p><p>​    <strong>PRE_SCALE</strong>寄存器用以调制PWM频率。驱动舵机的话我们需要<strong>20ms</strong>的脉冲，频率为<strong>50Hz</strong>。</p><p>​    如果学习过STM32用定时器输出PWM的话应该很容易理解，只不过这里的<strong>自动重装载值</strong>固定为4096。</p><p>​    时钟给出的是<strong>25MHz</strong>的频率，如果我们设置<strong>n分频</strong>，那么<strong>计数器</strong>就会每过<strong>$\frac{n}{25000000}$</strong>秒计数一次，那么$T_n = \frac{4096n}{25000000}$秒就是一个周期。假如我们要<strong>50Hz</strong>的脉冲，那么周期应该是<strong>20ms</strong>，令$T_n == 0.02s$，解得n，那么分频系数设置为<strong>n-1</strong>即可。</p><p>​    为什么要减去一呢？因为不分频其实也就是<strong>一分频</strong>，但是默认<code>prescale value == 0</code>时是不分频。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="Write写数据"><a href="#Write写数据" class="headerlink" title="Write写数据"></a>Write写数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_write1</span><span class="params">(u8 adr,u8 data)</span></span><br><span class="line">&#123; </span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(adr);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(data);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/02/zMwCgD3Qt1vx5cy.png" alt="IIC_3.png"></p><p>这里贴上之前的流程图方便比对。</p><h3 id="Read读数据"><a href="#Read读数据" class="headerlink" title="Read读数据"></a>Read读数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">u8 <span class="title function_">pca_read1</span><span class="params">(u8 adr)</span></span><br><span class="line">&#123;</span><br><span class="line">u8 data;</span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(adr);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">IIC_Start();</span><br><span class="line"></span><br><span class="line">IIC_Send_Byte(pca_adr1|<span class="number">0x01</span>);</span><br><span class="line">IIC_Wait_Ack();</span><br><span class="line"></span><br><span class="line">data=IIC_Read_Byte(<span class="number">0</span>);</span><br><span class="line">IIC_Stop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/11/02/hQueywRLE3xf4v5.png" alt="IIC_4.png"></p><h3 id="设置分频系数"><a href="#设置分频系数" class="headerlink" title="设置分频系数"></a>设置分频系数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_setfreq1</span><span class="params">(<span class="type">float</span> freq)</span> </span><br><span class="line">&#123;</span><br><span class="line">u8 prescale,oldmode,newmode;</span><br><span class="line"><span class="type">double</span> prescaleval;</span><br><span class="line">freq *= <span class="number">0.92</span>; </span><br><span class="line">prescaleval = <span class="number">25000000</span>;</span><br><span class="line">prescaleval /= <span class="number">4096</span>;</span><br><span class="line">prescaleval /= freq;</span><br><span class="line">prescaleval -= <span class="number">1</span>;</span><br><span class="line">prescale =<span class="built_in">floor</span>(prescaleval + <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">oldmode = pca_read1(pca_mode1); <span class="comment">//获取之前mode寄存器配置状态</span></span><br><span class="line"></span><br><span class="line">newmode = (oldmode&amp;<span class="number">0x7F</span>) | <span class="number">0x10</span>; <span class="comment">// 睡眠模式</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, newmode); <span class="comment">// 进入睡眠</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_pre, prescale); <span class="comment">// 设置分频系数</span></span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, oldmode); <span class="comment">//写回原来</span></span><br><span class="line">delay_ms(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">pca_write1(pca_mode1, oldmode | <span class="number">0xa1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    注意手册里也多次强调，<span class='p red'>只有在设备进入睡眠模式之后才能修改分频系数</span></p><p>这里需要了解一下<strong>MODE1</strong>寄存器里的<emp>RESTART</emp>位</p><div class="note info modern"><p>在<strong>不停止PWM通道输出</strong>的情况下将设备设置为sleep模式，<strong>RESTART</strong>位会在一个PWM周期后被置1，<strong>LED</strong>寄存器里面的数据会被保存。想要重启，向<strong>RESTART</strong>位写1即可，此时该位会被自动<strong>置0</strong>。</p></div><p>​    当然，在这段代码中还设置了<strong>ALLCALL、AL</strong>位。</p><h3 id="调制PWM占空比"><a href="#调制PWM占空比" class="headerlink" title="调制PWM占空比"></a>调制PWM占空比</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pca_setpwm1</span><span class="params">(u8 num, u32 on, u32 off)</span> </span><br><span class="line">&#123;</span><br><span class="line">pca_write1(LED0_ON_L+<span class="number">4</span>*num,on);</span><br><span class="line">pca_write1(LED0_ON_H+<span class="number">4</span>*num,on&gt;&gt;<span class="number">8</span>);</span><br><span class="line">pca_write1(LED0_OFF_L+<span class="number">4</span>*num,off);</span><br><span class="line">pca_write1(LED0_OFF_H+<span class="number">4</span>*num,off&gt;&gt;<span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个“LED”有四个寄存器，所以<strong>第n个</strong>led地址为<strong>LED0</strong>地址加<strong>4n</strong>。</p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>感谢大家耐心看完了本篇博客，欢迎大家分享；完整的工程可以在我的<strong>GiHub</strong>仓库找到。由于本人水平有限，可能有不完善之处，欢迎大家批评指正。</p>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> IIC </tag>
            
            <tag> 舵机 </tag>
            
            <tag> PCA9685 </tag>
            
            <tag> 通讯协议 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有趣的位运算</title>
      <link href="/2022/10/29/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
      <url>/2022/10/29/%E6%9C%89%E8%B6%A3%E7%9A%84%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="有意思的操作"><a href="#有意思的操作" class="headerlink" title="有意思的操作"></a>有意思的操作</h1><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>位运算是算法题里比较特殊的一种类型，它们利用二进制位运算的特性进行一些奇妙的优化和计算。常用的位运算符号包括：“∧” 按位异或（取不同）、“&amp;” 按位与（取交）、“|” 按位或（取并）、“~” 取反、“&lt;&lt;” 算术左移和 “&gt;&gt;” 算术右移。</p><ul><li>n &amp; (n - 1) 可以去除 n 的位级表示中最低的那一位，例如对于二进制表示 11110100 ，减去 1 得到 11110011，这两个数按位与得到 11110000。</li><li>n &amp; (-n) 可以得到 n 的位级表示中最低的那一位，例如对于二进制表示 11110100，取负得到 00001100，这两个数按位与得到 00000100。</li></ul><h2 id="获取二进制数中1的个数"><a href="#获取二进制数中1的个数" class="headerlink" title="获取二进制数中1的个数"></a>获取二进制数中1的个数</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_contains</span><span class="params">(u32 s,<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(((s&gt;&gt;i) &amp; <span class="number">0x01</span>) == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_size0</span><span class="params">(u32 s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n += <span class="built_in">bitset_contains</span>(s,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>int bitset_contains(u32 s,int i)</code>就是判断s的<strong>第i位</strong>（从<strong>第0位</strong>开始计起）是否为1。</p><p><code>int bitset_size0(u32 s)</code>就是一位位看是不是1，是就<strong>计数加一</strong>。</p><p>最后效果就是<strong>统计s为1的位数</strong></p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bitset_size</span><span class="params">(u32 s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s = (s &amp; <span class="number">0x55555555</span>) + ((s&gt;&gt;<span class="number">1</span>) &amp; <span class="number">0x55555555</span>); <span class="comment">//01010101010101010101010101010101</span></span><br><span class="line">    s = (s &amp; <span class="number">0x33333333</span>) + ((s&gt;&gt;<span class="number">2</span>) &amp; <span class="number">0x33333333</span>); <span class="comment">//00110011001100110011001100110011</span></span><br><span class="line">    s = (s &amp; <span class="number">0x0f0f0f0f</span>) + ((s&gt;&gt;<span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>); <span class="comment">//00001111000011110000111100001111</span></span><br><span class="line">    s = (s &amp; <span class="number">0x00ff00ff</span>) + ((s&gt;&gt;<span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>); <span class="comment">//00000000111111110000000011111111</span></span><br><span class="line">    s = (s &amp; <span class="number">0x0000ffff</span>) + ((s&gt;&gt;<span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);<span class="comment">//00000000000000001111111111111111</span></span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    一般来说，看到这样的<strong>十六进制</strong>数就会不由自主地想把它们转换为<strong>二进制</strong>看看。转换之后呢就能稍微看出一些端倪了。😁</p><p>​    <code>0x55555555</code>将s分为<strong>两个一组</strong>，每一组两位数。其实就是==分别判断一组里的两位数是不是1==。</p><ul><li>都是1，则变为<strong>1+1=10</strong>；</li><li>只有一个，就变为<strong>01</strong>；</li><li>没有则为<strong>0</strong></li></ul><p>​    变换完了之后呢，储存的就是这一组里 <em>“1”</em> 的个数。</p><p>​    <code>0x33333333</code>则是将s分为<strong>四个一组</strong>，一组里同样是<strong>两个数</strong>，只不过一个数是<strong>两位</strong>。操作的结果呢就是<strong>将两个数各自两个位里1的个数</strong>加起来，即<strong>四个位里1的个数</strong>。</p><p>​    <code>0x0f0f0f0f</code>将s分为<strong>八个一组</strong>，统计<strong>八个位里1的个数</strong></p><p>​    <code>0x00ff00ff</code>将s分为<strong>十六个一组</strong>，统计<strong>十六位里1的个数</strong></p><p>​    <code>0x0000ffff</code>将整个32位的s看作一组，统计<strong>所有1的个数</strong></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>​    两种方法比较来看，明显是第一种方法简单易懂，也容易想到；但是从运算效率上来看，第二种远远高于第一种。</p><h1 id="遥控数据解析"><a href="#遥控数据解析" class="headerlink" title="遥控数据解析"></a>遥控数据解析</h1><p><img src="https://s2.loli.net/2022/10/29/7vaHiBuG1CXbV9m.png" alt="遥控协议.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RemoteReceive</span><span class="params">(<span class="keyword">volatile</span> <span class="type">uint8_t</span> *<span class="type">const</span> ptr_sbus_rx_buffer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ptr_sbus_rx_buffer == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    RC_Ctl.rc.ch0 = (ptr_sbus_rx_buffer[<span class="number">0</span>] | (ptr_sbus_rx_buffer[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>)) &amp;<span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch1 = (ptr_sbus_rx_buffer[<span class="number">1</span>] &gt;&gt; <span class="number">3</span>) | (ptr_sbus_rx_buffer[<span class="number">2</span>] &lt;&lt; <span class="number">5</span>) &amp; <span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch2 = (ptr_sbus_rx_buffer[<span class="number">2</span>] &gt;&gt; <span class="number">6</span>) | (ptr_sbus_rx_buffer[<span class="number">3</span>] &lt;&lt; <span class="number">2</span>) | (ptr_sbus_rx_buffer[<span class="number">4</span>] &lt;&lt; <span class="number">10</span>) &amp; <span class="number">0x07ff</span>;</span><br><span class="line">    RC_Ctl.rc.ch3 = (ptr_sbus_rx_buffer[<span class="number">4</span>] &gt;&gt; <span class="number">1</span>) | (ptr_sbus_rx_buffer[<span class="number">5</span>] &lt;&lt; <span class="number">7</span>) &amp; <span class="number">0x07ff</span>; </span><br><span class="line">    RC_Ctl.rc.s1 = (ptr_sbus_rx_buffer[<span class="number">5</span>] &gt;&gt; <span class="number">6</span>) &amp; <span class="number">0x0003</span>;</span><br><span class="line">    RC_Ctl.rc.s2 = (ptr_sbus_rx_buffer[<span class="number">5</span>] &gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0003</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括来说就是依照<strong>通信协议</strong>利用<strong>位移运算</strong>和<strong>或、与运算</strong>，将数据从<strong>ptr_sbus_rx_buffer</strong>剥离提取至<strong>RC_Ctl.rc.xx</strong>中。</p><ul><li>位移操作后，需要提取的数据在<strong>后11位(或后2位)</strong>，<strong>0x07ff</strong>换成二进制就是<strong>0000011111111111</strong>，过滤掉不需要的位数；<strong>0x0003</strong>同理</li><li><strong>ch0</strong>获取buffer[0]<strong>全部八位</strong>和buffer[1]<strong>低三位</strong></li><li><strong>ch1</strong>获取buffer[1]<strong>高五位</strong>和buffer[2]<strong>低六位</strong></li><li><strong>ch2</strong>获取buffer[2]<strong>高两位</strong>和buffer[3]<strong>全部八位</strong>和buffer[4]<strong>低一位</strong></li><li><strong>ch3</strong>获取buffer[4]<strong>高七位</strong>和buffer[5]<strong>低四位</strong></li><li><strong>s1</strong>获取buffer[5]<strong>高两位</strong></li><li><strong>s2</strong>获取buffer[5]<strong>第五第六位</strong></li></ul><p>不知道是不是搞反了，根据协议来看是<strong>s1</strong>获取buffer[5]<strong>第五第六位</strong>，<strong>s2</strong>获取buffer[5]<strong>高两位</strong></p><h1 id="位运算实现四则运算"><a href="#位运算实现四则运算" class="headerlink" title="位运算实现四则运算"></a>位运算实现四则运算</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    在平时手算的时候我们经常会<strong>列竖式</strong>，先不考虑进位，只看<strong>和</strong>和<strong>相加的两个数</strong>同位的数，把进位数写小一点记在横线上方。<strong>计算下一位的时候再加上上一位的进位。</strong></p><p>​    所以在程序中也是模拟这样一个思路：</p><ul><li>先不看进位，得到一个和；记下进位</li><li>进位在与和相加，不看进位得到一个新的和；同时也得到新的进位</li><li>不断迭代递推，直到不再产生新的进位</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 加法函数</span></span><br><span class="line"><span class="comment"> * @param ini_x 加数1</span></span><br><span class="line"><span class="comment"> * @param ini_y 加数2</span></span><br><span class="line"><span class="comment"> * @return 补码形式的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">u32 <span class="title">addition</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//不需要转换为补码</span></span><br><span class="line">    u32 x = ini_x, y = ini_y;</span><br><span class="line">    <span class="comment">//和，进位</span></span><br><span class="line">    u32 ans,carry;</span><br><span class="line">    ans = x ^ y;</span><br><span class="line">    carry = (x &amp; y) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//不断获取进位与不考虑进位的和，迭代相加，直至进位为0</span></span><br><span class="line">    <span class="keyword">while</span>(carry != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        u32 i = ans, j = carry;</span><br><span class="line">        ans = i ^ j;</span><br><span class="line">        carry = (i &amp; j) &lt;&lt; <span class="number">1</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DEBUG调试</span></span><br><span class="line">    <span class="comment">//printf(&quot;DE<span class="doctag">BUG:</span> %d add %d = %d\r\n&quot;,ini_x,ini_y,ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    可以发现，</p><ul><li>不看进位得到的和其实就是<strong>两数异或</strong>，即<code>ans = x ^ y;</code>；</li><li>进位即<strong>两数相与再左移一位</strong>，即<code>carry = (x &amp; y) &lt;&lt; 1;</code></li></ul><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>​    <strong>a-b</strong> 即 <strong>a+(-b)</strong></p><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    可以将被乘数不断加<strong>乘数次数</strong>的自己。但是这样效率不高。同样是模拟手算的思想，从<strong>乘数的最低位</strong>到<strong>最高位</strong>，在<strong>第i位</strong>，即给最后乘积贡献的值为</p><p>==被乘数 <em> 乘数[i] </em> (进制数)^(i-1)^==</p><p>​    在这个算法下不再能直接用补码参与计算，所以要换成原码并去除符号位。在开始的时候根据两数记下乘积的正负值，计算完毕之后再赋回去。</p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 乘法</span></span><br><span class="line"><span class="comment"> * @param ini_x </span></span><br><span class="line"><span class="comment"> * @param ini_y </span></span><br><span class="line"><span class="comment"> * @return u32 积</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">u32 <span class="title">multiplication</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> negative_flag=<span class="number">0</span>;</span><br><span class="line">    u32 ans=<span class="number">0</span>, x=ini_x, y=ini_y;</span><br><span class="line">    <span class="comment">//判断积正负</span></span><br><span class="line">    <span class="keyword">if</span>( ( (x&amp;<span class="number">0x80000000</span>) &amp;&amp; !(y&amp;<span class="number">0x80000000</span>) )||( !(x&amp;<span class="number">0x80000000</span>) &amp;&amp; (y&amp;<span class="number">0x80000000</span>) ) ) &#123;negative_flag=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">//要转换为原码并去掉符号位</span></span><br><span class="line">    x = <span class="built_in">back_com</span>(x);</span><br><span class="line">    y = <span class="built_in">back_com</span>(y);</span><br><span class="line">    x &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    y &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="comment">//借鉴竖乘法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">31</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">0x01</span>) &#123;ans = <span class="built_in">addition</span>(ans,x);&#125;</span><br><span class="line">        y = y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        x = x&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y == <span class="number">0</span>) &#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加上正负号</span></span><br><span class="line">    <span class="keyword">if</span> (negative_flag) </span><br><span class="line">    &#123;</span><br><span class="line">        ans |= <span class="number">0x80000000</span>;<span class="comment">//这个时候依然是原码，想直接用%d，要转换为补码</span></span><br><span class="line">        ans = <span class="built_in">get_com</span>(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//DEBUG调试</span></span><br><span class="line">    <span class="comment">//printf(&quot;DE<span class="doctag">BUG:</span> %d multiply %d = %d\r\n&quot;,ini_x,ini_y,ans);</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>​    因为除法有<strong>商</strong>和<strong>余数</strong>，所以用了一个结构体方便存储。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 除法答案结构体</span></span><br><span class="line"><span class="comment"> * @param ans 商</span></span><br><span class="line"><span class="comment"> * @param mod 余数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">__ans_division_t</span>&#123;</span><br><span class="line">    u32 ans;</span><br><span class="line">    u32 mod;</span><br><span class="line">&#125;<span class="type">ans_division_t</span>;</span><br></pre></td></tr></table></figure><h3 id="算法思路-2"><a href="#算法思路-2" class="headerlink" title="算法思路"></a>算法思路</h3><p>​    也是模拟手算流程，在理解了乘法的实现思路后便很容易理解。</p><ul><li>将被除数不断<strong>进位</strong>，即乘上<strong>进制数</strong>，直到恰好比被除数小。</li><li>用被除数除以<strong>进位后的除数</strong>得到<strong>商</strong>（为了区别最终的商把它叫做<em>小商</em>吧），同时<strong>商</strong>加上==小商*进制数^(进位次数)^==</li><li>被除数不断<strong>退位</strong>（除以进制数），同时重复上述操作，直到回到最初大小，即<strong>进位数为0</strong></li></ul><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 除法</span></span><br><span class="line"><span class="comment"> * @param ini_x 被除数</span></span><br><span class="line"><span class="comment"> * @param ini_y 除数</span></span><br><span class="line"><span class="comment"> * @return ans_division_t* 答案指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">ans_division_t</span> *<span class="title">division</span><span class="params">(u32 ini_x, u32 ini_y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">bool</span> negative_flag=<span class="number">0</span>;</span><br><span class="line">    u32 ans=<span class="number">0</span>, carry=<span class="number">0</span>, x=ini_x, y=ini_y;</span><br><span class="line">    <span class="type">ans_division_t</span> *ans_division;</span><br><span class="line">    ans_division = (<span class="type">ans_division_t</span>*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="type">ans_division_t</span>));</span><br><span class="line">    <span class="keyword">if</span>( ( (x&amp;<span class="number">0x80000000</span>) &amp;&amp; !(y&amp;<span class="number">0x80000000</span>) )||( !(x&amp;<span class="number">0x80000000</span>) &amp;&amp; (y&amp;<span class="number">0x80000000</span>) ) ) &#123;negative_flag=<span class="number">1</span>;&#125;</span><br><span class="line">    <span class="comment">//要转换为原码并去掉符号位</span></span><br><span class="line">    x = <span class="built_in">back_com</span>(x);</span><br><span class="line">    y = <span class="built_in">back_com</span>(y);</span><br><span class="line">    x &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    y &amp;= <span class="number">0x7fffffff</span>;</span><br><span class="line">    <span class="comment">//依然是模拟手除流程</span></span><br><span class="line">    <span class="comment">//除数不断进位直至比被除数大</span></span><br><span class="line">    <span class="keyword">while</span>(y &lt; x) </span><br><span class="line">    &#123;</span><br><span class="line">        y = y&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        carry = <span class="built_in">addition</span>(carry,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果能除，商就加上1&lt;&lt;carry，除数再不断右移直至回到本来大小。</span></span><br><span class="line">    <span class="keyword">while</span>(carry)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x&gt;=y)</span><br><span class="line">        &#123;</span><br><span class="line">            ans = <span class="built_in">addition</span>(ans,<span class="number">1</span>&lt;&lt;carry);</span><br><span class="line">            x = <span class="built_in">addition</span>(x,-y);</span><br><span class="line">        &#125;</span><br><span class="line">        y = y&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        carry = <span class="built_in">addition</span>(carry,<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x&gt;=y) </span><br><span class="line">    &#123;</span><br><span class="line">        ans = <span class="built_in">addition</span>(ans,<span class="number">1</span>);</span><br><span class="line">        x = <span class="built_in">addition</span>(x,-y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//赋值</span></span><br><span class="line">    ans_division-&gt;ans = ans;</span><br><span class="line">    ans_division-&gt;mod = x;</span><br><span class="line">    <span class="keyword">return</span> ans_division;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    因为负数的余数比较奇怪，平时也不用，这里没有考虑在内。</p><h2 id="DEBUG"><a href="#DEBUG" class="headerlink" title="DEBUG"></a>DEBUG</h2><p>​    vscode 程序文件不能用中文命名。</p><p>​    在程序运行的时候使用补码记录。即便是<strong>usigned int</strong>，倘若<strong>scanf -9</strong>，对应二进制编码也是<strong>11111111111111111111111111110111</strong>。<strong>int</strong>型同样如此。</p><p>​    所以在运算的时候不需要人为的去转换为补码了，在这方面耽误了不少时间。</p><p>​    而对于同样的一串二进制编码，<strong>printf(“%d”)</strong>和<strong>printf(“%u”)</strong>输出结果是不一样的：%d会自动转换输出原码对应的有符号数；那%u则是会将这个补码当作原码直接换算成十进制输出。</p><p><img src="https://s2.loli.net/2022/10/29/PICY3lTj1Q4OKGS.png" alt="存储形式·1.png"></p><p><img src="https://s2.loli.net/2022/10/29/2SIuUTAJV9tDnqR.png" alt="存储形式2.png"></p><p>​    其余的就是一些逻辑漏洞了，不得不说VScode写代码还是比Keil舒服😁</p><h1 id="有关位运算的一些有意思的题目"><a href="#有关位运算的一些有意思的题目" class="headerlink" title="有关位运算的一些有意思的题目"></a>有关位运算的一些有意思的题目</h1><h2 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h2><blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗</p><p>示例 1:</p><blockquote><p>输入: [2,2,1]<br>输出: 1</p></blockquote><p>示例 2:</p><blockquote><p>输入: [4,1,2,1,2]<br>输出: 4</p></blockquote></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>需要用到异或运算的性质：</p><p>a \^ a = 0<br>a \^ 0 = a<br>a \^ b \^ a = b \^ (a \^ a) = b（交换律和结合律）<br>所以只要全部异或最后结果就是答案</p><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="type">int</span> &amp; num: nums)</span><br><span class="line">        ans ^= num;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比特位计数"><a href="#比特位计数" class="headerlink" title="比特位计数"></a>比特位计数</h2><blockquote><p>给定一个非负整数 n，求从 0 到 n 的所有数字的二进制表达中，分别有多少个 1。</p></blockquote><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>本题可以利用动态规划和位运算进行快速的求解。定义一个数组 dp，其中 dp [i] 表示数字 i 的二进制含有 1 的个数。对于第 i 个数字，如果它二进制的最后一位为 1，那么它含有 1 的个数 则为 dp [i-1] + 1；如果它二进制的最后一位为 0，那么它含有 1 的个数和其算术右移结果相同，即 dp [i&gt;&gt;1]。</p><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countBits</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(num+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= num; ++i)</span><br><span class="line">        dp[i] = i &amp; <span class="number">1</span>? dp[i<span class="number">-1</span>] + <span class="number">1</span>: dp[i&gt;&gt;<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 等价于dp[i] = dp[i&amp;(i-1)] + 1;</span></span><br><span class="line">    <span class="keyword">return</span> dp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 位运算 </tag>
            
            <tag> leecode </tag>
            
            <tag> 四则运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32仿真器程序烧录</title>
      <link href="/2022/10/22/STM32%E4%BB%BF%E7%9C%9F%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95/"/>
      <url>/2022/10/22/STM32%E4%BB%BF%E7%9C%9F%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>​    这几天捯饬了一下烧录程序的方法。主要还是<strong>SWD</strong>烧录，后续应该会尝试其他方法。我最开始的时候就不太会弄，即便手边有个仿真器也没有去用（后来就丢了😂），一直用的是<strong>ISP</strong>下载，不仅效率低，还不能在线调试。所以就整理了一下烧录方法。</p><span id="more"></span><h1 id="STM32仿真器程序烧录"><a href="#STM32仿真器程序烧录" class="headerlink" title="STM32仿真器程序烧录"></a>STM32仿真器程序烧录</h1><h3 id="SWD烧录"><a href="#SWD烧录" class="headerlink" title="SWD烧录"></a>SWD烧录</h3><p>SWD烧录是一种串行调试接口，出去供电与共地只需要两根线即可烧录调试</p><ul><li><strong>SWDIO：</strong> 串行数据线，用于数据的读出和写入;</li><li><strong>SWDCLK：</strong> 串行时钟线，提供所需要的时钟信号;</li></ul><p>下面是官方手册里烧录接口的引脚到GPIO口的映射关系</p><p><img src="https://s2.loli.net/2022/10/22/yxIoZNYtkJiqcvs.png" alt="映射关系.png"></p><p>这个是标准的接口排列，要注意的是按照插座边上的<strong>缺口向左</strong>的方向来查看。</p><p><img src="https://s2.loli.net/2022/10/22/NxQRpn7YiqlcZ9j.png" alt="swd_jtag插座.png"></p><p>一般情况下大多数单片机的 JTAG 接口和 SWDIO 接口是复用的，下面就是MINI板的原理图</p><p><img src="https://s2.loli.net/2022/10/22/hPSMBDUczKI6gOZ.png" alt="MINIswd插座.png"></p><h4 id="J-link"><a href="#J-link" class="headerlink" title="J-link"></a>J-link</h4><p>这个是比较常见也比较便宜的一款J-link，只有<strong>3.3vVCC、SWDIO、SWCLK、GND</strong>四根线，接线方式也十分的简单 。</p><p><img src="https://s2.loli.net/2022/10/22/jM2wkymvznOZtS9.jpg" alt="廉价j-link.jpg" style="zoom:50%;" /></p><p>像<strong>STM32C8T6、openCRP</strong>等等已经给出这四个接口的板子直接接上就好了</p><p><img src="https://s2.loli.net/2022/10/22/RGTbYQp9D8sUexm.jpg" alt="swd接口.jpg"></p><p>如果是20脚标准接口的话对照上面的图片找到对应的引脚直接接上即可。</p><p><img src="https://s2.loli.net/2022/10/22/EMTGCtwVFrAia9I.jpg" alt="廉价j-link接线.jpg"></p><p>​    如果实在找不到接口呢，直接把<strong>SWDIO、SWCLK</strong>接在<strong>PA13、PA14</strong>，再供电共地也是一样可以正常烧录的。    </p><p>​    经过测试呢，可以正常烧录，但是会<strong>供电不足</strong>。其中<strong>C8T6和openCRP</strong>的<strong>5V</strong>引脚电压不够，不过程序倒是可以正常运行；而<strong>MINI</strong>则是程序无法正常运行。这个具体情况还与各个板子的PCB设计有关。一般保险起见的话，需要<strong>额外供电</strong>。</p><h4 id="ST-link"><a href="#ST-link" class="headerlink" title="ST-link"></a>ST-link</h4><p>这也是很常见的一款ST-link</p><p><img src="https://s2.loli.net/2022/10/22/wQTMaopVhKlZq7g.jpg" alt="ST-link.jpg"></p><p>​    如果能直接用20脚的接口就很方便。不行的话也可以直接对照前面的图片把<strong>SWD</strong>对应的四根线接出来。</p><p>​    和板子的接线方法与之前都是一样的。</p><h4 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h4><p>这里用的是<strong>MDK5</strong>或者叫<strong>Keil</strong></p><ol><li>首先是点开<strong>魔术棒</strong>，选择对应的调试器<img src="https://s2.loli.net/2022/10/22/9botRpUDXFnAEqs.png" alt="config.png"></li><li>然后进入<strong>settings</strong>选择烧录方式和烧录速度<img src="https://s2.loli.net/2022/10/22/mxFHa8b52YNCoiJ.jpg" alt="config2.jpg"></li><li>然后可以检查一下烧录算法和自己的芯片型号是不是对应的。<img src="https://s2.loli.net/2022/10/22/1xEaqv8ANcwoJsX.jpg" alt="config3.jpg"></li><li>最后点击<strong>load</strong>按钮就可以烧录了。</li></ol><h3 id="ISP烧录"><a href="#ISP烧录" class="headerlink" title="ISP烧录"></a>ISP烧录</h3>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS串口通讯</title>
      <link href="/2022/08/29/ROS-USART-STM32/"/>
      <url>/2022/08/29/ROS-USART-STM32/</url>
      
        <content type="html"><![CDATA[<p>​    简单记录了尝试使用ROS与STM32通讯的过程，包括踩的一点坑，其中一些低级问题实在是有点让人哭笑不得😂</p><span id="more"></span><h1 id="ROS串口通讯"><a href="#ROS串口通讯" class="headerlink" title="ROS串口通讯"></a>ROS串口通讯</h1><h2 id="ROS串口通讯配置"><a href="#ROS串口通讯配置" class="headerlink" title="ROS串口通讯配置"></a>ROS串口通讯配置</h2><h3 id="Ubuntu20-04手动获取Serial包"><a href="#Ubuntu20-04手动获取Serial包" class="headerlink" title="Ubuntu20.04手动获取Serial包"></a>Ubuntu20.04手动获取Serial包</h3><h3 id="linux-ros-串口权限获取"><a href="#linux-ros-串口权限获取" class="headerlink" title="linux/ros 串口权限获取"></a>linux/ros 串口权限获取</h3><p>转载自<a href="https://blog.csdn.net/qq_16775293/article/details/82822851?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-0-82822851-blog-55259778.wap_relevant_multi_platform_whitelistv1&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1">(9条消息) Linux/ROS——获取串口权限_不懂音乐的欣赏者的博客-CSDN博客</a></p><p>我这里的串口号是<strong>/dev/ttyTHS1</strong>，需要适当变动</p><h4 id="永久解决串口权限问题"><a href="#永久解决串口权限问题" class="headerlink" title="永久解决串口权限问题"></a>永久解决串口权限问题</h4><p>（我试了一下，但是失败了）</p><p>创建ttyUSB权限规则文件etc/udev/rules.d/70-ttyUSB.rules</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim -p /etc/udev/rules.d/70-ttyUSB.rules</span><br></pre></td></tr></table></figure><p>在<strong>70-ttyUSB.rules</strong>文件中写入下列代码</p><p>KERNEL==”ttyUSB*”, OWNER=”root”, GROUP=”root”, MODE=”0666”<br>保存即可,重启或注销用户在登录后生效</p><h4 id="临时获取串口权限"><a href="#临时获取串口权限" class="headerlink" title="临时获取串口权限"></a>临时获取串口权限</h4><p>先查看插入电脑的<strong>串口号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/ | grep ttyUSB</span><br></pre></td></tr></table></figure><p>知道串口号之后对指定串口赋予权限,以<strong>ttyUSB0</strong>为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+rw /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>不用重启即可生效</p><h3 id="代码编写问题"><a href="#代码编写问题" class="headerlink" title="代码编写问题"></a>代码编写问题</h3><h2 id="Jetson-nano与STM32通讯"><a href="#Jetson-nano与STM32通讯" class="headerlink" title="Jetson nano与STM32通讯"></a>Jetson nano与STM32通讯</h2><h3 id="jetson-nano串口"><a href="#jetson-nano串口" class="headerlink" title="jetson nano串口"></a>jetson nano串口</h3><p>引脚图，直接连即可。</p><p><img src="https://s2.loli.net/2022/10/22/x8melhw2bcjAgqV.jpg" alt="nano_usart.jpg"></p><h3 id="ROS与32串口通讯（ROS端）只能接收不能发送"><a href="#ROS与32串口通讯（ROS端）只能接收不能发送" class="headerlink" title="ROS与32串口通讯（ROS端）只能接收不能发送"></a>ROS与32串口通讯（ROS端）只能接收不能发送</h3><p>​    被这个问题卡了很久。根据情况描述，既然都能正常接收了为什么发送会失败呢？</p><h4 id="ROS端"><a href="#ROS端" class="headerlink" title="ROS端"></a>ROS端</h4><p>​    在ROS端串口输出一个字符串所用到的函数是<strong>ser.write（string value）</strong>，在定时器的回调函数里面同时调用。首先就是检查定时器回调函数是否被成功调用，读取数据和发送数据都是在这个回调函数里调用的，那么基本上是没问题的，<strong>ROS_INFO</strong>一下确实没问题。同理<strong>SendMsgs( )</strong>一样成功调用了。那至少能肯定，<strong>write( )</strong>函数肯定被调用了呀。</p><p>​    中间还出了一点岔子，就是代码中不小心打上了一点乱码，结果编译出问题。但是编译日志也没有报错，我虽然看着和原来的不一样，但是没有太在意。但是这就导致了之前改完代码后好几次编译都是不通过的，一直运行的也是那个有问题的节点代码。所以如果编译日志同平时比较为反常，要当心一下。</p><p>​    接下来将<strong>nano</strong>的<strong>TX，RX</strong>短接，判断到底是不是nano端的问题。发现确实能自己接收到自己的消息，那就没问题了</p><p>​    nano端没问题了，估计就是32端的问题了。ros只能接受不能发送，是不是<strong>rx</strong>接对了但<strong>tx</strong>接错了呢？</p><blockquote><p>nano 8：TX——RX：stm32 PA10</p><p>nano 10: RX——TX：stm32 PA9</p></blockquote><p>再检验一遍着实无误。</p><h4 id="32端"><a href="#32端" class="headerlink" title="32端"></a>32端</h4><p>​    32端没有再配置一个串口，使用<strong>oled屏</strong>DEBUG，nano端使用cutecom通讯正常，32能接收到消息，换成ros发消息后32却是一点反应都没有，那这个时候就想到看看<strong>串口中断函数</strong>到底有没有被调用，32到底有没有接收到消息。我在该函数里面加了些语句：如果串口中断函数被调用的话oled就会显示。</p><p>​    那结果是没有反应。</p><p>​    实际上控制oled显示的时候输完内容，要加个<strong>refresh</strong>。同时<strong>while( )</strong>里在不断<strong>Set_Z( )</strong>,里面也会不断更新内容然后refresh，所以其实串口中断是被调用了的，但在这样的情况下看不到反应。最后是使用keil的<strong>在线调试功能</strong>设置<strong>断点</strong>发现的，其实调用了。这个时候再看一下函数关于接收到的消息的过滤，其实正点原子也说过——<strong>发送新行</strong>。cutecom会，但ros不会。最终在要发送的字符串后面加上<strong>\r\n</strong>，DEBUG结束。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul><li>函数调用因oled错误使用检查失败。</li><li>不会使用Jlink在线调试</li><li>忽视了ros和cutecom细节上的输出差异。</li></ul><p>如果这三点有一点不出问题的话，或许都能够早些找到，错误。在此非常感谢师兄的指点！</p><h2 id="LattePanda与其Arduino通讯"><a href="#LattePanda与其Arduino通讯" class="headerlink" title="LattePanda与其Arduino通讯"></a>LattePanda与其Arduino通讯</h2><p>本来打算使用stm32进行下游设备的控制，但是发现LattePanda集成了一块<strong>arduino</strong>，不好好利用一下实在是太可惜了。</p><h3 id="Arduino-IDE安装"><a href="#Arduino-IDE安装" class="headerlink" title="Arduino IDE安装"></a>Arduino IDE安装</h3><p>​    在官网<a href="https://www.arduino.cc/en/software">Software | Arduino</a>下载Linux版本的安装包。可是下载<strong>2.0.0</strong>版本的会显示<em>没有可执行的软件</em>，所以最后选择了<strong>1.8.19</strong>。lattepanda对应的版本是<strong>linux 64 bits</strong></p><p>在安装目录得到了<strong>.tar.xz</strong>文件，运行解压命令</p><p><code>tar -xvf arduino-1.8.19-linux64.tar.xz</code></p><p>进入解压得到的安装目录，运行安装脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd arduino-1.8.19/</span><br><span class="line">sudo ./install.sh</span><br></pre></td></tr></table></figure><p>看到返回 <em>done!</em> 后安装成功</p><h3 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h3><p>​    平时用电脑给arduino烧录程序需要用一根数据线将二者连接起来。那在lattepanda上就相当于把这个数据线在板子上画好了，再把电脑和arduino粘一块儿</p><p>​    这个数据线对应的串口号是<strong>/dev/ttyACM0</strong>；</p><p>​    对应的芯片型号是<strong>ATmega32u4</strong>，这在IDE里面找不到，实际上也叫<strong>Arduino Leonardo</strong></p><p>​    之后就可以烧程序和通讯了。</p><h3 id="移植ROS包时遇到的一点小问题"><a href="#移植ROS包时遇到的一点小问题" class="headerlink" title="移植ROS包时遇到的一点小问题"></a>移植ROS包时遇到的一点小问题</h3>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
            <tag> ROS </tag>
            
            <tag> USART </tag>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
