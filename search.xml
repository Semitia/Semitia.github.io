<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>STM32仿真器程序烧录</title>
      <link href="/2022/10/22/STM32%E4%BB%BF%E7%9C%9F%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95/"/>
      <url>/2022/10/22/STM32%E4%BB%BF%E7%9C%9F%E5%99%A8%E7%A8%8B%E5%BA%8F%E7%83%A7%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>​这几天捯饬了一下烧录程序的方法。主要还是<strong>SWD</strong>烧录，后续应该会尝试其他方法。我最开始的时候就不太会弄，即便手边有个仿真器也没有去用（后来就丢了😂），一直用的是<strong>ISP</strong>下载，不仅效率低，还不能在线调试。所以就整理了一下烧录方法。</p><span id="more"></span><h1 id="STM32仿真器程序烧录"><a href="#STM32仿真器程序烧录" class="headerlink" title="STM32仿真器程序烧录"></a>STM32仿真器程序烧录</h1><h3 id="SWD烧录"><a href="#SWD烧录" class="headerlink" title="SWD烧录"></a>SWD烧录</h3><p>SWD烧录是一种串行调试接口，出去供电与共地只需要两根线即可烧录调试</p><ul><li><strong>SWDIO：</strong> 串行数据线，用于数据的读出和写入;</li><li><strong>SWDCLK：</strong> 串行时钟线，提供所需要的时钟信号;</li></ul><p>下面是官方手册里烧录接口的引脚到GPIO口的映射关系</p><p><img src="/./images/%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB.png" alt="映射关系"></p><p>这个是标准的接口排列，要注意的是按照插座边上的<strong>缺口向左</strong>的方向来查看。</p><p><img src="/.%5Cimages%5Cswd_jtag%E6%8F%92%E5%BA%A7.png" alt="swd_jtag插座"></p><p>一般情况下大多数单片机的 JTAG 接口和 SWDIO 接口是复用的，下面就是MINI板的原理图</p><p><img src="/.%5Cimages%5CMINIswd%E6%8F%92%E5%BA%A7.png" alt="MINIswd插座"></p><h4 id="J-link"><a href="#J-link" class="headerlink" title="J-link"></a>J-link</h4><p>这个是比较常见也比较便宜的一款J-link，只有<strong>3.3vVCC、SWDIO、SWCLK、GND</strong>四根线，接线方式也十分的简单 。</p><img src=".\images\廉价j-link.jpg" alt="廉价j-link" style="zoom:50%;" /><p>像<strong>STM32C8T6、openCRP</strong>等等已经给出这四个接口的板子直接接上就好了</p><img src=".\images\swd接口.jpg" alt="swd接口" style="zoom:80%;" /><p>如果是20脚标准接口的话对照上面的图片找到对应的引脚直接接上即可。</p><p><img src="/.%5Cimages%5C%E5%BB%89%E4%BB%B7j-link%E6%8E%A5%E7%BA%BF.jpg" alt="廉价j-link接线"></p><p>​如果实在找不到接口呢，直接把<strong>SWDIO、SWCLK</strong>接在<strong>PA13、PA14</strong>，再供电共地也是一样可以正常烧录的。</p><p>​经过测试呢，可以正常烧录，但是会<strong>供电不足</strong>。其中<strong>C8T6和openCRP</strong>的<strong>5V</strong>引脚电压不够，不过程序倒是可以正常运行；而<strong>MINI</strong>则是程序无法正常运行。这个具体情况还与各个板子的PCB设计有关。一般保险起见的话，需要<strong>额外供电</strong>。</p><h4 id="ST-link"><a href="#ST-link" class="headerlink" title="ST-link"></a>ST-link</h4><p>这也是很常见的一款ST-link</p><p><img src="/.%5Cimages%5CST-link.jpg" alt="ST-link"></p><p>​如果能直接用20脚的接口就很方便。不行的话也可以直接对照前面的图片把<strong>SWD</strong>对应的四根线接出来。</p><p>​和板子的接线方法与之前都是一样的。</p><h4 id="软件配置"><a href="#软件配置" class="headerlink" title="软件配置"></a>软件配置</h4><p>这里用的是<strong>MDK5</strong>或者叫<strong>Keil</strong></p><ol><li>首先是点开<strong>魔术棒</strong>，选择对应的调试器<img src="/.%5Cimages%5Cconfig.png" alt="config"></li><li>然后进入<strong>settings</strong>选择烧录方式和烧录速度<img src="/.%5Cimages%5Cconfig2.jpg" alt="config2"></li><li>然后可以检查一下烧录算法和自己的芯片型号是不是对应的。<img src="/.%5Cimages%5Cconfig3.jpg" alt="config3"></li><li>最后点击<strong>load</strong>按钮就可以烧录了。</li></ol><h3 id="ISP烧录"><a href="#ISP烧录" class="headerlink" title="ISP烧录"></a>ISP烧录</h3>]]></content>
      
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS串口通讯</title>
      <link href="/2022/08/29/ROS-USART-STM32/"/>
      <url>/2022/08/29/ROS-USART-STM32/</url>
      
        <content type="html"><![CDATA[<p>​简单记录了尝试使用ROS与STM32通讯的过程，包括踩的一点坑，其中一些低级问题实在是有点让人哭笑不得😂</p><span id="more"></span><h1 id="ROS串口通讯"><a href="#ROS串口通讯" class="headerlink" title="ROS串口通讯"></a>ROS串口通讯</h1><h2 id="ROS串口通讯配置"><a href="#ROS串口通讯配置" class="headerlink" title="ROS串口通讯配置"></a>ROS串口通讯配置</h2><h3 id="Ubuntu20-04手动获取Serial包"><a href="#Ubuntu20-04手动获取Serial包" class="headerlink" title="Ubuntu20.04手动获取Serial包"></a>Ubuntu20.04手动获取Serial包</h3><h3 id="linux-x2F-ros-串口权限获取"><a href="#linux-x2F-ros-串口权限获取" class="headerlink" title="linux&#x2F;ros 串口权限获取"></a>linux&#x2F;ros 串口权限获取</h3><p>转载自<a href="https://blog.csdn.net/qq_16775293/article/details/82822851?utm_medium=distribute.wap_relevant.none-task-blog-2~default~baidujs_title~default-0-82822851-blog-55259778.wap_relevant_multi_platform_whitelistv1&spm=1001.2101.3001.4242.1&utm_relevant_index=1">(9条消息) Linux&#x2F;ROS——获取串口权限_不懂音乐的欣赏者的博客-CSDN博客</a></p><p>我这里的串口号是**&#x2F;dev&#x2F;ttyTHS1**，需要适当变动</p><h4 id="永久解决串口权限问题"><a href="#永久解决串口权限问题" class="headerlink" title="永久解决串口权限问题"></a>永久解决串口权限问题</h4><p>（我试了一下，但是失败了）</p><p>创建ttyUSB权限规则文件etc&#x2F;udev&#x2F;rules.d&#x2F;70-ttyUSB.rules</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim -p /etc/udev/rules.d/70-ttyUSB.rules</span><br></pre></td></tr></table></figure><p>在<strong>70-ttyUSB.rules</strong>文件中写入下列代码</p><p>KERNEL&#x3D;&#x3D;”ttyUSB*”, OWNER&#x3D;”root”, GROUP&#x3D;”root”, MODE&#x3D;”0666”<br>保存即可,重启或注销用户在登录后生效</p><h4 id="临时获取串口权限"><a href="#临时获取串口权限" class="headerlink" title="临时获取串口权限"></a>临时获取串口权限</h4><p>先查看插入电脑的<strong>串口号</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /dev/ | grep ttyUSB</span><br></pre></td></tr></table></figure><p>知道串口号之后对指定串口赋予权限,以<strong>ttyUSB0</strong>为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod a+rw /dev/ttyUSB0</span><br></pre></td></tr></table></figure><p>不用重启即可生效</p><h3 id="代码编写问题"><a href="#代码编写问题" class="headerlink" title="代码编写问题"></a>代码编写问题</h3><h2 id="Jetson-nano与STM32通讯"><a href="#Jetson-nano与STM32通讯" class="headerlink" title="Jetson nano与STM32通讯"></a>Jetson nano与STM32通讯</h2><h3 id="jetson-nano串口"><a href="#jetson-nano串口" class="headerlink" title="jetson nano串口"></a>jetson nano串口</h3><p>引脚图，直接连即可。</p><p><img src="/./images/nano_usart.png" alt="nano_usart"></p><h3 id="ROS与32串口通讯（ROS端）只能接收不能发送"><a href="#ROS与32串口通讯（ROS端）只能接收不能发送" class="headerlink" title="ROS与32串口通讯（ROS端）只能接收不能发送"></a>ROS与32串口通讯（ROS端）只能接收不能发送</h3><p>​被这个问题卡了很久。根据情况描述，既然都能正常接收了为什么发送会失败呢？</p><h4 id="ROS端"><a href="#ROS端" class="headerlink" title="ROS端"></a>ROS端</h4><p>​在ROS端串口输出一个字符串所用到的函数是<strong>ser.write（string value）</strong>，在定时器的回调函数里面同时调用。首先就是检查定时器回调函数是否被成功调用，读取数据和发送数据都是在这个回调函数里调用的，那么基本上是没问题的，<strong>ROS_INFO</strong>一下确实没问题。同理**SendMsgs( )<strong>一样成功调用了。那至少能肯定，</strong>write( )**函数肯定被调用了呀。</p><p>​中间还出了一点岔子，就是代码中不小心打上了一点乱码，结果编译出问题。但是编译日志也没有报错，我虽然看着和原来的不一样，但是没有太在意。但是这就导致了之前改完代码后好几次编译都是不通过的，一直运行的也是那个有问题的节点代码。所以如果编译日志同平时比较为反常，要当心一下。</p><p>​接下来将<strong>nano</strong>的<strong>TX，RX</strong>短接，判断到底是不是nano端的问题。发现确实能自己接收到自己的消息，那就没问题了</p><p>​nano端没问题了，估计就是32端的问题了。ros只能接受不能发送，是不是<strong>rx</strong>接对了但<strong>tx</strong>接错了呢？</p><blockquote><p>nano 8：TX——RX：stm32 PA10</p><p>nano 10: RX——TX：stm32 PA9</p></blockquote><p>再检验一遍着实无误。</p><h4 id="32端"><a href="#32端" class="headerlink" title="32端"></a>32端</h4><p>​32端没有再配置一个串口，使用<strong>oled屏</strong>DEBUG，nano端使用cutecom通讯正常，32能接收到消息，换成ros发消息后32却是一点反应都没有，那这个时候就想到看看<strong>串口中断函数</strong>到底有没有被调用，32到底有没有接收到消息。我在该函数里面加了些语句：如果串口中断函数被调用的话oled就会显示。</p><p>​那结果是没有反应。</p><p>​实际上控制oled显示的时候输完内容，要加个<strong>refresh</strong>。同时<strong>while( )<strong>里在不断</strong>Set_Z( )</strong>,里面也会不断更新内容然后refresh，所以其实串口中断是被调用了的，但在这样的情况下看不到反应。最后是使用keil的<strong>在线调试功能</strong>设置<strong>断点</strong>发现的，其实调用了。这个时候再看一下函数关于接收到的消息的过滤，其实正点原子也说过——<strong>发送新行</strong>。cutecom会，但ros不会。最终在要发送的字符串后面加上<strong>\r\n</strong>，DEBUG结束。</p><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><ul><li>函数调用因oled错误使用检查失败。</li><li>不会使用Jlink在线调试</li><li>忽视了ros和cutecom细节上的输出差异。</li></ul><p>如果这三点有一点不出问题的话，或许都能够早些找到，错误。在此非常感谢师兄的指点！</p><h2 id="LattePanda与其Arduino通讯"><a href="#LattePanda与其Arduino通讯" class="headerlink" title="LattePanda与其Arduino通讯"></a>LattePanda与其Arduino通讯</h2><p>本来打算使用stm32进行下游设备的控制，但是发现LattePanda集成了一块<strong>arduino</strong>，不好好利用一下实在是太可惜了。</p><h3 id="Arduino-IDE安装"><a href="#Arduino-IDE安装" class="headerlink" title="Arduino IDE安装"></a>Arduino IDE安装</h3><p>​在官网<a href="https://www.arduino.cc/en/software">Software | Arduino</a>下载Linux版本的安装包。可是下载<strong>2.0.0</strong>版本的会显示<em>没有可执行的软件</em>，所以最后选择了<strong>1.8.19</strong>。lattepanda对应的版本是<strong>linux 64 bits</strong></p><p>在安装目录得到了**.tar.xz**文件，运行解压命令</p><p><code> tar -xvf arduino-1.8.19-linux64.tar.xz</code></p><p>进入解压得到的安装目录，运行安装脚本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd arduino-1.8.19/</span><br><span class="line">sudo ./install.sh</span><br></pre></td></tr></table></figure><p>看到返回 <em>done!</em> 后安装成功</p><h3 id="连接配置"><a href="#连接配置" class="headerlink" title="连接配置"></a>连接配置</h3><p>​平时用电脑给arduino烧录程序需要用一根数据线将二者连接起来。那在lattepanda上就相当于把这个数据线在板子上画好了，再把电脑和arduino粘一块儿</p><p>​这个数据线对应的串口号是**&#x2F;dev&#x2F;ttyACM0**；</p><p>​对应的芯片型号是<strong>ATmega32u4</strong>，这在IDE里面找不到，实际上也叫<strong>Arduino Leonardo</strong></p><p>​之后就可以烧程序和通讯了。</p><h3 id="移植ROS包时遇到的一点小问题"><a href="#移植ROS包时遇到的一点小问题" class="headerlink" title="移植ROS包时遇到的一点小问题"></a>移植ROS包时遇到的一点小问题</h3>]]></content>
      
      
      
        <tags>
            
            <tag> ROS </tag>
            
            <tag> STM32 </tag>
            
            <tag> USART </tag>
            
            <tag> Arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/08/16/hello-world/"/>
      <url>/2022/08/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
